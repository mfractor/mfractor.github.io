{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nWelcome to the documentation for MFractor, incredible Xamarin tools.\n\n\nLet's get you started:\n\n\nGet Started:\n\n\n\n\nDownload MFractor\n\n\nInstall MFractor\n\n\n\n\nXamarin.Forms Essentials:\n\n\n\n\nQuickstart Guide\n\n\nXaml Analysis\n\n\nBinding Context Configuration\n\n\nNavigation\n\n\nCode Actions\n\n\n\n\nXamarin.Android Essentials:\n\n\n\n\nQuickstart Guide\n\n\nResource Analysis\n\n\nC# Analysis\n\n\nResource IntelliSense\n\n\nNavigation\n\n\nProject Indexing\n\n\nCode Actions\n\n\n\n\nSupport\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to hello@mfractor.com\n\n\n\n\nThank You!\n\n\nSlowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.\n\n\nThank you for installing and using MFractor. It means the world to me.\n\n\nMatthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Welcome to the documentation for MFractor, incredible Xamarin tools.  Let's get you started:", 
            "title": "Welcome"
        }, 
        {
            "location": "/#get-started", 
            "text": "Download MFractor  Install MFractor", 
            "title": "Get Started:"
        }, 
        {
            "location": "/#xamarinforms-essentials", 
            "text": "Quickstart Guide  Xaml Analysis  Binding Context Configuration  Navigation  Code Actions", 
            "title": "Xamarin.Forms Essentials:"
        }, 
        {
            "location": "/#xamarinandroid-essentials", 
            "text": "Quickstart Guide  Resource Analysis  C# Analysis  Resource IntelliSense  Navigation  Project Indexing  Code Actions", 
            "title": "Xamarin.Android Essentials:"
        }, 
        {
            "location": "/#support", 
            "text": "If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to hello@mfractor.com", 
            "title": "Support"
        }, 
        {
            "location": "/#thank-you", 
            "text": "Slowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.  Thank you for installing and using MFractor. It means the world to me.  Matthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Thank You!"
        }, 
        {
            "location": "/setup/", 
            "text": "Setup\n\n\nInstalling, activating and updating MFractor\n\n\nIntroduction\n\n\nThis document covers how to install, activate, update and uninstall MFractor for Xamarin Studio.\n\n\nGet MFractor\n\n\nThe latest version of MFractor for Xamarin Studio can be downloaded from the addin server, \naddins.mfractor.com/MFractor.mpack\n.\n\n\nIf you'd like an older version of MFractor, these can be found under our old release archives. Simply navigate to \naddins.mfractor.com/releases\n, open the folder for the version you'd like and download the .mpack file.\n\n\nInstall MFractor Manually\n\n\nMFractor can be installed directly through the addin manager's \nInstall from file\n button.\n\n\nFirstly, download the latest version of MFractor for Xamarin studio at \naddins.mfractor.com/MFractor.mpack\n\n\nOpen up Xamarin Studio and click on the \nXamarin Studio\n menu and then \nAddins...\n\n\n\n\nWithin the Addin Manager, click the \nInstall from file\n button in the bottom left of the Addin Manager.\n\n\nBrowse to \nMFractor.mpack\n and then select \nOpen\n:\n\n\n\n\nInstall Using MFractor.Installer\n\n\nWe can also install install MFractor into Xamarin Studio by using the MFractor.Installer helper addin.\n\n\nThis addin lives inside the Addin Manager in Xamarin Studio, under \nGallery\n -\n \nIDE extensions\n.\n\n\nOpen up Xamarin Studio and click on the \nXamarin Studio\n menu and then \nAddins...\n\n\n\n\nOnce the Addin Manager opens, click \nGallery\n and under \nIDE extensions\n locate \nMFractor.Installer\n. If this isn't present, hit the \nRefresh\n button to update the Gallery listings.\n\n\n\n\nOnce you've located \nMFractor.Installer\n, left click on it to select it. In the right hand detail view, click \nInstall\n. Xamarin Studio will prompt you for confirmation, click \nInstall\n\n\n\n\nYou will then see a download dialog appear and MFractor will download and install.\n\n\n\n\nActivation\n\n\nTo use MFractor, you'll need activate it using your email address.\n\n\nFirst things first, \nclose the Addin Manager\n. There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.\n\n\nTo activate MFractor, enter you email and then click \nActivate\n.\n\n\n\n\nTada! You are now ready to rock. Why not learn how to use MFractor for \nXamarin.Forms\n or \nXamarin.Android\n next?\n\n\nUpdating\n\n\nWhen MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.\n\n\nThis means that Xamarin Studio will automatically prompt you that an update is available.\n\n\nHowever, you can check for udpate at any time by opening the \nXamarin Studio\n main menu and selecting \nCheck for Updates...\n\n\n\n\nXamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!\n\n\nUninstalling MFractor\n\n\nYou can uninstall MFractor through the addin manager at any time.\n\n\nSelect the \nXamarin Studio\n main menu and then \nAddins\n\n\nUnder \nGallery\n then \nIDE extensions\n select the MFractor addin list item and then click \nUninstall\n\n\nYou will be prompted to uninstall the addin, confirm uninstallation by clicking \nUninstall", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#setup", 
            "text": "Installing, activating and updating MFractor", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#introduction", 
            "text": "This document covers how to install, activate, update and uninstall MFractor for Xamarin Studio.", 
            "title": "Introduction"
        }, 
        {
            "location": "/setup/#get-mfractor", 
            "text": "The latest version of MFractor for Xamarin Studio can be downloaded from the addin server,  addins.mfractor.com/MFractor.mpack .  If you'd like an older version of MFractor, these can be found under our old release archives. Simply navigate to  addins.mfractor.com/releases , open the folder for the version you'd like and download the .mpack file.", 
            "title": "Get MFractor"
        }, 
        {
            "location": "/setup/#install-mfractor-manually", 
            "text": "MFractor can be installed directly through the addin manager's  Install from file  button.  Firstly, download the latest version of MFractor for Xamarin studio at  addins.mfractor.com/MFractor.mpack  Open up Xamarin Studio and click on the  Xamarin Studio  menu and then  Addins...   Within the Addin Manager, click the  Install from file  button in the bottom left of the Addin Manager.  Browse to  MFractor.mpack  and then select  Open :", 
            "title": "Install MFractor Manually"
        }, 
        {
            "location": "/setup/#install-using-mfractorinstaller", 
            "text": "We can also install install MFractor into Xamarin Studio by using the MFractor.Installer helper addin.  This addin lives inside the Addin Manager in Xamarin Studio, under  Gallery  -   IDE extensions .  Open up Xamarin Studio and click on the  Xamarin Studio  menu and then  Addins...   Once the Addin Manager opens, click  Gallery  and under  IDE extensions  locate  MFractor.Installer . If this isn't present, hit the  Refresh  button to update the Gallery listings.   Once you've located  MFractor.Installer , left click on it to select it. In the right hand detail view, click  Install . Xamarin Studio will prompt you for confirmation, click  Install   You will then see a download dialog appear and MFractor will download and install.", 
            "title": "Install Using MFractor.Installer"
        }, 
        {
            "location": "/setup/#activation", 
            "text": "To use MFractor, you'll need activate it using your email address.  First things first,  close the Addin Manager . There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.  To activate MFractor, enter you email and then click  Activate .   Tada! You are now ready to rock. Why not learn how to use MFractor for  Xamarin.Forms  or  Xamarin.Android  next?", 
            "title": "Activation"
        }, 
        {
            "location": "/setup/#updating", 
            "text": "When MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.  This means that Xamarin Studio will automatically prompt you that an update is available.  However, you can check for udpate at any time by opening the  Xamarin Studio  main menu and selecting  Check for Updates...   Xamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!", 
            "title": "Updating"
        }, 
        {
            "location": "/setup/#uninstalling-mfractor", 
            "text": "You can uninstall MFractor through the addin manager at any time.  Select the  Xamarin Studio  main menu and then  Addins  Under  Gallery  then  IDE extensions  select the MFractor addin list item and then click  Uninstall  You will be prompted to uninstall the addin, confirm uninstallation by clicking  Uninstall", 
            "title": "Uninstalling MFractor"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nGeting help for MFractor when something's amiss or giving feedback\n\n\nHow can I get help or support?\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to \nhello@mfractor.com\n\n\n\n\nWhat version of Xamarin Studio is MFractor compatible with?\n\n\nThe latest version of MFractor always targets the current stable channel version of Xamarin Studio.\n\n\nHow do I get started with MFractor?\n\n\nMFractor does a lot so it may take a little while to learn its ins and outs. If you'd like to learn how to best use it, you have a few options:\n\n\n\n\nGet started by reading the \nXamarin.Forms Quickstart\n and \nXamarin.Android Quickstart\n; these are a quick overview of the most used features.\n\n\nRead the in-depth docs for both Xamarin.Forms and Xamarin.Android (se the menu to the left). Each article covers a feature in-depth and fully explains how to use it.\n\n\nRead the \ntutorials\n for and in-depth exploration of a feature from first concepts to practical use cases.\n\n\nDrop into the \n#mfractor Xamarin Slack sub-channel\n and start chatting to me (Matthew Robbins). I'm happy to answer any questions you have.\n\n\n\n\nHow do I file a bug report?\n\n\nIf you notice a bug while you are using MFractor, please file a bug report by taking the following steps:\n\n\n\n\nPrepare a short 2-3 sentence description of the bug, the steps you took that triggered it and the symptoms of the bug.\n\n\nCopy MFractors version information by opening the \nAbout\n dialog (\nHelp\n -\n \nMFractor\n -\n \nAbout\n) and click \nCopy Build Details Into Clipboard\n.\n\n\nEmail the description and build version to \nhello@mfractor.com\n.\n\n\n\n\nHow do I install or update the Android SDK meta-data bundle?\n\n\nIf you'd like to activate tooltips and go-to declaration support for Android SDK resources (for example: \n@android:string/my_sting\n), you can install MFractors Android SDK meta-data.\n\n\nTo install, go to the \nHelp\n main menu, select \nMFractor\n and then \nInstall Android SDK Meta-Data\n:\n\n\n\n\nYou will be prompted to confirm the installation; installing the meta-data will wipe any existing installation!\n\n\n\n\nMFractor will then download and install the latest meta-data bundle:\n\n\n\n\nWhen the installation has completed, just close the installation success message; there is no need to restart Xamarin Studio.\n\n\nWhat is the .droidres folder?\n\n\nThe \n.droidres\n folder contains the meta-data that's generated when MFractor indexes your Android projects. This meta-data is used to power resource tooltips and resource go-to declaration for Android projets.\n\n\nIt is safe to delete whenever you want however some features for Android development won't work correctly without it.\n\n\nShould I check .droidres into source control?\n\n\nNo, you should not check \n.droidres\n into your source control.\n\n\nIf you are using git, append the following text to the end of your \n.gitignore\n to exclude \n.droidres\n:\n\n\n# MFractor's Android resource meta-data cache\n*.droidres/", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "Geting help for MFractor when something's amiss or giving feedback", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-can-i-get-help-or-support", 
            "text": "If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to  hello@mfractor.com", 
            "title": "How can I get help or support?"
        }, 
        {
            "location": "/faq/#what-version-of-xamarin-studio-is-mfractor-compatible-with", 
            "text": "The latest version of MFractor always targets the current stable channel version of Xamarin Studio.", 
            "title": "What version of Xamarin Studio is MFractor compatible with?"
        }, 
        {
            "location": "/faq/#how-do-i-get-started-with-mfractor", 
            "text": "MFractor does a lot so it may take a little while to learn its ins and outs. If you'd like to learn how to best use it, you have a few options:   Get started by reading the  Xamarin.Forms Quickstart  and  Xamarin.Android Quickstart ; these are a quick overview of the most used features.  Read the in-depth docs for both Xamarin.Forms and Xamarin.Android (se the menu to the left). Each article covers a feature in-depth and fully explains how to use it.  Read the  tutorials  for and in-depth exploration of a feature from first concepts to practical use cases.  Drop into the  #mfractor Xamarin Slack sub-channel  and start chatting to me (Matthew Robbins). I'm happy to answer any questions you have.", 
            "title": "How do I get started with MFractor?"
        }, 
        {
            "location": "/faq/#how-do-i-file-a-bug-report", 
            "text": "If you notice a bug while you are using MFractor, please file a bug report by taking the following steps:   Prepare a short 2-3 sentence description of the bug, the steps you took that triggered it and the symptoms of the bug.  Copy MFractors version information by opening the  About  dialog ( Help  -   MFractor  -   About ) and click  Copy Build Details Into Clipboard .  Email the description and build version to  hello@mfractor.com .", 
            "title": "How do I file a bug report?"
        }, 
        {
            "location": "/faq/#how-do-i-install-or-update-the-android-sdk-meta-data-bundle", 
            "text": "If you'd like to activate tooltips and go-to declaration support for Android SDK resources (for example:  @android:string/my_sting ), you can install MFractors Android SDK meta-data.  To install, go to the  Help  main menu, select  MFractor  and then  Install Android SDK Meta-Data :   You will be prompted to confirm the installation; installing the meta-data will wipe any existing installation!   MFractor will then download and install the latest meta-data bundle:   When the installation has completed, just close the installation success message; there is no need to restart Xamarin Studio.", 
            "title": "How do I install or update the Android SDK meta-data bundle?"
        }, 
        {
            "location": "/faq/#what-is-the-droidres-folder", 
            "text": "The  .droidres  folder contains the meta-data that's generated when MFractor indexes your Android projects. This meta-data is used to power resource tooltips and resource go-to declaration for Android projets.  It is safe to delete whenever you want however some features for Android development won't work correctly without it.", 
            "title": "What is the .droidres folder?"
        }, 
        {
            "location": "/faq/#should-i-check-droidres-into-source-control", 
            "text": "No, you should not check  .droidres  into your source control.  If you are using git, append the following text to the end of your  .gitignore  to exclude  .droidres :  # MFractor's Android resource meta-data cache\n*.droidres/", 
            "title": "Should I check .droidres into source control?"
        }, 
        {
            "location": "/xamarin-forms-quickstart/", 
            "text": "Xamarin.Forms Quick Start\n\n\nLearn to use the most handy features in MFractor for Xamarin.Forms\n\n\nIntroduction\n\n\nWelcome to the quickstart guide for using MFractor with Xamarin.Forms.\n\n\nThis document explains the most useful features of MFractor for Xamarin.Forms.\n\n\nConfiguring A Binding Context\n\n\nWhen the \nBindingContext\n property is explicitly set for a Xaml view, MFractor can analyse binding expressions and perform refactoring from Xaml to the binding context.\n\n\nWe explicitly configure the binding context using a view model locator:\n\n\nViewModelLocator.cs\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nFor more detail, see \nConfigure Binding Context\n.\n\n\nMvvm Naming Conventions\n\n\nImplicitly associate a view to a ViewModel using these naming conventions:\n\n\n\n\nClasses that end with \nViewModel\n, \nPageModel\n and \nModel\n are assumed to be a view model for a Xaml view.\n\n\nXaml files that end with \nPage\n or \nView\n are assumed to be a xaml view for a view model.\n\n\nWhen a view and view model share the same name without \nPage\n, \nView\n or \nViewModel\n, MFractor assumes an implicit association.\n\n\n\n\nConsider \nLoginPage.xaml\n, \nLoginPage.xaml.cs\n and \nLoginViewMode.cs\n:\n\n\n\n\nLoginPage.xaml\n is considered a xaml view.\n\n\nLoginPage.xaml.cs\n is considered the code behind class.\n\n\nLoginViewModel.cs\n is considered the view model.\n\n\n\n\nFor more detail, see \nImplicit Binding Context Resolution\n.\n\n\nUsing Mvvm Navigation\n\n\nWe can quickly navigate between Views, Code Behind Class and ViewModel when we use the \nMvvm naming conventions\n.\n\n\nRight click and select:\n\n\n\n\nGo-To ViewModel\n when in a Xaml view or code behind class to jump to the ViewModel.\n\n\nGo-To Code Behind Class\n when in a Xaml view or ViewModel to jump to the code behind class.\n\n\nGo-To Xaml View\n when in a code behind class or view model to jump to the Xaml view.\n\n\n\n\nFor more detail, see \nMvvm Navigation\n.\n\n\nXaml Analysis\n\n\nThe Xaml analyser inspects Xaml files for code issues and underlines the issue in either red or yellow.\n\n\n\n\nHover over a xaml issue to view more information on the code issue.\n\n\nRed underlined issues are compilation or runtime errors.\n\n\nYellow underlined issues are compilation warnings.\n\n\nBlue underlined issues are code improvements.\n\n\nTo fix an issueRight click on the issue region and browse to \nFix\n and select the fix you'd like to apply.\n\n\n\n\nFor more detail, see:\n\n\n\n\nXaml Analysis\n\n\nFull List of Xaml Analysers\n\n\n\n\nAccessing Code Actions\n\n\nPress Alt+Return on", 
            "title": "Xamarin.Forms Quickstart"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#xamarinforms-quick-start", 
            "text": "Learn to use the most handy features in MFractor for Xamarin.Forms", 
            "title": "Xamarin.Forms Quick Start"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#introduction", 
            "text": "Welcome to the quickstart guide for using MFractor with Xamarin.Forms.  This document explains the most useful features of MFractor for Xamarin.Forms.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#configuring-a-binding-context", 
            "text": "When the  BindingContext  property is explicitly set for a Xaml view, MFractor can analyse binding expressions and perform refactoring from Xaml to the binding context.  We explicitly configure the binding context using a view model locator:  ViewModelLocator.cs  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   For more detail, see  Configure Binding Context .", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#mvvm-naming-conventions", 
            "text": "Implicitly associate a view to a ViewModel using these naming conventions:   Classes that end with  ViewModel ,  PageModel  and  Model  are assumed to be a view model for a Xaml view.  Xaml files that end with  Page  or  View  are assumed to be a xaml view for a view model.  When a view and view model share the same name without  Page ,  View  or  ViewModel , MFractor assumes an implicit association.   Consider  LoginPage.xaml ,  LoginPage.xaml.cs  and  LoginViewMode.cs :   LoginPage.xaml  is considered a xaml view.  LoginPage.xaml.cs  is considered the code behind class.  LoginViewModel.cs  is considered the view model.   For more detail, see  Implicit Binding Context Resolution .", 
            "title": "Mvvm Naming Conventions"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#using-mvvm-navigation", 
            "text": "We can quickly navigate between Views, Code Behind Class and ViewModel when we use the  Mvvm naming conventions .  Right click and select:   Go-To ViewModel  when in a Xaml view or code behind class to jump to the ViewModel.  Go-To Code Behind Class  when in a Xaml view or ViewModel to jump to the code behind class.  Go-To Xaml View  when in a code behind class or view model to jump to the Xaml view.   For more detail, see  Mvvm Navigation .", 
            "title": "Using Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#xaml-analysis", 
            "text": "The Xaml analyser inspects Xaml files for code issues and underlines the issue in either red or yellow.   Hover over a xaml issue to view more information on the code issue.  Red underlined issues are compilation or runtime errors.  Yellow underlined issues are compilation warnings.  Blue underlined issues are code improvements.  To fix an issueRight click on the issue region and browse to  Fix  and select the fix you'd like to apply.   For more detail, see:   Xaml Analysis  Full List of Xaml Analysers", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#accessing-code-actions", 
            "text": "Press Alt+Return on", 
            "title": "Accessing Code Actions"
        }, 
        {
            "location": "/xamarin-android-quickstart/", 
            "text": "WORK IN PROGRESS\n\n\nXamarin.Android Quickstart\n\n\nLearn to use the most handy features in MFractor for Xamarin.Android\n\n\nIntroduction\n\n\nWelcome to the quick start guide for using MFractor with Xamarin.Android!\n\n\nThis document explains the most useful features of MFractor for Xamarin.Android.\n\n\nProject Resource Indexing\n\n\nWhen an Android project is opened, MFractor needs to \nindex\n the projects resources; this is all files and folders under \nResources\\\n including layouts, menus, drawables, strings, colors etc.\n\n\nWhen the indexing operation finishes, you might see a status message in the top toolbar:\n\n\n\n\nThe indexing will generate a SQL database under a folder named \n.droidres\n; this database contains relational information about each of the Android projects within the current solution which powers most features in MFractor for Xamarin.Android.\n\n\nEach time a resource document is edited, MFractor will re-index that particular file into .droidres database.\n\n\nAt any time you can force a complete re-index of your solution by selecting \nTools\n in the main menu and then \nMFractor - Resync Solution Resources\n.\n\n\nResource Tooltips\n\n\nHover over a resource expression to view a tooltip that lists all configurations of that resource.\n\n\nC# Expression\n\n\nResource.Layout.Toolbar\n\n\n\n\nXml Expression\n\n\n@+id/toolbar\n\n\n\n\nFor example:\n\n\n\n\nGo-To Resource Declaration\n\n\nWhen the caret is inside a C# or Xml resource expression, you can press \nCommand+D\n to jump to the implementation of that resource.\n\n\nWhen a resource has multiple configurations, a selector dialog is displayed where you can select the specific configuration to jump to:\n\n\n\n\nResource IntelliSense\n\n\nMFractor adds IntelliSense support for \nall\n Android resources.\n\n\nTo use resource IntelliSense, simply open a \n.axml\n or \n.xml\n file within your projects \nResources\n folder and start typing.\n\n\nA full list of supported resource IntelliSense modules can be found  \n\n\nResource Code Analysis\n\n\nFind All Resource References\n\n\nC# Code Analysis For Android", 
            "title": "Xamarin.Android Quickstart"
        }, 
        {
            "location": "/xamarin-android-quickstart/#xamarinandroid-quickstart", 
            "text": "Learn to use the most handy features in MFractor for Xamarin.Android", 
            "title": "Xamarin.Android Quickstart"
        }, 
        {
            "location": "/xamarin-android-quickstart/#introduction", 
            "text": "Welcome to the quick start guide for using MFractor with Xamarin.Android!  This document explains the most useful features of MFractor for Xamarin.Android.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android-quickstart/#project-resource-indexing", 
            "text": "When an Android project is opened, MFractor needs to  index  the projects resources; this is all files and folders under  Resources\\  including layouts, menus, drawables, strings, colors etc.  When the indexing operation finishes, you might see a status message in the top toolbar:   The indexing will generate a SQL database under a folder named  .droidres ; this database contains relational information about each of the Android projects within the current solution which powers most features in MFractor for Xamarin.Android.  Each time a resource document is edited, MFractor will re-index that particular file into .droidres database.  At any time you can force a complete re-index of your solution by selecting  Tools  in the main menu and then  MFractor - Resync Solution Resources .", 
            "title": "Project Resource Indexing"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-tooltips", 
            "text": "Hover over a resource expression to view a tooltip that lists all configurations of that resource.  C# Expression  Resource.Layout.Toolbar  Xml Expression  @+id/toolbar  For example:", 
            "title": "Resource Tooltips"
        }, 
        {
            "location": "/xamarin-android-quickstart/#go-to-resource-declaration", 
            "text": "When the caret is inside a C# or Xml resource expression, you can press  Command+D  to jump to the implementation of that resource.  When a resource has multiple configurations, a selector dialog is displayed where you can select the specific configuration to jump to:", 
            "title": "Go-To Resource Declaration"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-intellisense", 
            "text": "MFractor adds IntelliSense support for  all  Android resources.  To use resource IntelliSense, simply open a  .axml  or  .xml  file within your projects  Resources  folder and start typing.  A full list of supported resource IntelliSense modules can be found", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-code-analysis", 
            "text": "", 
            "title": "Resource Code Analysis"
        }, 
        {
            "location": "/xamarin-android-quickstart/#find-all-resource-references", 
            "text": "", 
            "title": "Find All Resource References"
        }, 
        {
            "location": "/xamarin-android-quickstart/#c-code-analysis-for-android", 
            "text": "", 
            "title": "C# Code Analysis For Android"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/", 
            "text": "Configuring A Binding Context\n\n\nPower the refactoring engine and xaml analyser by targeting a binding context\n\n\nIntroduction\n\n\nIn Mvvm architected applications, views use a \nBinding Context\n to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through \ndata binding\n; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts \nThe Mvvm Pattern\n article.\n\n\nWhen working with Xaml, we can specify a binding context to activate binding expression analysis and a variety of BindingContext specific refactorings.\n\n\nWe can specify a binding context \nexplicitly\n via in inline Xaml expression or \nimplicitly\n through the use of common MVVM naming conventions.\n\n\nExplicit Binding Context Resolution\n\n\nIn Xamarin.Forms, all views have the property \nBindingContext\n; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the \nx:Static\n markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:\n\n\n \nEntry BindingContext=\n{x:Static local:MyStaticClass.MyStaticProperty}\n/\n\n\n\n\n\nThis is known as the \nView Model Locator Pattern\n. We implement a static class named \nViewModelLocator\n and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the \nView Model Locator Pattern\n has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent \nView Model Locator\n article.\n\n\nFor example, given a Xaml page named \nLoginPage\n, we can explicitly provide an instance of \nLoginViewModel\n as the binding context like so:\n\n\nViewModelLocator.cs\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nWhen MFractor begins analysis on LoginPage.xaml it will check if any \nBindingContext\n properties have been assigned to. As the root \nContentPage\n assigns a binding context, it will inspect the value component of the \nBindingContext\n attribute, check if it is a Xaml expression and then evaluate it for the return type.\n\n\nFor the \n{x:Static local:ViewModelLocator.LoginViewModel}\n expression, MFractor will resolve the \nViewModelLocator\n class in the \nlocal\n namespace and then grab the C# type of the \nLoginViewModel\n property. This informs MFractor that the page will be bound to a \nLoginViewModel\n instance and therefore to analyse all \nBinding\n expressions against the \nLoginViewModel\n type.\n\n\nExplicit binding context resolution will also work when referencing another element using \nx:Reference\n expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:\n\n\n  \nSwitch x:Name=\nmySwitch\n /\n\n  \nLabel BindingContext=\n{x:Reference mySwitch}\n IsVisible=\n{Binding IsToggled}\n/\n\n\n\n\n\nWhen MFractor analyses the \n{Binding IsToggled}\n expression, it will evaluate the \n{x:Reference mySwitch}\n expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).\n\n\nImplicit Binding Context Resolution\n\n\nIn addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via \nimplicit binding context resolution\n. This is done by looking for classes and Xaml views that share a common naming convention.\n\n\nLet's consider the following files:\n\n\n\n\nLoginPage.xaml\n - The xaml view.\n\n\nLoginPage.xaml.cs\n - The code behind for the xaml view.\n\n\nLoginViewModel\n - The a C# class that is the view model for the LoginPage view.\n\n\n\n\n\n\nBecause these pages share the prefix \nLogin\n and each has a distinct file extension or suffix, we can infer the following relationships:\n\n\n\n\nThe \n.xaml\n extension denotes that \nLoginPage.xaml\n is a xaml view.\n\n\nThe \n.xaml.cs\n extension and the \nLoginPage\n component denotes that \nLoginPage.xaml.cs\n is the code behind implementation \nLoginPage\n view.\n\n\nThe \nViewModel\n suffix implies that \nLoginViewModel\n is a view model. When \nViewModel\n is removed from \nLoginViewModel\n and \nPage\n is removed from \nLoginPage\n, the \nLogin\n component implies that the \nLoginViewModel\n is related to the \nLoginPage\n xaml view and it's code behind file.\n\n\n\n\nMFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that \nLoginViewModel\n will probably be the BindingContext for \nLoginPage\n. It will then\n\n\nThe following suffixes are supported for Xaml views:\n\n\n\n\nPage\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nView\n: EG LoginView.xaml \n-\n LoginViewModel\n\n\n\n\nExplicit binding context resolution will \nalways\n override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the \nBindingContext\n property then MFractor will use the \nBindingContext\n return type instead of the implicit Mvvm relationship.\n\n\nData Template Binding Context Resolution\n\n\nData templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a \nDataTemplate\n to specify the view appearance of each instance provided through the \nItemsSource\n property.\n\n\nMFractor will attempt to infer the BindingContext for a data templates view by resolving the \nItemsSource\n property on the wrapping view.\n\n\nConsider the following code:\n\n\n  \nListView ItemsSource=\n{Binding Contacts}\n\n      \nListView.ItemTemplate\n\n        \nDataTemplate\n\n          \nTextCell Text=\n{Binding DisplayName}\n /\n\n        \n/DataTemplate\n\n      \n/ListView.ItemTemplate\n\n  \n/ListView\n\n\n\n\n\nThe inner \nDataTemplate\n has a \nTextCell\n where the \nText\n property is provided by the binding expression \n{Binding DisplayName}\n. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the \nItemsSource\n property and evaluate the expression.\n\n\nWhen the return type is an \nIEnumerable\n or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.\n\n\nSummary\n\n\nIn summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.\n\n\n\n\nBinding expressions require a binding context to be analysed.\n\n\nWe can explicitly specify a binding context by assigning the \nBindingContext\n property of any Xaml element.\n\n\nWhen we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.\n\n\nData templates use the return type of the wrapping views \nItemSource\n property.", 
            "title": "Configure Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#configuring-a-binding-context", 
            "text": "Power the refactoring engine and xaml analyser by targeting a binding context", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#introduction", 
            "text": "In Mvvm architected applications, views use a  Binding Context  to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through  data binding ; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts  The Mvvm Pattern  article.  When working with Xaml, we can specify a binding context to activate binding expression analysis and a variety of BindingContext specific refactorings.  We can specify a binding context  explicitly  via in inline Xaml expression or  implicitly  through the use of common MVVM naming conventions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#explicit-binding-context-resolution", 
            "text": "In Xamarin.Forms, all views have the property  BindingContext ; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the  x:Static  markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:    Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} /   This is known as the  View Model Locator Pattern . We implement a static class named  ViewModelLocator  and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the  View Model Locator Pattern  has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent  View Model Locator  article.  For example, given a Xaml page named  LoginPage , we can explicitly provide an instance of  LoginViewModel  as the binding context like so:  ViewModelLocator.cs  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   When MFractor begins analysis on LoginPage.xaml it will check if any  BindingContext  properties have been assigned to. As the root  ContentPage  assigns a binding context, it will inspect the value component of the  BindingContext  attribute, check if it is a Xaml expression and then evaluate it for the return type.  For the  {x:Static local:ViewModelLocator.LoginViewModel}  expression, MFractor will resolve the  ViewModelLocator  class in the  local  namespace and then grab the C# type of the  LoginViewModel  property. This informs MFractor that the page will be bound to a  LoginViewModel  instance and therefore to analyse all  Binding  expressions against the  LoginViewModel  type.  Explicit binding context resolution will also work when referencing another element using  x:Reference  expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:     Switch x:Name= mySwitch  / \n   Label BindingContext= {x:Reference mySwitch}  IsVisible= {Binding IsToggled} /   When MFractor analyses the  {Binding IsToggled}  expression, it will evaluate the  {x:Reference mySwitch}  expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).", 
            "title": "Explicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#implicit-binding-context-resolution", 
            "text": "In addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via  implicit binding context resolution . This is done by looking for classes and Xaml views that share a common naming convention.  Let's consider the following files:   LoginPage.xaml  - The xaml view.  LoginPage.xaml.cs  - The code behind for the xaml view.  LoginViewModel  - The a C# class that is the view model for the LoginPage view.    Because these pages share the prefix  Login  and each has a distinct file extension or suffix, we can infer the following relationships:   The  .xaml  extension denotes that  LoginPage.xaml  is a xaml view.  The  .xaml.cs  extension and the  LoginPage  component denotes that  LoginPage.xaml.cs  is the code behind implementation  LoginPage  view.  The  ViewModel  suffix implies that  LoginViewModel  is a view model. When  ViewModel  is removed from  LoginViewModel  and  Page  is removed from  LoginPage , the  Login  component implies that the  LoginViewModel  is related to the  LoginPage  xaml view and it's code behind file.   MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that  LoginViewModel  will probably be the BindingContext for  LoginPage . It will then  The following suffixes are supported for Xaml views:   Page : EG LoginPage.xaml  -  LoginViewModel  View : EG LoginView.xaml  -  LoginViewModel   Explicit binding context resolution will  always  override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the  BindingContext  property then MFractor will use the  BindingContext  return type instead of the implicit Mvvm relationship.", 
            "title": "Implicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#data-template-binding-context-resolution", 
            "text": "Data templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a  DataTemplate  to specify the view appearance of each instance provided through the  ItemsSource  property.  MFractor will attempt to infer the BindingContext for a data templates view by resolving the  ItemsSource  property on the wrapping view.  Consider the following code:     ListView ItemsSource= {Binding Contacts} \n       ListView.ItemTemplate \n         DataTemplate \n           TextCell Text= {Binding DisplayName}  / \n         /DataTemplate \n       /ListView.ItemTemplate \n   /ListView   The inner  DataTemplate  has a  TextCell  where the  Text  property is provided by the binding expression  {Binding DisplayName} . To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the  ItemsSource  property and evaluate the expression.  When the return type is an  IEnumerable  or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.", 
            "title": "Data Template Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#summary", 
            "text": "In summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.   Binding expressions require a binding context to be analysed.  We can explicitly specify a binding context by assigning the  BindingContext  property of any Xaml element.  When we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.  Data templates use the return type of the wrapping views  ItemSource  property.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/navigation/", 
            "text": "Navigation\n\n\nMove efficiently through a Xamarin.Forms project with rich Xaml code navigation\n\n\nMvvm Navigation\n\n\nWhen MFractor can \nimplicitly resolve the View - Code Behind Class - ViewModel relationship\n, the Mvvm navigation shortcut suite is activated.\n\n\nWe can access these shortcuts by right clicking in a \n.xaml\n, \n.xaml.cs\n or \nViewModel.cs\n code file:\n\n\n\n\nGo To Code-Behind Class: Jumps you to the code behind class related to a view or view model\n\n\nGo To View Model: Jumps you to the view model related to a view or code behind class.\n\n\nGo To Xaml View: Jumps you to the xaml view related to a view model or code behind class.\n\n\n\n\nFor example:\n\n\n\n\nXaml Go-To Symbol\n\n\nJust like C#, we can jump to the declaration of a symbol when in our Xaml.\n\n\nTo perform this, click onto a Xaml element (such as a node, attribute or expression) and press \nCommand + D\n.\n\n\nWe can also right click on any Xaml element and select the \nGo-To Xaml Symbol\n shortcut:\n\n\n\n\nXaml Tooltips\n\n\nWhen in a .xaml file, we can hover over any Xaml element to view a .NET style tooltip:\n\n\n\n\nWe can also hover over markup extension expressions to view the evaluation result:\n\n\n\n\nMFractor also supports the following additional types of tooltips.\n\n\nBinding Context Tooltips\n\n\nIf you hover over a \nBinding\n markup extension expression that can be evaluated, MFractor will render the full .NET type of the binding context into the tooltip:\n\n\n\n\nThis is useful for understanding the behaviour of your View at runtime.\n\n\nValue Conversion Tooltips\n\n\nWhen you have annotated implementations of \nIValueConverter\n with the value conversion attribute, MFractor supports rendering of input, output and parameter type into the tooltip window.\n\n\nWhen you hover over a Xaml element or markup extension expression that evaluates to a \nIValueConverter\n, MFractor will render out the input and output types when available:\n\n\n\n\nColor Tooltips\n\n\nWhen MFractor encounters a Xaml attribute that uses the \nXamarin.Forms.Color\n or \nSystem.Drawing.Color\n type, it will attempt to evaluate the color hex or color literal.\n\n\nIf successfully evaluated, it will render the color value into the resulting tooltip:\n\n\n\n\nImage Tooltips\n\n\nMFractor supports inline image tooltips; these tooltips will display a preview of the image that you are referencing from within your Xaml:\n\n\nImage tooltips are activated when you hover over the value of a Xaml attribute whose type is \nXamarin.Forms.ImageSource\n; when MFractor encounters a value that looks like an image reference to a bundled resource (IE: \nlogo.png\n), it attempts to locate that image within any iOS or Android projects that reference the assembly.\n\n\nMFractor searches the \nResources\n folder within linked iOS projects and the \nResources/drawable*\n and \nResources/mipmap*\n folders on Android.\n\n\nWhen MFractor finds an image that matches that image name, it will render it into the image into the tooltip window:", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#navigation", 
            "text": "Move efficiently through a Xamarin.Forms project with rich Xaml code navigation", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#mvvm-navigation", 
            "text": "When MFractor can  implicitly resolve the View - Code Behind Class - ViewModel relationship , the Mvvm navigation shortcut suite is activated.  We can access these shortcuts by right clicking in a  .xaml ,  .xaml.cs  or  ViewModel.cs  code file:   Go To Code-Behind Class: Jumps you to the code behind class related to a view or view model  Go To View Model: Jumps you to the view model related to a view or code behind class.  Go To Xaml View: Jumps you to the xaml view related to a view model or code behind class.   For example:", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-go-to-symbol", 
            "text": "Just like C#, we can jump to the declaration of a symbol when in our Xaml.  To perform this, click onto a Xaml element (such as a node, attribute or expression) and press  Command + D .  We can also right click on any Xaml element and select the  Go-To Xaml Symbol  shortcut:", 
            "title": "Xaml Go-To Symbol"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-tooltips", 
            "text": "When in a .xaml file, we can hover over any Xaml element to view a .NET style tooltip:   We can also hover over markup extension expressions to view the evaluation result:   MFractor also supports the following additional types of tooltips.", 
            "title": "Xaml Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#binding-context-tooltips", 
            "text": "If you hover over a  Binding  markup extension expression that can be evaluated, MFractor will render the full .NET type of the binding context into the tooltip:   This is useful for understanding the behaviour of your View at runtime.", 
            "title": "Binding Context Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#value-conversion-tooltips", 
            "text": "When you have annotated implementations of  IValueConverter  with the value conversion attribute, MFractor supports rendering of input, output and parameter type into the tooltip window.  When you hover over a Xaml element or markup extension expression that evaluates to a  IValueConverter , MFractor will render out the input and output types when available:", 
            "title": "Value Conversion Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#color-tooltips", 
            "text": "When MFractor encounters a Xaml attribute that uses the  Xamarin.Forms.Color  or  System.Drawing.Color  type, it will attempt to evaluate the color hex or color literal.  If successfully evaluated, it will render the color value into the resulting tooltip:", 
            "title": "Color Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#image-tooltips", 
            "text": "MFractor supports inline image tooltips; these tooltips will display a preview of the image that you are referencing from within your Xaml:  Image tooltips are activated when you hover over the value of a Xaml attribute whose type is  Xamarin.Forms.ImageSource ; when MFractor encounters a value that looks like an image reference to a bundled resource (IE:  logo.png ), it attempts to locate that image within any iOS or Android projects that reference the assembly.  MFractor searches the  Resources  folder within linked iOS projects and the  Resources/drawable*  and  Resources/mipmap*  folders on Android.  When MFractor finds an image that matches that image name, it will render it into the image into the tooltip window:", 
            "title": "Image Tooltips"
        }, 
        {
            "location": "/xamarin-forms/analysis/", 
            "text": "WORK IN PROGRESS\n\n\nXaml Analysis\n\n\nUse the Xaml analyser to spend less time debugging and see Xaml errors in-editor\n\n\nIntroduction\n\n\nIt's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues \nimmediately\n and then marking them inside the xaml editor with a concise error message.\n\n\nBye bye Xaml bugs! \ud83d\udc4b\n\n\nUnder The Hood\n\n\nLet's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:\n\n\n\n\nWhen you open a Xaml file that's part of a .NET project, Xamarin Studio notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.\n\n\nOnce MFractor has a copy of the Xaml DOM, it \nsymbolicates\n the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.\n\n\nIt may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:\n\n\n\n\nWhen the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either\n\n\nA full list of available Xaml analysers can be found at \nXamarin.Forms Analysers\n.\n\n\nWhenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.\n\n\nCode Fixes\n\n\nWhen MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:\n\n\nYou can action this fix by right clicking on the text area marked by the yellow squiggle\n\n\nSee \nCode Actions\n for further documentation on using Xaml to C# code generation.\n\n\nExpression Analysis\n\n\nBinding Expression Analysis", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#xaml-analysis", 
            "text": "Use the Xaml analyser to spend less time debugging and see Xaml errors in-editor", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#introduction", 
            "text": "It's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues  immediately  and then marking them inside the xaml editor with a concise error message.  Bye bye Xaml bugs! \ud83d\udc4b", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/analysis/#under-the-hood", 
            "text": "Let's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:   When you open a Xaml file that's part of a .NET project, Xamarin Studio notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.  Once MFractor has a copy of the Xaml DOM, it  symbolicates  the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.  It may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:   When the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either  A full list of available Xaml analysers can be found at  Xamarin.Forms Analysers .  Whenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.", 
            "title": "Under The Hood"
        }, 
        {
            "location": "/xamarin-forms/analysis/#code-fixes", 
            "text": "When MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:  You can action this fix by right clicking on the text area marked by the yellow squiggle  See  Code Actions  for further documentation on using Xaml to C# code generation.", 
            "title": "Code Fixes"
        }, 
        {
            "location": "/xamarin-forms/analysis/#expression-analysis", 
            "text": "", 
            "title": "Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#binding-expression-analysis", 
            "text": "", 
            "title": "Binding Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/code-actions/", 
            "text": "Code Actions\n\n\nFix issues, refactor, tidy up code and generate C# from your Xaml\n\n\nIntroduction\n\n\nCode actions are shortcuts that manipulate your Xaml or C# code (or both!); they enable you to fix issues, refactor xaml, generate C# code from your views and organise xaml code.\n\n\nThis article describes how to access and use code actions\n\n\nFor a full list of available xaml code actions, see the following articles:\n\n\n\n\nRefactoring Code Actions\n article.\n\n\nGeneration Code Actions\n article.\n\n\nOrganise Code Actions\n article.\n\n\nCode Issue Fixes\n article.\n\n\n\n\nUsing Code Actions\n\n\nMFractor has 4 types of code actions:\n\n\n\n\nFixes\n: Fixes code issues detected by the Xaml analyser.\n\n\nGenerate\n: Generates common xaml and C# code.\n\n\nRefactor\n: Rename C# and Xaml symbols from your Xaml document.\n\n\nOrganise\n: Tidy up and organise your xaml.\n\n\n\n\nMFractor exposes code actions through 2 methods:\n\n\n\n\nPressing the keyboard shortcut \nAlt\n+\nReturn\n:\n\n\n\n\n\n\n\n\nRight clicking within the document and selecting a menu action:\n\n\n\n\n\n\nCode Issue Fixes\n\n\nCode issue fixes are available when an analyser from the \nXaml Analysis Engine\n detects a code issue and it marks that code section with a yellow underline.\n\n\nYou can action a code fix by right-clicking on the yellow-underlined code section, opening the \nFix\n menu and then selecting the fix you'd like to action:\n\n\n\n\nTo view a complete list of available code issue fixes, visit the \nCode Issue Fix\n document.\n\n\nCode Generation\n\n\nCode generation operations allow you to quickly build boilerplate code that you'd otherwise have to hand code yourself.\n\n\nFor example, you could:\n\n\n\n\nGenerate resource dictionaries for view elements.\n\n\nImplement all missing bindings in bulk using the \nImplement View Model\n code generator.\n\n\n\n\n\n\nTo view a complete list of available code generation refactorings, visit \nRefactorings - Generate\n.\n\n\nCode Refactoring\n\n\nThe refactorings within the \nRefactor\n allow you to manipulate Xaml and .NET symbols while within your Xaml document. These refactorings typically take user input and perform a change on the Xaml and/or C# based on that input.\n\n\nFor example, you could:\n\n\n\n\nTake the attribute \nText=\"Hello Xamarin Forms!\"\n and extract the value \n\"Hello Xamarin Forms!\"\n into the views binding context; replacing the attribute with \nText=\"{Binding Message}\"\n and creating the C# property \npublic string Message { get; set; } = \"Hello Xamarin Forms!\"\n.\n\n\nEdit a color literal using the color picker dialog.\n\n\n\n\n\n\nTo view a complete list of available refactoring operations, visit \nRefactorings - Refactor\n.\n\n\nCode Organisation\n\n\nThe refactorings within the \nOrganise\n are used to quickly format your xaml code. These refactorings are useful to keep your xaml tidy and easy to understand.\n\n\nFor example, you could:\n\n\n\n\nSort all attributes on a node by name and namespace.\n\n\nCollapse or expand the attribute on a node onto separate or the same lines.\n\n\nExpand or collapse the closing tag on a node.\n\n\n\n\n\n\nTo view a complete list of available code organisation operations, visit \nRefactorings - Organise\n.", 
            "title": "Using Code Actions"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#code-actions", 
            "text": "Fix issues, refactor, tidy up code and generate C# from your Xaml", 
            "title": "Code Actions"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#introduction", 
            "text": "Code actions are shortcuts that manipulate your Xaml or C# code (or both!); they enable you to fix issues, refactor xaml, generate C# code from your views and organise xaml code.  This article describes how to access and use code actions  For a full list of available xaml code actions, see the following articles:   Refactoring Code Actions  article.  Generation Code Actions  article.  Organise Code Actions  article.  Code Issue Fixes  article.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#using-code-actions", 
            "text": "MFractor has 4 types of code actions:   Fixes : Fixes code issues detected by the Xaml analyser.  Generate : Generates common xaml and C# code.  Refactor : Rename C# and Xaml symbols from your Xaml document.  Organise : Tidy up and organise your xaml.   MFractor exposes code actions through 2 methods:   Pressing the keyboard shortcut  Alt + Return :     Right clicking within the document and selecting a menu action:", 
            "title": "Using Code Actions"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#code-issue-fixes", 
            "text": "Code issue fixes are available when an analyser from the  Xaml Analysis Engine  detects a code issue and it marks that code section with a yellow underline.  You can action a code fix by right-clicking on the yellow-underlined code section, opening the  Fix  menu and then selecting the fix you'd like to action:   To view a complete list of available code issue fixes, visit the  Code Issue Fix  document.", 
            "title": "Code Issue Fixes"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#code-generation", 
            "text": "Code generation operations allow you to quickly build boilerplate code that you'd otherwise have to hand code yourself.  For example, you could:   Generate resource dictionaries for view elements.  Implement all missing bindings in bulk using the  Implement View Model  code generator.    To view a complete list of available code generation refactorings, visit  Refactorings - Generate .", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#code-refactoring", 
            "text": "The refactorings within the  Refactor  allow you to manipulate Xaml and .NET symbols while within your Xaml document. These refactorings typically take user input and perform a change on the Xaml and/or C# based on that input.  For example, you could:   Take the attribute  Text=\"Hello Xamarin Forms!\"  and extract the value  \"Hello Xamarin Forms!\"  into the views binding context; replacing the attribute with  Text=\"{Binding Message}\"  and creating the C# property  public string Message { get; set; } = \"Hello Xamarin Forms!\" .  Edit a color literal using the color picker dialog.    To view a complete list of available refactoring operations, visit  Refactorings - Refactor .", 
            "title": "Code Refactoring"
        }, 
        {
            "location": "/xamarin-forms/code-actions/#code-organisation", 
            "text": "The refactorings within the  Organise  are used to quickly format your xaml code. These refactorings are useful to keep your xaml tidy and easy to understand.  For example, you could:   Sort all attributes on a node by name and namespace.  Collapse or expand the attribute on a node onto separate or the same lines.  Expand or collapse the closing tag on a node.    To view a complete list of available code organisation operations, visit  Refactorings - Organise .", 
            "title": "Code Organisation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/", 
            "text": "Xamarin.Forms Xaml Analysis\n\n\nA complete list of all Xaml analysers in MFractor for Xamarin.Forms - 46 analysers\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\n\nBinding Expression Return Type Mismatch\n\n\nValidates that the .NET symbol returned by a binding expression matches the expected type for the property.\n\n\nBinding Expressions Resolve\n\n\nInspects \nBinding\n expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.\n\n\nClass Does Not Have Attached Property\n\n\nLooks for attached properties (for example \nGrid.Row\n) and validates they exist in the class that they are attempting to use.\n\n\nCode Behind Class Type Mismatch\n\n\nInspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.\n\n\nDuplicate AutomationIds\n\n\nInspects a Xaml document for occurances of duplicate \nAutomationId\n declarations.\n\n\nDuplicate Code Behind Field Declarations\n\n\nChecks that the value assigned to an \nx:Name\n attribute is unique within the scope of the document.\n\n\nDuplicate Namespace Declaration\n\n\nChecks that an xml namespace points to a unique namespace and assembly. For example if both \nxmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"\n and \nxmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"\n were declared, this analyser would warn that they both reference the same assembly and namespace.\n\n\nDuplicate Resource Dictionary Keys\n\n\nValidates the each resource entry within a resource dictionary has a unique key.\n\n\nEmpty Code Behind Field Declaration\n\n\nInspects occurances of the \nx:Name\n attribute and validates that a value is assigned; empty \nx:Name\n expressions generate an empty named code-behind field, causing compilation errors.\n\n\nEvent Handler Exists In Code Behind Class\n\n\nChecks that an event callback referenced referenced by an attribute value exists in the code behind class.\n\n\nEvent Handler Signature Mismatch\n\n\nChecks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.\n\n\nGeneric Usage Is Missing x:TypeArguments\n\n\nInspects generic classes that are instantiated through Xaml and validates that an \nx:TypeArguments\n attribute or property assignment node is present.\n\n\nIValueConverter Input Type Mismatch\n\n\nInspects the \nConverter\n property of a \nBinding\nexpression and validates that the input type is correct. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nIValueConverter Output Type Mismatch\n\n\nInspects the \nConverter\n component of a \nBinding\n expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nMalformed Xmlns Declaration\n\n\nVerifies that a 'xmlns' attribute has both a clr-namespace and an assembly component.\n\n\nMissing Microsoft Schema\n\n\nInspects at the root xaml node and verifies that it references the Microsoft Xaml schema: \nhttp://schemas.microsoft.com/winfx/2009/xaml\n. This schema is required for Xamarin Forms Xaml documents.\n\n\nObsolete Property Used\n\n\nChecks for attributes that are marked as obsolete/deprecated.\n\n\nOnIdiom Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnIdiom\n element is valid with the parent property type.\n\n\nOnPlatform Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnPlatform\n element is valid with the parent property type.\n\n\nProperty Node Maps To Member In Parent Type\n\n\nChecks that a property node resolves to a member within its parent type.\n\n\nProperty Setter Attribute Has Value\n\n\nChecks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.\n\n\nProperty Setter Node Has Value\n\n\nChecks that a value has been provided to a node Property setter (EG \nMyClass.MyProperty\n/MyClass.MyProperty\n).\n\n\nProperty Setter Node Misuse\n\n\nInspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.\n\n\nProperty Setter Type Mismatch\n\n\nWhen using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.\n\n\nRedundant Code Behind Field On Root Node\n\n\nInspects the root Xaml node for a redundant code behind declaration (\nx:Name=\"fieldName\"\n); a code behind field should not be declared on the root element as the code behind class can already be accessed using \nthis\n\n\nReferenced Attribute Member Exists In Parent Type\n\n\nChecks that an attribute resolves to a member within its parent type.\n\n\nReferenced Code Behind Field Exists\n\n\nInspects usages of the \nx:Reference\n expression and validates the referenced element has been declared within the document. \nx:Reference\n expressions are used to resolve another Xaml node has a code behind field defined using the \nx:Name\n attribute.\n\n\nResource Entry Does Not Define Key\n\n\nValidates the elements provided to a resource dictionary supply an \nx:Key\n attribute to declare their resource dictionary key.\n\n\nRoot Element Defines Code Behind Class\n\n\nChecks that the root xaml node defines a code behind class using the \nx:Class\n directive\n\n\nStaticResource Return Type Mismatch\n\n\nValidates that the symbol returned by a \nStaticResource\n expression matches the expected type for the property.\n\n\nUndefined Static Resource Usage\n\n\nValidates that the element referenced by a \nStaticResource\n expression resource lookup resolves to a resource defined in the xaml file.\n\n\nUnknown Static Property Value\n\n\nFor attributes that accept a class object, hecks that the literal value maps to a static property or field in the class type. For example, the \nLayoutOptions\n class has the static fields \nFill\n or \nCentreAndExpand\n that can be used a literal attribute values. If \nCentreAndFill\n was provided, this analyser would inspect \nLayoutOptions\n for a static field named \nCentreAndFill\n and trigger an analysis error when it couldn't be found.\n\n\nUnknown Type Provided To Generic\n\n\nInspects usages of \nx:TypeArguments\n and validates that the type provided exists.\n\n\nUnresolved .NET Symbols Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.\n\n\nUnresolved Namespace Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.\n\n\nUnresolved Xml Namespace\n\n\nChecks that the namespace used on the xml nodes is defined within the current document.\n\n\nUnresolved Xmlns Assembly\n\n\nChecks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.\n\n\nUnused Resource\n\n\nInspects that resource dictionary entries are used via the \nStaticResource\n markup extension expression within this document.\n\n\nUnused Xml Namespace\n\n\nValidate that xmlns attributes that declare a namespace and assembly that is used within the current document.\n\n\nValidate Binding Expressions Return A Property\n\n\nEvaluates a \nBinding\n expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.\n\n\nValidate Value Types\n\n\nInspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.\n\n\nx:Name Has Invalid Characters\n\n\nChecks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.\n\n\nx:Static Return Type Mismatch\n\n\nValidates that the .NET symbol returned by an \nx:Static\n expressions matches the expected type for the property.\n\n\nx:TypeArguments Used On Non-Generic Class\n\n\nInspects for usages of \nx:TypeArguments\n on elements that are non-generic classes.\n\n\nXaml Node Cannot Be Instantiated\n\n\nChecks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.\n\n\nXaml Node Resolves\n\n\nChecks that xaml nodes map to a valid .NET symbol.", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xamarinforms-xaml-analysis", 
            "text": "A complete list of all Xaml analysers in MFractor for Xamarin.Forms - 46 analysers  (Autogenerated by MFractor v2.10.0.0)", 
            "title": "Xamarin.Forms Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#binding-expression-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by a binding expression matches the expected type for the property.", 
            "title": "Binding Expression Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#binding-expressions-resolve", 
            "text": "Inspects  Binding  expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.", 
            "title": "Binding Expressions Resolve"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#class-does-not-have-attached-property", 
            "text": "Looks for attached properties (for example  Grid.Row ) and validates they exist in the class that they are attempting to use.", 
            "title": "Class Does Not Have Attached Property"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#code-behind-class-type-mismatch", 
            "text": "Inspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.", 
            "title": "Code Behind Class Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#duplicate-automationids", 
            "text": "Inspects a Xaml document for occurances of duplicate  AutomationId  declarations.", 
            "title": "Duplicate AutomationIds"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#duplicate-code-behind-field-declarations", 
            "text": "Checks that the value assigned to an  x:Name  attribute is unique within the scope of the document.", 
            "title": "Duplicate Code Behind Field Declarations"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#duplicate-namespace-declaration", 
            "text": "Checks that an xml namespace points to a unique namespace and assembly. For example if both  xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"  and  xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"  were declared, this analyser would warn that they both reference the same assembly and namespace.", 
            "title": "Duplicate Namespace Declaration"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#duplicate-resource-dictionary-keys", 
            "text": "Validates the each resource entry within a resource dictionary has a unique key.", 
            "title": "Duplicate Resource Dictionary Keys"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#empty-code-behind-field-declaration", 
            "text": "Inspects occurances of the  x:Name  attribute and validates that a value is assigned; empty  x:Name  expressions generate an empty named code-behind field, causing compilation errors.", 
            "title": "Empty Code Behind Field Declaration"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#event-handler-exists-in-code-behind-class", 
            "text": "Checks that an event callback referenced referenced by an attribute value exists in the code behind class.", 
            "title": "Event Handler Exists In Code Behind Class"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#event-handler-signature-mismatch", 
            "text": "Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.", 
            "title": "Event Handler Signature Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#generic-usage-is-missing-xtypearguments", 
            "text": "Inspects generic classes that are instantiated through Xaml and validates that an  x:TypeArguments  attribute or property assignment node is present.", 
            "title": "Generic Usage Is Missing x:TypeArguments"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#ivalueconverter-input-type-mismatch", 
            "text": "Inspects the  Converter  property of a  Binding expression and validates that the input type is correct. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "IValueConverter Input Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#ivalueconverter-output-type-mismatch", 
            "text": "Inspects the  Converter  component of a  Binding  expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "IValueConverter Output Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#malformed-xmlns-declaration", 
            "text": "Verifies that a 'xmlns' attribute has both a clr-namespace and an assembly component.", 
            "title": "Malformed Xmlns Declaration"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#missing-microsoft-schema", 
            "text": "Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema:  http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents.", 
            "title": "Missing Microsoft Schema"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#obsolete-property-used", 
            "text": "Checks for attributes that are marked as obsolete/deprecated.", 
            "title": "Obsolete Property Used"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#onidiom-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnIdiom  element is valid with the parent property type.", 
            "title": "OnIdiom Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#onplatform-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnPlatform  element is valid with the parent property type.", 
            "title": "OnPlatform Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#property-node-maps-to-member-in-parent-type", 
            "text": "Checks that a property node resolves to a member within its parent type.", 
            "title": "Property Node Maps To Member In Parent Type"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#property-setter-attribute-has-value", 
            "text": "Checks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.", 
            "title": "Property Setter Attribute Has Value"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#property-setter-node-has-value", 
            "text": "Checks that a value has been provided to a node Property setter (EG  MyClass.MyProperty /MyClass.MyProperty ).", 
            "title": "Property Setter Node Has Value"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#property-setter-node-misuse", 
            "text": "Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.", 
            "title": "Property Setter Node Misuse"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#property-setter-type-mismatch", 
            "text": "When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.", 
            "title": "Property Setter Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#redundant-code-behind-field-on-root-node", 
            "text": "Inspects the root Xaml node for a redundant code behind declaration ( x:Name=\"fieldName\" ); a code behind field should not be declared on the root element as the code behind class can already be accessed using  this", 
            "title": "Redundant Code Behind Field On Root Node"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#referenced-attribute-member-exists-in-parent-type", 
            "text": "Checks that an attribute resolves to a member within its parent type.", 
            "title": "Referenced Attribute Member Exists In Parent Type"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#referenced-code-behind-field-exists", 
            "text": "Inspects usages of the  x:Reference  expression and validates the referenced element has been declared within the document.  x:Reference  expressions are used to resolve another Xaml node has a code behind field defined using the  x:Name  attribute.", 
            "title": "Referenced Code Behind Field Exists"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#resource-entry-does-not-define-key", 
            "text": "Validates the elements provided to a resource dictionary supply an  x:Key  attribute to declare their resource dictionary key.", 
            "title": "Resource Entry Does Not Define Key"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#root-element-defines-code-behind-class", 
            "text": "Checks that the root xaml node defines a code behind class using the  x:Class  directive", 
            "title": "Root Element Defines Code Behind Class"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#staticresource-return-type-mismatch", 
            "text": "Validates that the symbol returned by a  StaticResource  expression matches the expected type for the property.", 
            "title": "StaticResource Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#undefined-static-resource-usage", 
            "text": "Validates that the element referenced by a  StaticResource  expression resource lookup resolves to a resource defined in the xaml file.", 
            "title": "Undefined Static Resource Usage"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unknown-static-property-value", 
            "text": "For attributes that accept a class object, hecks that the literal value maps to a static property or field in the class type. For example, the  LayoutOptions  class has the static fields  Fill  or  CentreAndExpand  that can be used a literal attribute values. If  CentreAndFill  was provided, this analyser would inspect  LayoutOptions  for a static field named  CentreAndFill  and trigger an analysis error when it couldn't be found.", 
            "title": "Unknown Static Property Value"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unknown-type-provided-to-generic", 
            "text": "Inspects usages of  x:TypeArguments  and validates that the type provided exists.", 
            "title": "Unknown Type Provided To Generic"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unresolved-net-symbols-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.", 
            "title": "Unresolved .NET Symbols Within Xaml Expression"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unresolved-namespace-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.", 
            "title": "Unresolved Namespace Within Xaml Expression"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unresolved-xml-namespace", 
            "text": "Checks that the namespace used on the xml nodes is defined within the current document.", 
            "title": "Unresolved Xml Namespace"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unresolved-xmlns-assembly", 
            "text": "Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.", 
            "title": "Unresolved Xmlns Assembly"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unused-resource", 
            "text": "Inspects that resource dictionary entries are used via the  StaticResource  markup extension expression within this document.", 
            "title": "Unused Resource"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#unused-xml-namespace", 
            "text": "Validate that xmlns attributes that declare a namespace and assembly that is used within the current document.", 
            "title": "Unused Xml Namespace"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#validate-binding-expressions-return-a-property", 
            "text": "Evaluates a  Binding  expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.", 
            "title": "Validate Binding Expressions Return A Property"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#validate-value-types", 
            "text": "Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.", 
            "title": "Validate Value Types"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xname-has-invalid-characters", 
            "text": "Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.", 
            "title": "x:Name Has Invalid Characters"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xstatic-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by an  x:Static  expressions matches the expected type for the property.", 
            "title": "x:Static Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xtypearguments-used-on-non-generic-class", 
            "text": "Inspects for usages of  x:TypeArguments  on elements that are non-generic classes.", 
            "title": "x:TypeArguments Used On Non-Generic Class"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xaml-node-cannot-be-instantiated", 
            "text": "Checks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.", 
            "title": "Xaml Node Cannot Be Instantiated"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/#xaml-node-resolves", 
            "text": "Checks that xaml nodes map to a valid .NET symbol.", 
            "title": "Xaml Node Resolves"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactor/", 
            "text": "Refactoring\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available refactorings in MFractor for Xamarin.Forms\n\n\n3 Code Actions\n\n\nEdit Inline Color\n\n\nThis action let's you select any attribute that expects a \nXamarin.Forms.Color\n and let's you edit it using a color editor dialog.\n\n\nExtract Attribute Value Into Property Binding\n\n\nWhen a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.\n\n\nFor example, given the attribute initialiser \nText=\"Hello Xamarin.Forms!\"\n, this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal \n\"Message\"\n and replace the attribute value with the binding expresion \n{Binding Message}\n.\n\n\nRename Xaml Namespace\n\n\nRenames the xaml namespace under the cursor", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactor/#refactoring", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available refactorings in MFractor for Xamarin.Forms  3 Code Actions", 
            "title": "Refactoring"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactor/#edit-inline-color", 
            "text": "This action let's you select any attribute that expects a  Xamarin.Forms.Color  and let's you edit it using a color editor dialog.", 
            "title": "Edit Inline Color"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactor/#extract-attribute-value-into-property-binding", 
            "text": "When a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.  For example, given the attribute initialiser  Text=\"Hello Xamarin.Forms!\" , this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal  \"Message\"  and replace the attribute value with the binding expresion  {Binding Message} .", 
            "title": "Extract Attribute Value Into Property Binding"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactor/#rename-xaml-namespace", 
            "text": "Renames the xaml namespace under the cursor", 
            "title": "Rename Xaml Namespace"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/", 
            "text": "Code Generation\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code generation actions in MFractor for Xamarin.Forms\n\n\n5 Code Actions\n\n\nGenerate Grid ColumnDefinitions\n\n\nThis code generation refactoring adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single \nColumnDefinition Width=\"*\"/\n element; this allows you to quickly setup a boilerplate grid.\n\n\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\n\n\nGrid\n\n\n    \nGrid.ColumnDefinitions\n\n\n    \nColumnDefinition Width=\n*\n\n\n    \n/Grid.ColumnDefinitions\n\n\n\n/Grid\n\n\n\n\n\n\nGenerate Grid RowDefinitions\n\n\nThis code generation refactoring adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single \nRowDefinition Height=\"*\"/\n element; this allows you to quickly setup a boilerplate grid.\n\n\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\n\n\nGrid\n\n\n    \nGrid.RowDefinitions\n\n\n    \nRowDefinition Height=\n*\n\n\n    \n/Grid.RowDefinitions\n\n\n\n/Grid\n\n\n\n\n\n\nGenerate Resource Dictionary\n\n\nThe \nGenerate Resource Dictionary\n refactoring adds a \nMyView.ResourceDictionary\n property with a nested resource dictionary to any Xaml node that derives from \nXamarin.Forms.VisualElement\n or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.\n\n\nImplement Missing Members\n\n\nWhen a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.\n\n\nThe following \nmust\n be satisfied for this refactoring to trigger:\n\n\n\n\nOne or more undefined members/properties must be in use.\n\n\nThe referenced class must exist.\n\n\nThe referenced class must be writeable; aka it must be in the users source code.\n\n\nWhen the referenced class derives from \nXamarin.Forms.BindableObject\n, this refactoring will allow the generation of bindable properties.\n\n\n\n\nLet's examine the following code:\n\n\nMyCustomSlider.cs\n\n\n\npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}\n\n\n\n\n\nMyXamlView.xaml\n\n\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:local=\nclr-namespace:HelloMFractor\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloMFractor.HelloMFractorPage\n\n    \nlocal:MyCustomSlider \n        MinRangeColor=\n{Binding MinColor}\n\n        MaxRangeColor=\n{Binding MaxColor}\n/\n\n\n/ContentPage\n\n\n\n\n\n\n\nWhen \nImplement Missing Members\n is actioned MFractor can generate the members/properties as plain old properties (EG: \nget; set;\n) or as a bindable property implementation.\n\n\nFor example, when actioned to generate bindable properties, \nMyCustomSlider\n would become:\n\n\n\npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}\n\n\n\n\n\nImplement View Model\n\n\nWhen a Xamarin.Forms xaml document has unimplemented bindings, this refactoring allows a developer to implement them all in a few clicks.\nThe 'Implement View Model' refactoring will gather all unimplemented binding expressions, generate the properties (optionally with backing fields), generate the commands and then insert the code into the binding context for the view.\n\n\nIf there is no associated binding context for the Xaml view, this refactoring will also generate the class. The naming convention will be [XamlFileName]ViewMode minus the Page or View comoponent; for example, LoginPage would create a class named LoginViewModel and PasswordDialogView would create a class named PasswordDialogViewModel.", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#code-generation", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code generation actions in MFractor for Xamarin.Forms  5 Code Actions", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#generate-grid-columndefinitions", 
            "text": "This code generation refactoring adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single  ColumnDefinition Width=\"*\"/  element; this allows you to quickly setup a boilerplate grid.  When this refactoring is used, the  Grid  node will have the following code injected:   Grid \n\n     Grid.ColumnDefinitions \n\n     ColumnDefinition Width= * \n\n     /Grid.ColumnDefinitions  /Grid", 
            "title": "Generate Grid ColumnDefinitions"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#generate-grid-rowdefinitions", 
            "text": "This code generation refactoring adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single  RowDefinition Height=\"*\"/  element; this allows you to quickly setup a boilerplate grid.  When this refactoring is used, the  Grid  node will have the following code injected:   Grid \n\n     Grid.RowDefinitions \n\n     RowDefinition Height= * \n\n     /Grid.RowDefinitions  /Grid", 
            "title": "Generate Grid RowDefinitions"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#generate-resource-dictionary", 
            "text": "The  Generate Resource Dictionary  refactoring adds a  MyView.ResourceDictionary  property with a nested resource dictionary to any Xaml node that derives from  Xamarin.Forms.VisualElement  or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.", 
            "title": "Generate Resource Dictionary"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#implement-missing-members", 
            "text": "When a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.  The following  must  be satisfied for this refactoring to trigger:   One or more undefined members/properties must be in use.  The referenced class must exist.  The referenced class must be writeable; aka it must be in the users source code.  When the referenced class derives from  Xamarin.Forms.BindableObject , this refactoring will allow the generation of bindable properties.   Let's examine the following code:  MyCustomSlider.cs  \npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}  MyXamlView.xaml   ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:local= clr-namespace:HelloMFractor \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloMFractor.HelloMFractorPage \n     local:MyCustomSlider \n        MinRangeColor= {Binding MinColor} \n        MaxRangeColor= {Binding MaxColor} /  /ContentPage   When  Implement Missing Members  is actioned MFractor can generate the members/properties as plain old properties (EG:  get; set; ) or as a bindable property implementation.  For example, when actioned to generate bindable properties,  MyCustomSlider  would become:  \npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}", 
            "title": "Implement Missing Members"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/generate/#implement-view-model", 
            "text": "When a Xamarin.Forms xaml document has unimplemented bindings, this refactoring allows a developer to implement them all in a few clicks.\nThe 'Implement View Model' refactoring will gather all unimplemented binding expressions, generate the properties (optionally with backing fields), generate the commands and then insert the code into the binding context for the view.  If there is no associated binding context for the Xaml view, this refactoring will also generate the class. The naming convention will be [XamlFileName]ViewMode minus the Page or View comoponent; for example, LoginPage would create a class named LoginViewModel and PasswordDialogView would create a class named PasswordDialogViewModel.", 
            "title": "Implement View Model"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/", 
            "text": "Code Organisation\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code organisation actions in MFractor for Xamarin.Forms\n\n\n7 Code Actions\n\n\nCollapse Attributes Onto Same Line\n\n\nThis refactoring will collapse all the attributes for a Xaml node onto the same line as the nodes name declaration.\n\n\nCollapse Node\n\n\nWhen a Xaml node has a closing tag and no children (eg: \nMyNode\n \n/MyNode\n), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node \nMyNode\n ... \n/MyNode\n, the closing tag \n/MyNode\n is removed and the element becomes self closing like so: \nMyNode/\n.\n\n\nExpand Attributes Onto Separate Lines\n\n\nThis refactoring will expand all the attributes for a Xaml node onto a separate line for each attribute.\n\n\nFor example, gi\n\n\nExpand Node\n\n\nWhen a Xaml node is self-closing (EG \nMyNode/\n), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node \nMyNode/\n would become \nMyNode\n ... \n/MyNode\n after applying this refactoring.\n\n\nFormat Xaml Document\n\n\nApplies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.\n\n\nSimplify Static Member Assignment\n\n\nAttributes that accept a class instance can be assigned long hand by using the type and instance name that will be used for the assignement.For example, when assigning VerticalOptions it's perfectly reasonable to use the long hand form of 'LayoutOptions.CentreAndExpand'.This refactoring action strips out the leading type specifier and reduces the assignment to just 'CentreAndExpand'\n\n\nSort Xaml Attributes\n\n\nThis refactoring sorts the attributes for a Xaml node and regenerates the xaml node based on the IDE's xml formatting policy.\nMFractor uses the following rules when sorting:\n\n\n\n\nAttributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example \nxmlns:forms=\"http://xamarin.com/schemas/2014/forms\"\n will appear before \nxmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n.\n\n\nAttributes that belong to the Microsoft Xaml schema \nhttp://schemas.microsoft.com/winfx/2009/xaml\n are ordered next. For example, the \nx:Class\n or \nx:Name\n declaration.\n\n\nAttributes belonging to the default namespace are ordered next, sorted alphabetically ascending.\n\n\nAttributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.", 
            "title": "Xaml Organisation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#code-organisation", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code organisation actions in MFractor for Xamarin.Forms  7 Code Actions", 
            "title": "Code Organisation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#collapse-attributes-onto-same-line", 
            "text": "This refactoring will collapse all the attributes for a Xaml node onto the same line as the nodes name declaration.", 
            "title": "Collapse Attributes Onto Same Line"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#collapse-node", 
            "text": "When a Xaml node has a closing tag and no children (eg:  MyNode   /MyNode ), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node  MyNode  ...  /MyNode , the closing tag  /MyNode  is removed and the element becomes self closing like so:  MyNode/ .", 
            "title": "Collapse Node"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#expand-attributes-onto-separate-lines", 
            "text": "This refactoring will expand all the attributes for a Xaml node onto a separate line for each attribute.  For example, gi", 
            "title": "Expand Attributes Onto Separate Lines"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#expand-node", 
            "text": "When a Xaml node is self-closing (EG  MyNode/ ), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node  MyNode/  would become  MyNode  ...  /MyNode  after applying this refactoring.", 
            "title": "Expand Node"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#format-xaml-document", 
            "text": "Applies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.", 
            "title": "Format Xaml Document"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#simplify-static-member-assignment", 
            "text": "Attributes that accept a class instance can be assigned long hand by using the type and instance name that will be used for the assignement.For example, when assigning VerticalOptions it's perfectly reasonable to use the long hand form of 'LayoutOptions.CentreAndExpand'.This refactoring action strips out the leading type specifier and reduces the assignment to just 'CentreAndExpand'", 
            "title": "Simplify Static Member Assignment"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/organise/#sort-xaml-attributes", 
            "text": "This refactoring sorts the attributes for a Xaml node and regenerates the xaml node based on the IDE's xml formatting policy.\nMFractor uses the following rules when sorting:   Attributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example  xmlns:forms=\"http://xamarin.com/schemas/2014/forms\"  will appear before  xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" .  Attributes that belong to the Microsoft Xaml schema  http://schemas.microsoft.com/winfx/2009/xaml  are ordered next. For example, the  x:Class  or  x:Name  declaration.  Attributes belonging to the default namespace are ordered next, sorted alphabetically ascending.  Attributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.", 
            "title": "Sort Xaml Attributes"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/", 
            "text": "Code Issue Fixes\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code fixes in MFractor for Xamarin.Forms\n\n\n24 Code Actions\n\n\nAutocorrect class or property\n\n\nWhen a c# symbol reference expression does not resolve, this fix applies an auto-corrected suggestion from the class/property.\n\n\nAutocorrect property | Generate property\n\n\nWhen the symbol referenced inside a binding expression is unresolved, this fix can either apply an auto-correcet or generate a property on elements the BindingContext\n\n\nCreate x:TypeArguments attribute.\n\n\nGenerates an x:TypeArguments attribute, resolving the potential argument types if possible.\n\n\nGenerate bindable property on type\n\n\nThis fix generates a bindable property onto the targetted class.\n\n\nGenerate class\n\n\nWhen a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.\n\n\nGenerate class and static member\n\n\nWhen a c# symbol reference expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.\n\n\nGenerate event handler method\n\n\nGenerates a method body for an event handler that does not exist in the xaml files code-behind class.\n\n\nGenerate Missing Class\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new implementation of that class.\n\n\nGenerate Missing Value Converter\n\n\nWhen a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.\n\n\nGenerate Missing View\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new implemenation of that class deriving from 'Xamarin.Forms.View'.\n\n\nGenerate property\n\n\nGenerate a static or constant variable onto the targetted class\n\n\nGenerate property onto parent type\n\n\nThis fix generates a property with a getter and setter onto the parent type.\n\n\nImport namespace and assembly\n\n\nWhen the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.\n\n\nImport namespace and assembly\n\n\nWhen an xaml node can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.\n\n\nRemove unused xmlns declaration\n\n\nRemoves the unused xmlns declaration.\n\n\nRemove unused xmlns declaration\n\n\nRemoves the unused xmlns declaration.\n\n\nRename Duplicate Namespace References\n\n\nReplaces all occurances of a namespace with .\n\n\nReplace attribute with closely named member\n\n\nLooks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.\n\n\nReplace field or method reference with property.\n\n\nReplaces a field or method symbol within a binding expression with a suggested property name.\n\n\nReplace node with auto-corrected match\n\n\nThis fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.\n\n\nReplace unknown property value with autocorrection\n\n\nWhen a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.\n\n\nReplace with correct attached property name\n\n\nReplaces an incorrect attached property with an auto-corrected value.\n\n\nReplace x:Name with closely named member\n\n\nReplaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.\n\n\nReplace xml namespace with auto-correction\n\n\nReplaces an xml namespace prefix with the auto-corrected xml namespace.", 
            "title": "Issue Fixing"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#code-issue-fixes", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code fixes in MFractor for Xamarin.Forms  24 Code Actions", 
            "title": "Code Issue Fixes"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#autocorrect-class-or-property", 
            "text": "When a c# symbol reference expression does not resolve, this fix applies an auto-corrected suggestion from the class/property.", 
            "title": "Autocorrect class or property"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#autocorrect-property-generate-property", 
            "text": "When the symbol referenced inside a binding expression is unresolved, this fix can either apply an auto-correcet or generate a property on elements the BindingContext", 
            "title": "Autocorrect property | Generate property"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#create-xtypearguments-attribute", 
            "text": "Generates an x:TypeArguments attribute, resolving the potential argument types if possible.", 
            "title": "Create x:TypeArguments attribute."
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-bindable-property-on-type", 
            "text": "This fix generates a bindable property onto the targetted class.", 
            "title": "Generate bindable property on type"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-class", 
            "text": "When a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.", 
            "title": "Generate class"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-class-and-static-member", 
            "text": "When a c# symbol reference expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.", 
            "title": "Generate class and static member"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-event-handler-method", 
            "text": "Generates a method body for an event handler that does not exist in the xaml files code-behind class.", 
            "title": "Generate event handler method"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-missing-class", 
            "text": "When a Xaml node cannot be resolved, this fix will create a new implementation of that class.", 
            "title": "Generate Missing Class"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-missing-value-converter", 
            "text": "When a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.", 
            "title": "Generate Missing Value Converter"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-missing-view", 
            "text": "When a Xaml node cannot be resolved, this fix will create a new implemenation of that class deriving from 'Xamarin.Forms.View'.", 
            "title": "Generate Missing View"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-property", 
            "text": "Generate a static or constant variable onto the targetted class", 
            "title": "Generate property"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#generate-property-onto-parent-type", 
            "text": "This fix generates a property with a getter and setter onto the parent type.", 
            "title": "Generate property onto parent type"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#import-namespace-and-assembly", 
            "text": "When the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.", 
            "title": "Import namespace and assembly"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#import-namespace-and-assembly_1", 
            "text": "When an xaml node can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.", 
            "title": "Import namespace and assembly"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#remove-unused-xmlns-declaration", 
            "text": "Removes the unused xmlns declaration.", 
            "title": "Remove unused xmlns declaration"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#remove-unused-xmlns-declaration_1", 
            "text": "Removes the unused xmlns declaration.", 
            "title": "Remove unused xmlns declaration"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#rename-duplicate-namespace-references", 
            "text": "Replaces all occurances of a namespace with .", 
            "title": "Rename Duplicate Namespace References"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-attribute-with-closely-named-member", 
            "text": "Looks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.", 
            "title": "Replace attribute with closely named member"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-field-or-method-reference-with-property", 
            "text": "Replaces a field or method symbol within a binding expression with a suggested property name.", 
            "title": "Replace field or method reference with property."
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-node-with-auto-corrected-match", 
            "text": "This fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.", 
            "title": "Replace node with auto-corrected match"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-unknown-property-value-with-autocorrection", 
            "text": "When a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.", 
            "title": "Replace unknown property value with autocorrection"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-with-correct-attached-property-name", 
            "text": "Replaces an incorrect attached property with an auto-corrected value.", 
            "title": "Replace with correct attached property name"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-xname-with-closely-named-member", 
            "text": "Replaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.", 
            "title": "Replace x:Name with closely named member"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fix/#replace-xml-namespace-with-auto-correction", 
            "text": "Replaces an xml namespace prefix with the auto-corrected xml namespace.", 
            "title": "Replace xml namespace with auto-correction"
        }, 
        {
            "location": "/xamarin-android/project-resource-indexing/", 
            "text": "WORK IN PROGRESS", 
            "title": "Project Resource Indexing"
        }, 
        {
            "location": "/xamarin-android/navigation/", 
            "text": "WORK IN PROGRESS\n\n\nNavigation\n\n\nExplore Android projects in a snap with resource tooltips and navigation shortcuts\n\n\nIntroduction", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-android/navigation/#navigation", 
            "text": "Explore Android projects in a snap with resource tooltips and navigation shortcuts", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-android/navigation/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android/analysis/", 
            "text": "WORK IN PROGRESS", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-android/code-actions/", 
            "text": "WORK IN PROGRESS", 
            "title": "Using Code Actions"
        }, 
        {
            "location": "/xamarin-android/dotnet-code-analysis/", 
            "text": "WORK IN PROGRESS", 
            "title": ".NET Code Analysis"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/", 
            "text": "WORK IN PROGRESS\n\n\nResource IntelliSense\n\n\nBuilding Android resource files such as values, menus, drawables or layouts using resource code completion\n\n\nIntroduction", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#resource-intellisense", 
            "text": "Building Android resource files such as values, menus, drawables or layouts using resource code completion", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/", 
            "text": "Xamarin.Android Resource Analysis\n\n\nA complete list of all resource analysers in MFractor for Xamarin.Android - 46 analysers\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\n\nBinding Expression Return Type Mismatch\n\n\nValidates that the .NET symbol returned by a binding expression matches the expected type for the property.\n\n\nBinding Expressions Resolve\n\n\nInspects \nBinding\n expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.\n\n\nClass Does Not Have Attached Property\n\n\nLooks for attached properties (for example \nGrid.Row\n) and validates they exist in the class that they are attempting to use.\n\n\nCode Behind Class Type Mismatch\n\n\nInspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.\n\n\nDuplicate AutomationIds\n\n\nInspects a Xaml document for occurances of duplicate \nAutomationId\n declarations.\n\n\nDuplicate Code Behind Field Declarations\n\n\nChecks that the value assigned to an \nx:Name\n attribute is unique within the scope of the document.\n\n\nDuplicate Namespace Declaration\n\n\nChecks that an xml namespace points to a unique namespace and assembly. For example if both \nxmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"\n and \nxmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"\n were declared, this analyser would warn that they both reference the same assembly and namespace.\n\n\nDuplicate Resource Dictionary Keys\n\n\nValidates the each resource entry within a resource dictionary has a unique key.\n\n\nEmpty Code Behind Field Declaration\n\n\nInspects occurances of the \nx:Name\n attribute and validates that a value is assigned; empty \nx:Name\n expressions generate an empty named code-behind field, causing compilation errors.\n\n\nEvent Handler Exists In Code Behind Class\n\n\nChecks that an event callback referenced referenced by an attribute value exists in the code behind class.\n\n\nEvent Handler Signature Mismatch\n\n\nChecks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.\n\n\nGeneric Usage Is Missing x:TypeArguments\n\n\nInspects generic classes that are instantiated through Xaml and validates that an \nx:TypeArguments\n attribute or property assignment node is present.\n\n\nIValueConverter Input Type Mismatch\n\n\nInspects the \nConverter\n property of a \nBinding\nexpression and validates that the input type is correct. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nIValueConverter Output Type Mismatch\n\n\nInspects the \nConverter\n component of a \nBinding\n expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nMalformed Xmlns Declaration\n\n\nVerifies that a 'xmlns' attribute has both a clr-namespace and an assembly component.\n\n\nMissing Microsoft Schema\n\n\nInspects at the root xaml node and verifies that it references the Microsoft Xaml schema: \nhttp://schemas.microsoft.com/winfx/2009/xaml\n. This schema is required for Xamarin Forms Xaml documents.\n\n\nObsolete Property Used\n\n\nChecks for attributes that are marked as obsolete/deprecated.\n\n\nOnIdiom Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnIdiom\n element is valid with the parent property type.\n\n\nOnPlatform Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnPlatform\n element is valid with the parent property type.\n\n\nProperty Node Maps To Member In Parent Type\n\n\nChecks that a property node resolves to a member within its parent type.\n\n\nProperty Setter Attribute Has Value\n\n\nChecks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.\n\n\nProperty Setter Node Has Value\n\n\nChecks that a value has been provided to a node Property setter (EG \nMyClass.MyProperty\n/MyClass.MyProperty\n).\n\n\nProperty Setter Node Misuse\n\n\nInspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.\n\n\nProperty Setter Type Mismatch\n\n\nWhen using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.\n\n\nRedundant Code Behind Field On Root Node\n\n\nInspects the root Xaml node for a redundant code behind declaration (\nx:Name=\"fieldName\"\n); a code behind field should not be declared on the root element as the code behind class can already be accessed using \nthis\n\n\nReferenced Attribute Member Exists In Parent Type\n\n\nChecks that an attribute resolves to a member within its parent type.\n\n\nReferenced Code Behind Field Exists\n\n\nInspects usages of the \nx:Reference\n expression and validates the referenced element has been declared within the document. \nx:Reference\n expressions are used to resolve another Xaml node has a code behind field defined using the \nx:Name\n attribute.\n\n\nResource Entry Does Not Define Key\n\n\nValidates the elements provided to a resource dictionary supply an \nx:Key\n attribute to declare their resource dictionary key.\n\n\nRoot Element Defines Code Behind Class\n\n\nChecks that the root xaml node defines a code behind class using the \nx:Class\n directive\n\n\nStaticResource Return Type Mismatch\n\n\nValidates that the symbol returned by a \nStaticResource\n expression matches the expected type for the property.\n\n\nUndefined Static Resource Usage\n\n\nValidates that the element referenced by a \nStaticResource\n expression resource lookup resolves to a resource defined in the xaml file.\n\n\nUnknown Static Property Value\n\n\nFor attributes that accept a class object, hecks that the literal value maps to a static property or field in the class type. For example, the \nLayoutOptions\n class has the static fields \nFill\n or \nCentreAndExpand\n that can be used a literal attribute values. If \nCentreAndFill\n was provided, this analyser would inspect \nLayoutOptions\n for a static field named \nCentreAndFill\n and trigger an analysis error when it couldn't be found.\n\n\nUnknown Type Provided To Generic\n\n\nInspects usages of \nx:TypeArguments\n and validates that the type provided exists.\n\n\nUnresolved .NET Symbols Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.\n\n\nUnresolved Namespace Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.\n\n\nUnresolved Xml Namespace\n\n\nChecks that the namespace used on the xml nodes is defined within the current document.\n\n\nUnresolved Xmlns Assembly\n\n\nChecks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.\n\n\nUnused Resource\n\n\nInspects that resource dictionary entries are used via the \nStaticResource\n markup extension expression within this document.\n\n\nUnused Xml Namespace\n\n\nValidate that xmlns attributes that declare a namespace and assembly that is used within the current document.\n\n\nValidate Binding Expressions Return A Property\n\n\nEvaluates a \nBinding\n expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.\n\n\nValidate Value Types\n\n\nInspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.\n\n\nx:Name Has Invalid Characters\n\n\nChecks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.\n\n\nx:Static Return Type Mismatch\n\n\nValidates that the .NET symbol returned by an \nx:Static\n expressions matches the expected type for the property.\n\n\nx:TypeArguments Used On Non-Generic Class\n\n\nInspects for usages of \nx:TypeArguments\n on elements that are non-generic classes.\n\n\nXaml Node Cannot Be Instantiated\n\n\nChecks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.\n\n\nXaml Node Resolves\n\n\nChecks that xaml nodes map to a valid .NET symbol.", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xamarinandroid-resource-analysis", 
            "text": "A complete list of all resource analysers in MFractor for Xamarin.Android - 46 analysers  (Autogenerated by MFractor v2.10.0.0)", 
            "title": "Xamarin.Android Resource Analysis"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#binding-expression-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by a binding expression matches the expected type for the property.", 
            "title": "Binding Expression Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#binding-expressions-resolve", 
            "text": "Inspects  Binding  expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.", 
            "title": "Binding Expressions Resolve"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#class-does-not-have-attached-property", 
            "text": "Looks for attached properties (for example  Grid.Row ) and validates they exist in the class that they are attempting to use.", 
            "title": "Class Does Not Have Attached Property"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#code-behind-class-type-mismatch", 
            "text": "Inspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.", 
            "title": "Code Behind Class Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#duplicate-automationids", 
            "text": "Inspects a Xaml document for occurances of duplicate  AutomationId  declarations.", 
            "title": "Duplicate AutomationIds"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#duplicate-code-behind-field-declarations", 
            "text": "Checks that the value assigned to an  x:Name  attribute is unique within the scope of the document.", 
            "title": "Duplicate Code Behind Field Declarations"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#duplicate-namespace-declaration", 
            "text": "Checks that an xml namespace points to a unique namespace and assembly. For example if both  xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"  and  xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"  were declared, this analyser would warn that they both reference the same assembly and namespace.", 
            "title": "Duplicate Namespace Declaration"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#duplicate-resource-dictionary-keys", 
            "text": "Validates the each resource entry within a resource dictionary has a unique key.", 
            "title": "Duplicate Resource Dictionary Keys"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#empty-code-behind-field-declaration", 
            "text": "Inspects occurances of the  x:Name  attribute and validates that a value is assigned; empty  x:Name  expressions generate an empty named code-behind field, causing compilation errors.", 
            "title": "Empty Code Behind Field Declaration"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#event-handler-exists-in-code-behind-class", 
            "text": "Checks that an event callback referenced referenced by an attribute value exists in the code behind class.", 
            "title": "Event Handler Exists In Code Behind Class"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#event-handler-signature-mismatch", 
            "text": "Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.", 
            "title": "Event Handler Signature Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#generic-usage-is-missing-xtypearguments", 
            "text": "Inspects generic classes that are instantiated through Xaml and validates that an  x:TypeArguments  attribute or property assignment node is present.", 
            "title": "Generic Usage Is Missing x:TypeArguments"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#ivalueconverter-input-type-mismatch", 
            "text": "Inspects the  Converter  property of a  Binding expression and validates that the input type is correct. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "IValueConverter Input Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#ivalueconverter-output-type-mismatch", 
            "text": "Inspects the  Converter  component of a  Binding  expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "IValueConverter Output Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#malformed-xmlns-declaration", 
            "text": "Verifies that a 'xmlns' attribute has both a clr-namespace and an assembly component.", 
            "title": "Malformed Xmlns Declaration"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#missing-microsoft-schema", 
            "text": "Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema:  http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents.", 
            "title": "Missing Microsoft Schema"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#obsolete-property-used", 
            "text": "Checks for attributes that are marked as obsolete/deprecated.", 
            "title": "Obsolete Property Used"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#onidiom-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnIdiom  element is valid with the parent property type.", 
            "title": "OnIdiom Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#onplatform-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnPlatform  element is valid with the parent property type.", 
            "title": "OnPlatform Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#property-node-maps-to-member-in-parent-type", 
            "text": "Checks that a property node resolves to a member within its parent type.", 
            "title": "Property Node Maps To Member In Parent Type"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#property-setter-attribute-has-value", 
            "text": "Checks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.", 
            "title": "Property Setter Attribute Has Value"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#property-setter-node-has-value", 
            "text": "Checks that a value has been provided to a node Property setter (EG  MyClass.MyProperty /MyClass.MyProperty ).", 
            "title": "Property Setter Node Has Value"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#property-setter-node-misuse", 
            "text": "Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.", 
            "title": "Property Setter Node Misuse"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#property-setter-type-mismatch", 
            "text": "When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.", 
            "title": "Property Setter Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#redundant-code-behind-field-on-root-node", 
            "text": "Inspects the root Xaml node for a redundant code behind declaration ( x:Name=\"fieldName\" ); a code behind field should not be declared on the root element as the code behind class can already be accessed using  this", 
            "title": "Redundant Code Behind Field On Root Node"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#referenced-attribute-member-exists-in-parent-type", 
            "text": "Checks that an attribute resolves to a member within its parent type.", 
            "title": "Referenced Attribute Member Exists In Parent Type"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#referenced-code-behind-field-exists", 
            "text": "Inspects usages of the  x:Reference  expression and validates the referenced element has been declared within the document.  x:Reference  expressions are used to resolve another Xaml node has a code behind field defined using the  x:Name  attribute.", 
            "title": "Referenced Code Behind Field Exists"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#resource-entry-does-not-define-key", 
            "text": "Validates the elements provided to a resource dictionary supply an  x:Key  attribute to declare their resource dictionary key.", 
            "title": "Resource Entry Does Not Define Key"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#root-element-defines-code-behind-class", 
            "text": "Checks that the root xaml node defines a code behind class using the  x:Class  directive", 
            "title": "Root Element Defines Code Behind Class"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#staticresource-return-type-mismatch", 
            "text": "Validates that the symbol returned by a  StaticResource  expression matches the expected type for the property.", 
            "title": "StaticResource Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#undefined-static-resource-usage", 
            "text": "Validates that the element referenced by a  StaticResource  expression resource lookup resolves to a resource defined in the xaml file.", 
            "title": "Undefined Static Resource Usage"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unknown-static-property-value", 
            "text": "For attributes that accept a class object, hecks that the literal value maps to a static property or field in the class type. For example, the  LayoutOptions  class has the static fields  Fill  or  CentreAndExpand  that can be used a literal attribute values. If  CentreAndFill  was provided, this analyser would inspect  LayoutOptions  for a static field named  CentreAndFill  and trigger an analysis error when it couldn't be found.", 
            "title": "Unknown Static Property Value"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unknown-type-provided-to-generic", 
            "text": "Inspects usages of  x:TypeArguments  and validates that the type provided exists.", 
            "title": "Unknown Type Provided To Generic"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unresolved-net-symbols-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.", 
            "title": "Unresolved .NET Symbols Within Xaml Expression"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unresolved-namespace-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.", 
            "title": "Unresolved Namespace Within Xaml Expression"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unresolved-xml-namespace", 
            "text": "Checks that the namespace used on the xml nodes is defined within the current document.", 
            "title": "Unresolved Xml Namespace"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unresolved-xmlns-assembly", 
            "text": "Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.", 
            "title": "Unresolved Xmlns Assembly"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unused-resource", 
            "text": "Inspects that resource dictionary entries are used via the  StaticResource  markup extension expression within this document.", 
            "title": "Unused Resource"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#unused-xml-namespace", 
            "text": "Validate that xmlns attributes that declare a namespace and assembly that is used within the current document.", 
            "title": "Unused Xml Namespace"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#validate-binding-expressions-return-a-property", 
            "text": "Evaluates a  Binding  expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.", 
            "title": "Validate Binding Expressions Return A Property"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#validate-value-types", 
            "text": "Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.", 
            "title": "Validate Value Types"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xname-has-invalid-characters", 
            "text": "Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.", 
            "title": "x:Name Has Invalid Characters"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xstatic-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by an  x:Static  expressions matches the expected type for the property.", 
            "title": "x:Static Return Type Mismatch"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xtypearguments-used-on-non-generic-class", 
            "text": "Inspects for usages of  x:TypeArguments  on elements that are non-generic classes.", 
            "title": "x:TypeArguments Used On Non-Generic Class"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xaml-node-cannot-be-instantiated", 
            "text": "Checks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.", 
            "title": "Xaml Node Cannot Be Instantiated"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/#xaml-node-resolves", 
            "text": "Checks that xaml nodes map to a valid .NET symbol.", 
            "title": "Xaml Node Resolves"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/refactor/", 
            "text": "Refactoring\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available refactorings in MFractor for Xamarin.Android\n\n\n0 Code Actions", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/refactor/#refactoring", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available refactorings in MFractor for Xamarin.Android  0 Code Actions", 
            "title": "Refactoring"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/generate/", 
            "text": "Code Generation\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code generation actions in MFractor for Xamarin.Android\n\n\n0 Code Actions", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/generate/#code-generation", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code generation actions in MFractor for Xamarin.Android  0 Code Actions", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/organise/", 
            "text": "Code Organisation\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code organisation actions in MFractor for Xamarin.Android\n\n\n0 Code Actions", 
            "title": "Organisation"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/organise/#code-organisation", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code organisation actions in MFractor for Xamarin.Android  0 Code Actions", 
            "title": "Code Organisation"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/", 
            "text": "Code Issue Fixes\n\n\n(Autogenerated by MFractor v2.10.0.0)\n\nAll available code fixes in MFractor for Xamarin.Android\n\n\n8 Code Actions\n\n\nAdd Required Attributes\n\n\nAdds any missing required attributes and their default values to an xml node.\n\n\nApply Required Value\n\n\nReplaces an attributes value with the required value for xml element. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.\n\n\nFix 9-patch drawable references\n\n\nReplaces a nine patch drawable reference that includes the '.9' suffix with a reference that excludes the '.9' suffix.\n\n\nFix Declarative References\n\n\nReplaces misused declarative resource references with an id reference.\n\n\nFix Flags\n\n\nReplaces a mispelt flag with an auto-corrected suggestion or suggests from a list of valid keywords.\n\n\nFix Keywords\n\n\nReplaces a mispelt keyword with an auto-corrected suggestion or suggests from a list of valid keywords.\n\n\nFix Mispelt Resource Usages\n\n\nReplaces unresolvable resource usages with an auto-suggested value based on the resources available in the project or its references.\n\n\nFix Value Format\n\n\nFixes typeos for inline values such as dimensions, color or floats.", 
            "title": "Issue Fixing"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#code-issue-fixes", 
            "text": "(Autogenerated by MFractor v2.10.0.0) \nAll available code fixes in MFractor for Xamarin.Android  8 Code Actions", 
            "title": "Code Issue Fixes"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#add-required-attributes", 
            "text": "Adds any missing required attributes and their default values to an xml node.", 
            "title": "Add Required Attributes"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#apply-required-value", 
            "text": "Replaces an attributes value with the required value for xml element. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.", 
            "title": "Apply Required Value"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-9-patch-drawable-references", 
            "text": "Replaces a nine patch drawable reference that includes the '.9' suffix with a reference that excludes the '.9' suffix.", 
            "title": "Fix 9-patch drawable references"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-declarative-references", 
            "text": "Replaces misused declarative resource references with an id reference.", 
            "title": "Fix Declarative References"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-flags", 
            "text": "Replaces a mispelt flag with an auto-corrected suggestion or suggests from a list of valid keywords.", 
            "title": "Fix Flags"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-keywords", 
            "text": "Replaces a mispelt keyword with an auto-corrected suggestion or suggests from a list of valid keywords.", 
            "title": "Fix Keywords"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-mispelt-resource-usages", 
            "text": "Replaces unresolvable resource usages with an auto-suggested value based on the resources available in the project or its references.", 
            "title": "Fix Mispelt Resource Usages"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fix/#fix-value-format", 
            "text": "Fixes typeos for inline values such as dimensions, color or floats.", 
            "title": "Fix Value Format"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/intellisense/", 
            "text": "WORK IN PROGRESS", 
            "title": "IntelliSense"
        }, 
        {
            "location": "/tutorials/tutorials/", 
            "text": "Tutorials\n\n\nRead these tutorials to learn a feature in-depth\n\n\nIntroduction\n\n\nThis document lists all the tutorials for MFractor.\n\n\nEach of the tutorials is an in-depth exploration of a feature from first concepts to practical use cases.\n\n\nXamarin.Forms Tutorials\n\n\nMFractor for Xamarin.Forms has the following tutorials:\n\n\n\n\nMvvm Navigation\n: Teaches you to use the Mvvm navigation shortcuts.\n\n\nImplementing ViewModels\n: Learn to generate properties from binding expression and implement entire view models.\n\n\nValue Converter Type Safety\n: Provide type-safety to \nConverter\n expressions by annotating \nIValueConverter\ns with a value conversion attribute.\n\n\n\n\nXamarin.Android Tutorials:\n\n\nMFractor for Xamarin.Android has the following tutorials:\n\n\n\n\nResource Expressions And Code Navigation\n: A deep dive into how MFractor handles resource expressions in both C# and Xml.", 
            "title": "Tutorials"
        }, 
        {
            "location": "/tutorials/tutorials/#tutorials", 
            "text": "Read these tutorials to learn a feature in-depth", 
            "title": "Tutorials"
        }, 
        {
            "location": "/tutorials/tutorials/#introduction", 
            "text": "This document lists all the tutorials for MFractor.  Each of the tutorials is an in-depth exploration of a feature from first concepts to practical use cases.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/tutorials/#xamarinforms-tutorials", 
            "text": "MFractor for Xamarin.Forms has the following tutorials:   Mvvm Navigation : Teaches you to use the Mvvm navigation shortcuts.  Implementing ViewModels : Learn to generate properties from binding expression and implement entire view models.  Value Converter Type Safety : Provide type-safety to  Converter  expressions by annotating  IValueConverter s with a value conversion attribute.", 
            "title": "Xamarin.Forms Tutorials"
        }, 
        {
            "location": "/tutorials/tutorials/#xamarinandroid-tutorials", 
            "text": "MFractor for Xamarin.Android has the following tutorials:   Resource Expressions And Code Navigation : A deep dive into how MFractor handles resource expressions in both C# and Xml.", 
            "title": "Xamarin.Android Tutorials:"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/", 
            "text": "Resource Expressions And Code Navigation\n\n\nLearn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android\n\n\nOverview\n\n\nIf you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.\n\n\nThis becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.\n\n\nAnd this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.\n\n\nMFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.\n\n\nThese expressions come in 2 flavours:\n\n\n\n\nC#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.\n\n\nXML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.\n\n\n\n\nWhen MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.\n\n\nThat is much faster than manual searching! Now lets go over each of these expression types.\n\n\nC# Resource Expressions\n\n\nFor C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the \nAndroid Resource Basics\n page in Xamarins documentation.\n\n\nThe components of a supported resource expression are formatted like so:\n\n\n[Project Namespace].[Resource].[ResourceType].[ResourceName]\n\n\n\n\nWhere:\n\n\n\n\n[Project Namespace] is the project namespace that the Resources designer class resides. This component is either:\n\n\nImplicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.\n\n\nExplicit: The expression explicitly uses the namespace that owns the resource class.\n\n\nResource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.\n\n\nResourceType is the nested resource type class.\n\n\nResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.\n\n\n\n\nAn example of a valid expression would be:\n\n\nResources.String.my_string;\n\n\n\n\nWhen your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.\n\n\nXml Resource Expressions\n\n\nXml resource expressions come in 3 different categories:\n\n\n\n\nReference expressions point directly to a resource. They begin with the \u2018@\u2019 character.\n\n\nDeclarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.\n\n\nTheme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.\n\n\n\n\nReference and declarative expression are structured with the following syntax:\n\n\n@[+][PackageName:]resourceType/resourceName\n\n\n\n\nWhere:\n\n\n\n\n@[+] is the resource reference symbol.\n\n\nPackageName is an optional component that points to the package the resource is within.\n\n\nresourceType is the resource type.\n\n\nresourceName is the name of the resource.\n\n\n\n\nAn example of this would be:\n\n\n@string/my_string\n\n\n\n\nWhen your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.\n\n\nLastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:\n\n\n?[PackageName:][ResourceType/]themeItemName\n\n\n\n\nWhere:\n\n\n\n\nPackageName is the optional package name the theme component resides within.\n\n\nResourceType is the optional resource type of the theme component. This is typically inferred.\n\n\nthemeItemName the name of the theme item.", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#resource-expressions-and-code-navigation", 
            "text": "Learn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#overview", 
            "text": "If you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.  This becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.  And this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.  MFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.  These expressions come in 2 flavours:   C#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.  XML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.   When MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.  That is much faster than manual searching! Now lets go over each of these expression types.", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#c-resource-expressions", 
            "text": "For C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the  Android Resource Basics  page in Xamarins documentation.  The components of a supported resource expression are formatted like so:  [Project Namespace].[Resource].[ResourceType].[ResourceName]  Where:   [Project Namespace] is the project namespace that the Resources designer class resides. This component is either:  Implicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.  Explicit: The expression explicitly uses the namespace that owns the resource class.  Resource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.  ResourceType is the nested resource type class.  ResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.   An example of a valid expression would be:  Resources.String.my_string;  When your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.", 
            "title": "C# Resource Expressions"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#xml-resource-expressions", 
            "text": "Xml resource expressions come in 3 different categories:   Reference expressions point directly to a resource. They begin with the \u2018@\u2019 character.  Declarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.  Theme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.   Reference and declarative expression are structured with the following syntax:  @[+][PackageName:]resourceType/resourceName  Where:   @[+] is the resource reference symbol.  PackageName is an optional component that points to the package the resource is within.  resourceType is the resource type.  resourceName is the name of the resource.   An example of this would be:  @string/my_string  When your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.  Lastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:  ?[PackageName:][ResourceType/]themeItemName  Where:   PackageName is the optional package name the theme component resides within.  ResourceType is the optional resource type of the theme component. This is typically inferred.  themeItemName the name of the theme item.", 
            "title": "Xml Resource Expressions"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/", 
            "text": "Mvvm Navigation\n\n\nQuickly move between Xamarin.Forms Views, View Models and Code behind classes using Mvvm navigation shortcuts\n\n\nOverview\n\n\nXamarin.Forms is cross platform toolkit that allows developers to build iOS, Android and Windows apps and maximise code reuse across platforms. Xamarin.Forms also facilitates shared UI code through the use of an xml based view markup langauge named Xaml.\n\n\nDevelopers build their UI views in Xaml and Xamarin.Forms then inflate the view into it\u2019s native implementation.\n\n\nAlongside shared UI code, Xamarin.Forms uses the Model \u2013 View \u2013 View Model (Mvvm) design pattern to seperate a UI definition it\u2019s from state/behaviour code.\n\n\nThe Mvvm design pattern is a great for maintainabilty and code clarity however developers can spend a lot of time manually nagivating between Xaml views and an associated view model.\n\n\nMFractor adds several navigation shortcuts to speed up developers.\n\n\nGetting Started\nIn this article we will use MFractor to navigate between a Xaml UI definition, it\u2019s code behind class and its associated view model.\n\n\nWe assume the following:\n\n\n\n\nA Xamarin Studio 6.0 installation.\n\n\nMFractor installed into Xamarin Studio. Install it here: www.mfractor.com/download\n\n\nA familiarity with the Xamarin.Forms; particularly building UIs with Xaml and the Model \u2013 View \u2013 View Model design pattern.\n\n\nThe MFractor For Xamarin.Forms sample project downloaded and open in Xamarin Studio.\n\n\n\n\nViews, Code Behind classes and ViewModels\n\n\nLet\u2019s start by examining the MFractor For Xamarin.Forms sample project. Open it up in Xamarin Studio and take a look at the project structure:\n\n\nMFractor For Xamarin.Forms Project\n\n\nThe project itself is trivial; it has a single xaml page with a code behind class and 2 view view models; WelcomeViewModel and GoodbyeViewModel. Notice that this project appends Xaml views with with \u201cPage\u201d and view models with \u201cViewModel\u201d.\n\n\nBefore we get started learning how to use the Mvvm navigation shortcuts, let\u2019s understand the conventions that MFractor uses to drive the navigation.\n\n\nThe \u201cPage/View\" and \"ViewModel\" naming convention\n\n\nIn Xamarin.Forms, the de-facto naming convention is to append views with Page or View and view models are appended with ViewModel.\n\n\nThis naming standard implies that the WelcomePage and the WelcomeViewModel are associated; if we stripped off Page and ViewModel from the file names then both would be named Welcome. This implicit relationship makes the codebase easier to understand by conforming to industry standards.\n\n\nMFractor notices this implicit relationship; if a view and a view model within the same assembly are named like this, a MFractor activates shortcuts between the view, it\u2019s code behind and the associated view model.\n\n\nIf developers don\u2019t want this implicit relationship or their Views/View Models are in seperate assemblies, they may explicitly specify the binding context in the view\u2019s Xaml using the View Model Locator pattern.\n\n\nThe ViewModelLocator Pattern\n\n\nThe ViewModelLocator pattern is a static class used to specify the BindingContext of a Xaml view for design time previewing. James Montemagno re-introduced this concept in his blog post for the Xaml Previewer.\n\n\nDevelopers implement a static class named ViewModelLocator that exposes a static instance of their view models:\n\n\npublic static class ViewModelLocator\n{\n    static MyViewModel _myViewModel;\n    public static MyViewModel MyViewModel =\n _myViewModel ?? (_myViewModel = new MyViewModel());\n}\n\n\n\n\nThis static instance is then bound to the Xaml\u2019s binding context via an x:Static expression:\n\n\n    xmlns:design=\nclr-namespace:MyAppNamespace;assembly=MyApp\n\n    BindingContext=\n{x:Static design:ViewModelLocator.MyViewModel}\n\n\n\n\n\nWhen the BindingContext for a view is explicitly defined, MFractor will honor this relationship and route all Mvvm navigation to the view model class declaration defined by the ViewModelLocator.\n\n\nFor the sample project, we could retarget the WecomePage to link with the GoodbyeViewModel by exposing a static instance through the ViewModelLocator and referencing it using the BindingContext:\n\n\nC#\n\n\npublic static class ViewModelLocator\n{\n    static GoodbyeViewModel _goodebye;\n    public static GoodbyeViewModel GoodbyeViewModel =\n _goodebye ?? (_goodebye = new GoodbyeViewModel());\n}\n\n\n\n\nXaml\n\n\n    xmlns:design=\nclr-namespace:MFractorForForms;assembly=MFractorForForms\n\n    BindingContext=\n{x:Static design:ViewModelLocator.GoodbyeViewModel}\n\n\n\n\n\nFluid Mvvm Navigation\n\n\nNow that we understand how MFractor links the Mvvm code files, let\u2019s get to know the Mvvm navigation shortcuts.\n\n\nOpen up the WelcomePage.xaml and right click in the middle of the editor:\n\n\nMvvm Shortcuts\n\n\nThere are 3 Mvvm navigation shortcuts in MFractor:\n\n\n\n\nGo To Code-Behind Class: Jumps you to the code behind class related to a view or view model\n\n\nGo To View Model: Jumps you to the view model related to a view or code behind class.\n\n\nGo To Xaml View: Jumps you to the xaml view related to a view model or code behind class.\n\n\n\n\nWe can use these short-cuts to quickly navigate around these 3 files:\n\n\nOr we can use an xStatic expression that uses the ViewModelLocator to target a different view model implementation:\n\n\nCustom Binding Context\n\n\nNow the Go To View Model shortcut will instead jump to the class type used by the BindingContext rather than the implicit association.\n\n\nSummary\n\n\nWe\u2019ve learnt how to use MFractors Mvvm navigation shortcuts to quickly move between the View, Code Behind Class and View Model\n\n\nTo continue learning to use MFractor, visit our documentation page.", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#mvvm-navigation", 
            "text": "Quickly move between Xamarin.Forms Views, View Models and Code behind classes using Mvvm navigation shortcuts", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#overview", 
            "text": "Xamarin.Forms is cross platform toolkit that allows developers to build iOS, Android and Windows apps and maximise code reuse across platforms. Xamarin.Forms also facilitates shared UI code through the use of an xml based view markup langauge named Xaml.  Developers build their UI views in Xaml and Xamarin.Forms then inflate the view into it\u2019s native implementation.  Alongside shared UI code, Xamarin.Forms uses the Model \u2013 View \u2013 View Model (Mvvm) design pattern to seperate a UI definition it\u2019s from state/behaviour code.  The Mvvm design pattern is a great for maintainabilty and code clarity however developers can spend a lot of time manually nagivating between Xaml views and an associated view model.  MFractor adds several navigation shortcuts to speed up developers.  Getting Started\nIn this article we will use MFractor to navigate between a Xaml UI definition, it\u2019s code behind class and its associated view model.  We assume the following:   A Xamarin Studio 6.0 installation.  MFractor installed into Xamarin Studio. Install it here: www.mfractor.com/download  A familiarity with the Xamarin.Forms; particularly building UIs with Xaml and the Model \u2013 View \u2013 View Model design pattern.  The MFractor For Xamarin.Forms sample project downloaded and open in Xamarin Studio.", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#views-code-behind-classes-and-viewmodels", 
            "text": "Let\u2019s start by examining the MFractor For Xamarin.Forms sample project. Open it up in Xamarin Studio and take a look at the project structure:  MFractor For Xamarin.Forms Project  The project itself is trivial; it has a single xaml page with a code behind class and 2 view view models; WelcomeViewModel and GoodbyeViewModel. Notice that this project appends Xaml views with with \u201cPage\u201d and view models with \u201cViewModel\u201d.  Before we get started learning how to use the Mvvm navigation shortcuts, let\u2019s understand the conventions that MFractor uses to drive the navigation.", 
            "title": "Views, Code Behind classes and ViewModels"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#the-pageview-and-viewmodel-naming-convention", 
            "text": "In Xamarin.Forms, the de-facto naming convention is to append views with Page or View and view models are appended with ViewModel.  This naming standard implies that the WelcomePage and the WelcomeViewModel are associated; if we stripped off Page and ViewModel from the file names then both would be named Welcome. This implicit relationship makes the codebase easier to understand by conforming to industry standards.  MFractor notices this implicit relationship; if a view and a view model within the same assembly are named like this, a MFractor activates shortcuts between the view, it\u2019s code behind and the associated view model.  If developers don\u2019t want this implicit relationship or their Views/View Models are in seperate assemblies, they may explicitly specify the binding context in the view\u2019s Xaml using the View Model Locator pattern.", 
            "title": "The \u201cPage/View\" and \"ViewModel\" naming convention"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#the-viewmodellocator-pattern", 
            "text": "The ViewModelLocator pattern is a static class used to specify the BindingContext of a Xaml view for design time previewing. James Montemagno re-introduced this concept in his blog post for the Xaml Previewer.  Developers implement a static class named ViewModelLocator that exposes a static instance of their view models:  public static class ViewModelLocator\n{\n    static MyViewModel _myViewModel;\n    public static MyViewModel MyViewModel =  _myViewModel ?? (_myViewModel = new MyViewModel());\n}  This static instance is then bound to the Xaml\u2019s binding context via an x:Static expression:      xmlns:design= clr-namespace:MyAppNamespace;assembly=MyApp \n    BindingContext= {x:Static design:ViewModelLocator.MyViewModel}   When the BindingContext for a view is explicitly defined, MFractor will honor this relationship and route all Mvvm navigation to the view model class declaration defined by the ViewModelLocator.  For the sample project, we could retarget the WecomePage to link with the GoodbyeViewModel by exposing a static instance through the ViewModelLocator and referencing it using the BindingContext:  C#  public static class ViewModelLocator\n{\n    static GoodbyeViewModel _goodebye;\n    public static GoodbyeViewModel GoodbyeViewModel =  _goodebye ?? (_goodebye = new GoodbyeViewModel());\n}  Xaml      xmlns:design= clr-namespace:MFractorForForms;assembly=MFractorForForms \n    BindingContext= {x:Static design:ViewModelLocator.GoodbyeViewModel}", 
            "title": "The ViewModelLocator Pattern"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#fluid-mvvm-navigation", 
            "text": "Now that we understand how MFractor links the Mvvm code files, let\u2019s get to know the Mvvm navigation shortcuts.  Open up the WelcomePage.xaml and right click in the middle of the editor:", 
            "title": "Fluid Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#mvvm-shortcuts", 
            "text": "There are 3 Mvvm navigation shortcuts in MFractor:   Go To Code-Behind Class: Jumps you to the code behind class related to a view or view model  Go To View Model: Jumps you to the view model related to a view or code behind class.  Go To Xaml View: Jumps you to the xaml view related to a view model or code behind class.   We can use these short-cuts to quickly navigate around these 3 files:  Or we can use an xStatic expression that uses the ViewModelLocator to target a different view model implementation:", 
            "title": "Mvvm Shortcuts"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#custom-binding-context", 
            "text": "Now the Go To View Model shortcut will instead jump to the class type used by the BindingContext rather than the implicit association.", 
            "title": "Custom Binding Context"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#summary", 
            "text": "We\u2019ve learnt how to use MFractors Mvvm navigation shortcuts to quickly move between the View, Code Behind Class and View Model  To continue learning to use MFractor, visit our documentation page.", 
            "title": "Summary"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/", 
            "text": "Implementing View Models\n\n\nGenerate properties and view models from Xaml to C# using code fixes and the Implement View Model refactoring\n\n\nIntroduction\n\n\nIn Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.\n\n\nWe accomplish this data-transfer behaviour through the \nBinding Markup Extension\n. This is a Xamarin.Forms API that implements the \nIMarkupExtension interface\n; it reflects changes from the binding context to the view and vice-versa.\n\n\nWe use the binding markup extension syntax in our Xaml views:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\n\n\n\nLoginViewModel.cs\n\n\npublic class LoginViewModel\n{\n  public string Username { get; set; }\n}\n\n\n\n\nIn the above example, \n{Binding Username}\n points to a public property on the \nLogingPage\ns binding context, the \nLoginViewModel\n. When the user enters text, changes are automatically applied into the \nUsername\n property.\n\n\nBut what if we introduced a new \nEntry\n bound to \nPassword\n, a property that doesn't exist on the \nLoginViewModel\n:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nProvided we have configured the views binding context correctly, the \nXaml analyser\n recognises this is a runtime bug and marks it:\n\n\n\n\nMFractor encourages a \nXaml first\n workflow; you write out bindings in Xaml and then generate the implementation on the view model.\n\n\nThis is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the Xaml; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!\n\n\nUsing binding generation we can \nliterally\n eliminate minutes of work and hundreds of keystrokes in a few clicks.\n\n\nMFractor provides the following shortcuts to implement our bound properties:\n\n\n\n\nFix Missing Binding\n: A code issue fix that generates a single binding property onto the view model.\n\n\nImplement View Model\n: A refactoring action that collects \nall\n missing bindings and generates them in bulk on the view model.\n\n\n\n\nLet's examine these two methods of implementing missing properties using MFractor.\n\n\nIssue Fixing on Missing Bindings\n\n\nWhen MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.\n\n\nTo action the code isxue fix, we right click on the issue (underlined in yellow), navigate to \nFix\n and then select \nGenerate a property...\n.\n\n\n\n\nWe have two options available when generating a property:\n\n\nGenerate a property named XXX in XXX\n creates a new public property with a public \nget\n and \nset\n accessor:\n\n\npublic string Password { get; set; }\n\n\n\n\nGenerate a property named XXX in XXX with backing fields\n creates a new public property with a public \nget\n and \nset\n accessor that sets or gets a backing field:\n\n\nprivate string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}\n\n\n\n\nThe default getter / setter fix is most useful when:\n\n\n\n\nWe want a plain old property with no backing logic.\n\n\nWe are using Fody's \nImplementPropertyChanged\n attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.\n\n\n\n\nThe backing field fix is most useful when:\n\n\n\n\nWe want backing logic that occurs when our property changes.\n\n\nWe occasionally want to manipulate the properties backing field without changes propagating to the UI.\n\n\n\n\nThe Implement ViewModel Refactoring\n\n\nAnother way to generate properties for a view model is to use the \nImplement View Model\n refactoring. This shortcut collects \nall\n missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.\n\n\nWe can access this short cut by right clicking anywhere in a Xaml file, navigating to \nGenerate\n and then selecting the \nImplement View Model\n action:\n\n\n\n\nYou'll notice that there are 2 actions:\n\n\n\n\nImplement View Model\n gathers all missing bindings in the xaml document and implements them all as public properties with a public \nget\n and \nset\n accessor.\n\n\nImplement View Model (Use Backing Fields)\n gathers all missing bindings in the xaml document and implements them all as public properties with a public \nget\n and \nset\n accessor that sets or gets a backing field.\n\n\n\n\nThere are often cases when a binding context isn't specified \nexplicitly \n and can't be inferred \nimplicitly\n. A common example of this is that you have just started to build a Xaml view and haven't yet got around to building the corresponding view model.\n\n\nThe \nImplement View Model\n action can also generate a view model class for the Xaml view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your xaml view under the \nMyDefaultNamespace.ViewModels\n namespace.\n\n\nFor example:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nWhen creating the view model class, MFractor removes the \nPage\n or \nView\n suffix from the view name and then attaches \nViewModel\n to the end of the resulting name.\n\n\n\n\n\n\n\n\nRemove the \nPage\n or \nView\n suffix: LoginPage -\n Login\n\n\n\n\n\n\n\n\n\n\nAttach the \nViewModel\n suffix: Login -\n LoginViewModel\n\n\n\n\n\n\n\n\n\n\nGenerate a new class named \nLoginViewModel\n under the namespace \nMyDefaultNamespace.ViewModels\n.\n\n\n\n\n\n\n\n\nThis would result in the following view model class file:\n\n\nLoginViewModel.cs\n\n\npublic namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}\n\n\n\n\nIf you project references Fody's \nImplementPropertyChanged\n extension, the default getter / setter implementation will also annotate the result with the \n[ImplementPropertyChanged.PropertyChanged]\n attribute:\n\n\nLoginViewModel.cs\n\n\n[ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}\n\n\n\n\nGenerating Commands Implementations\n\n\nWhen MFractor encounters a property that expects the \nSystem.Windows.Input.ICommand\n interface, it will generate a property returning a empty command implementation.\n\n\nFor example, we bind our login button to a \nLoginCommand\n property on our view model:\n\n\nButton Command=\n{Binding LoginCommand}\n/\n\n\n\n\n\nWhen MFractor generates the property for \nLoginCommand\n, it creates an empty command implementation:\n\n\npublic System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() =\n\n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}\n\n\n\n\nBinding Generation And Value Converters\n\n\nWhen a binding expression uses a \nConverter\n, MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the \nIValueConverter\n for MFractor to resolve the input type. Please read the \nValue Conversion Type-Safety\n tutorial to learn more.\n\n\nFor example, we add a login button that is only enabled when the user has their password entered:\n\n\nResourceDictionary\n\n    \nlocal:StringToBoolConverter x:Key=\nstringToBoolConverter\n /\n\n\n/ResourceDictionary\n\n\n\nButton IsEnabled=\n{Binding Password, Converter={StaticResource stringToBoolConverter}}\n/\n\n\n\n\n\nProvided that \nstringToBoolConverter\n is annotated to accept string inputs and return a boolean output, MFractor can still generate \nPassword\n as a string even though \nIsEnabled\n is a boolean property.\n\n\nIf there is no value conversion information on the value converter, MFractor will default to \nSysten.Object\n as the type for our property:\n\n\npublic System.Object Password\n{\n  get; set;\n}\n\n\n\n\nLimitations\n\n\nThere are a some limitations in the \nImplement View Model\n refactoring:\n\n\n\n\nWhen a Xaml view has an item that uses a \nDataTemplate\n to declare an inline view, MFractor \nwill not\n gather the bindings inside the data template. A refactoring action to generate bindings for data templates will be coming in a future MFractor release.\n\n\n\n\nSummary\n\n\nBy building our apps using the \nXaml first\n mindset, we can leverage MFractor's binding generation to implement our view models quickly.\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can generate entire view models using the \nImplement View Model\n refactoring action.\n\n\nWe can generate single properties using code issue fixing.\n\n\nWe need a binding context to activate binding expression analysis and issue fixing.\n\n\nWhen a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#implementing-view-models", 
            "text": "Generate properties and view models from Xaml to C# using code fixes and the Implement View Model refactoring", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#introduction", 
            "text": "In Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.  We accomplish this data-transfer behaviour through the  Binding Markup Extension . This is a Xamarin.Forms API that implements the  IMarkupExtension interface ; it reflects changes from the binding context to the view and vice-versa.  We use the binding markup extension syntax in our Xaml views:  LoginPage.xaml.cs  Entry Text= {Binding Username} /   LoginViewModel.cs  public class LoginViewModel\n{\n  public string Username { get; set; }\n}  In the above example,  {Binding Username}  points to a public property on the  LogingPage s binding context, the  LoginViewModel . When the user enters text, changes are automatically applied into the  Username  property.  But what if we introduced a new  Entry  bound to  Password , a property that doesn't exist on the  LoginViewModel :  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   Provided we have configured the views binding context correctly, the  Xaml analyser  recognises this is a runtime bug and marks it:   MFractor encourages a  Xaml first  workflow; you write out bindings in Xaml and then generate the implementation on the view model.  This is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the Xaml; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!  Using binding generation we can  literally  eliminate minutes of work and hundreds of keystrokes in a few clicks.  MFractor provides the following shortcuts to implement our bound properties:   Fix Missing Binding : A code issue fix that generates a single binding property onto the view model.  Implement View Model : A refactoring action that collects  all  missing bindings and generates them in bulk on the view model.   Let's examine these two methods of implementing missing properties using MFractor.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#issue-fixing-on-missing-bindings", 
            "text": "When MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.  To action the code isxue fix, we right click on the issue (underlined in yellow), navigate to  Fix  and then select  Generate a property... .   We have two options available when generating a property:  Generate a property named XXX in XXX  creates a new public property with a public  get  and  set  accessor:  public string Password { get; set; }  Generate a property named XXX in XXX with backing fields  creates a new public property with a public  get  and  set  accessor that sets or gets a backing field:  private string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}  The default getter / setter fix is most useful when:   We want a plain old property with no backing logic.  We are using Fody's  ImplementPropertyChanged  attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.   The backing field fix is most useful when:   We want backing logic that occurs when our property changes.  We occasionally want to manipulate the properties backing field without changes propagating to the UI.", 
            "title": "Issue Fixing on Missing Bindings"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#the-implement-viewmodel-refactoring", 
            "text": "Another way to generate properties for a view model is to use the  Implement View Model  refactoring. This shortcut collects  all  missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.  We can access this short cut by right clicking anywhere in a Xaml file, navigating to  Generate  and then selecting the  Implement View Model  action:   You'll notice that there are 2 actions:   Implement View Model  gathers all missing bindings in the xaml document and implements them all as public properties with a public  get  and  set  accessor.  Implement View Model (Use Backing Fields)  gathers all missing bindings in the xaml document and implements them all as public properties with a public  get  and  set  accessor that sets or gets a backing field.   There are often cases when a binding context isn't specified  explicitly   and can't be inferred  implicitly . A common example of this is that you have just started to build a Xaml view and haven't yet got around to building the corresponding view model.  The  Implement View Model  action can also generate a view model class for the Xaml view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your xaml view under the  MyDefaultNamespace.ViewModels  namespace.  For example:  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   When creating the view model class, MFractor removes the  Page  or  View  suffix from the view name and then attaches  ViewModel  to the end of the resulting name.     Remove the  Page  or  View  suffix: LoginPage -  Login      Attach the  ViewModel  suffix: Login -  LoginViewModel      Generate a new class named  LoginViewModel  under the namespace  MyDefaultNamespace.ViewModels .     This would result in the following view model class file:  LoginViewModel.cs  public namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}  If you project references Fody's  ImplementPropertyChanged  extension, the default getter / setter implementation will also annotate the result with the  [ImplementPropertyChanged.PropertyChanged]  attribute:  LoginViewModel.cs  [ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}", 
            "title": "The Implement ViewModel Refactoring"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#generating-commands-implementations", 
            "text": "When MFractor encounters a property that expects the  System.Windows.Input.ICommand  interface, it will generate a property returning a empty command implementation.  For example, we bind our login button to a  LoginCommand  property on our view model:  Button Command= {Binding LoginCommand} /   When MFractor generates the property for  LoginCommand , it creates an empty command implementation:  public System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() = \n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}", 
            "title": "Generating Commands Implementations"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#binding-generation-and-value-converters", 
            "text": "When a binding expression uses a  Converter , MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the  IValueConverter  for MFractor to resolve the input type. Please read the  Value Conversion Type-Safety  tutorial to learn more.  For example, we add a login button that is only enabled when the user has their password entered:  ResourceDictionary \n     local:StringToBoolConverter x:Key= stringToBoolConverter  /  /ResourceDictionary  Button IsEnabled= {Binding Password, Converter={StaticResource stringToBoolConverter}} /   Provided that  stringToBoolConverter  is annotated to accept string inputs and return a boolean output, MFractor can still generate  Password  as a string even though  IsEnabled  is a boolean property.  If there is no value conversion information on the value converter, MFractor will default to  Systen.Object  as the type for our property:  public System.Object Password\n{\n  get; set;\n}", 
            "title": "Binding Generation And Value Converters"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#limitations", 
            "text": "There are a some limitations in the  Implement View Model  refactoring:   When a Xaml view has an item that uses a  DataTemplate  to declare an inline view, MFractor  will not  gather the bindings inside the data template. A refactoring action to generate bindings for data templates will be coming in a future MFractor release.", 
            "title": "Limitations"
        }, 
        {
            "location": "/tutorials/xamarin-forms/implementing-view-models/#summary", 
            "text": "By building our apps using the  Xaml first  mindset, we can leverage MFractor's binding generation to implement our view models quickly.  In this tutorial we learnt:   We can generate entire view models using the  Implement View Model  refactoring action.  We can generate single properties using code issue fixing.  We need a binding context to activate binding expression analysis and issue fixing.  When a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Summary"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/", 
            "text": "Value Converter Type Safety\n\n\nProvide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute\n\n\nIntroduction\n\n\nIn Xamarin.Forms developers data bind properties in a control to properties on a binding context using the \nBinding\n markup extension.\n\n\nTypically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?\n\n\nEnter the \nIValueConverter interface\n; value converters transform one data type to another.\n\n\nWe can expose a boolean \nIsEmailValid\n on our binding context, bind the \nTextColor\n field of the entry to the \nIsEmailValid\n property and use an \nIValueConverter\n that converts a \nTrue\n value to black and a \nFalse\n value to red.\n\n\nOur converter would look like this:\n\n\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nAnd when used in our xaml:\n\n\nLoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nContentPage\n        xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n        xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n        x:Class=\nMyApp.LoginPage\n\n        xmlns:converters=\nclr-namespace:MyApp.Converters;assembly=MyApp\n\n    \nContentPage.Resources\n\n        \nResourceDictionary\n\n            \nconverters:BoolToTextColorConverter x:Key=\nboolToTextColorConverter\n /\n\n        \n/ResourceDictionary\n\n    \n/ContentPage.Resources\n\n    \nEntry TextColor=\n{Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n/ContentPage\n\n\n\n\n\nNow when the user enters an invalid email, the value converter will translate the \nIsEmailValid\n boolean property in a \nXamarin.Forms.Color\n!\n\n\nBut what if we accidentally provided a \nstring\n to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nThis creates a runtime bug we won't discover until we build, deploy and navigate to the \nLoginPage\n; we'll see a type cast exception without a clear indication of the problem.\n\n\nWe can completely avoid this problem by declaring a value converters intent with an \nValueConversionAttribute\n to hint to MFractor's Xaml analyser it's expected behaviour.\n\n\nThe ValueConversion Attribute\n\n\nIn WPF, Microsoft provides the \nValueConversionAttribute\n that developers can use to describe the input, output and parameter type that an \nIValueConverter\n expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.\n\n\nUnfortunately this attribute is in the \nPresentationFramework\n assembly, which we can't reference in a Xamarin.Forms PCL or shared project.\n\n\nAs the \nValueConversionAttribute\n is simple in implementation, we can easily make our own:\n\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}\n\n\n\n\nLet's examine this attribute in detail:\n\n\n\n\nThe constructor \nValueConversionAttribute(Type input, Type output)\n declares the expected input and output types for a converter.\n\n\nType input\n is the expected \ninput\n type for the value converter. This is the argument \nobject value\n for the \nConvert\n method and the return type for the \nConvertBack\n method.\n\n\nType output\n is the expected \noutput\n type for the value converter. This is the return type for the \nConvert\n method and the argument \nobject value\n for the \nConvertBack\n method.\n\n\nThe property \nType ParameterType\n is the expected \nparamter\n type for the value converter. This is the argument \nobject parameter\n for the \nConvert\n and \nConvertBack\n methods.\n\n\n\n\nTo use the \nValueConversionAttribute\n in our source code, we annotate a value converter at the class level and use the \ntypeof\n operator to provide input, output and parameter types:\n\n\n[ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nThe \nBoolToTextColorConverter\n now declares it's intent when converting values to both tooling and other developers; it \nmust\n have a \nbool\n as an input and it \nmust\n return into a \nXamarin.Forms.Color\n type.\n\n\nTo include the \nValueConversionAttribute\n we can simply copy-paste the code into our code base. Alternatively, add a third party library like \nFormsCommunityToolkit.Converters\n that has the \nValueConversionAttribute\n defined.\n\n\nConverter Type-Safety in Xaml\n\n\nWhen an \nIValueConverter\n is annotated with the \nValueConversion\n attribute, we declare to MFractor that our value converter wishes to enforce \ntype safety\n.\n\n\nThis has a few benefits:\n\n\n\n\nMFractor can now verify the types passed into and returned by a \nConverter\n expression are correct in the given context.\n\n\nWhen MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.\n\n\n\n\nLet's consider our previous example of a provided a string as the input to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nWhen analysing the \nBinding\n expression, MFractor will inspect for \nConverter\n expressions and then evaluate the inner converter for it's expected input and output type.\n\n\nAs we have provided a \nstring\n but \nBoolToTextColorConverter\n expects a \nbool\n, MFractor will mark this as an error within the Xaml editor:\n\n\n\n\nVoila! We now have type-safety in our Xaml when using value converters! \u2728\u2728\n\n\nAnnotated value converters also allow the refactoring engine to correctly generate properties.\n\n\nFor example, if the our binding context is missing the \nEmail\n property, MFractor will extract the input type from the value converter and use that to generate the binding property:\n\n\n\n\nInstead of using the type of the \nTextColor\n property, MFractor could see that \nBoolToTextColorConverter\n expected a \nbool\n value and then generated the \nEmail\n property with a \nbool\n.\n\n\nSummary\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can annotate implementations of \nIValueConverter\n with a \nValueConversionAttribute\n to declare it's value conversion intent.\n\n\nAnnotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.\n\n\nAnnotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/#value-converter-type-safety", 
            "text": "Provide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/#introduction", 
            "text": "In Xamarin.Forms developers data bind properties in a control to properties on a binding context using the  Binding  markup extension.  Typically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?  Enter the  IValueConverter interface ; value converters transform one data type to another.  We can expose a boolean  IsEmailValid  on our binding context, bind the  TextColor  field of the entry to the  IsEmailValid  property and use an  IValueConverter  that converts a  True  value to black and a  False  value to red.  Our converter would look like this:  public class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  And when used in our xaml:  LoginPage.xaml  ?xml version= 1.0  encoding= UTF-8 ?  ContentPage\n        xmlns= http://xamarin.com/schemas/2014/forms \n        xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n        x:Class= MyApp.LoginPage \n        xmlns:converters= clr-namespace:MyApp.Converters;assembly=MyApp \n     ContentPage.Resources \n         ResourceDictionary \n             converters:BoolToTextColorConverter x:Key= boolToTextColorConverter  / \n         /ResourceDictionary \n     /ContentPage.Resources \n     Entry TextColor= {Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}} /  /ContentPage   Now when the user enters an invalid email, the value converter will translate the  IsEmailValid  boolean property in a  Xamarin.Forms.Color !  But what if we accidentally provided a  string  to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   This creates a runtime bug we won't discover until we build, deploy and navigate to the  LoginPage ; we'll see a type cast exception without a clear indication of the problem.  We can completely avoid this problem by declaring a value converters intent with an  ValueConversionAttribute  to hint to MFractor's Xaml analyser it's expected behaviour.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/#the-valueconversion-attribute", 
            "text": "In WPF, Microsoft provides the  ValueConversionAttribute  that developers can use to describe the input, output and parameter type that an  IValueConverter  expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.  Unfortunately this attribute is in the  PresentationFramework  assembly, which we can't reference in a Xamarin.Forms PCL or shared project.  As the  ValueConversionAttribute  is simple in implementation, we can easily make our own:  [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}  Let's examine this attribute in detail:   The constructor  ValueConversionAttribute(Type input, Type output)  declares the expected input and output types for a converter.  Type input  is the expected  input  type for the value converter. This is the argument  object value  for the  Convert  method and the return type for the  ConvertBack  method.  Type output  is the expected  output  type for the value converter. This is the return type for the  Convert  method and the argument  object value  for the  ConvertBack  method.  The property  Type ParameterType  is the expected  paramter  type for the value converter. This is the argument  object parameter  for the  Convert  and  ConvertBack  methods.   To use the  ValueConversionAttribute  in our source code, we annotate a value converter at the class level and use the  typeof  operator to provide input, output and parameter types:  [ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  The  BoolToTextColorConverter  now declares it's intent when converting values to both tooling and other developers; it  must  have a  bool  as an input and it  must  return into a  Xamarin.Forms.Color  type.  To include the  ValueConversionAttribute  we can simply copy-paste the code into our code base. Alternatively, add a third party library like  FormsCommunityToolkit.Converters  that has the  ValueConversionAttribute  defined.", 
            "title": "The ValueConversion Attribute"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/#converter-type-safety-in-xaml", 
            "text": "When an  IValueConverter  is annotated with the  ValueConversion  attribute, we declare to MFractor that our value converter wishes to enforce  type safety .  This has a few benefits:   MFractor can now verify the types passed into and returned by a  Converter  expression are correct in the given context.  When MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.   Let's consider our previous example of a provided a string as the input to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   When analysing the  Binding  expression, MFractor will inspect for  Converter  expressions and then evaluate the inner converter for it's expected input and output type.  As we have provided a  string  but  BoolToTextColorConverter  expects a  bool , MFractor will mark this as an error within the Xaml editor:   Voila! We now have type-safety in our Xaml when using value converters! \u2728\u2728  Annotated value converters also allow the refactoring engine to correctly generate properties.  For example, if the our binding context is missing the  Email  property, MFractor will extract the input type from the value converter and use that to generate the binding property:   Instead of using the type of the  TextColor  property, MFractor could see that  BoolToTextColorConverter  expected a  bool  value and then generated the  Email  property with a  bool .", 
            "title": "Converter Type-Safety in Xaml"
        }, 
        {
            "location": "/tutorials/xamarin-forms/value-converter-type-safety/#summary", 
            "text": "In this tutorial we learnt:   We can annotate implementations of  IValueConverter  with a  ValueConversionAttribute  to declare it's value conversion intent.  Annotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.  Annotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Summary"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/", 
            "text": "Organising Xaml Code\n\n\nTidy up your Xaml code with the expand, collapse and sort tools\n\n\nIntroduction\n\n\nIn this tutorial we'll go over the most useful Xaml organising refactorings. We'll cover MFractors Xaml formatting conventions, how to sort attributes and how to expand and collapse attributes and nodes.\n\n\nThese refactorings make it very easy to keep your Xaml organised and thus easier to understand.\n\n\nSorting Attributes\n\n\nThe \nSort Attributes\n operation arranges a Xaml nodes attributes in order of namespace and name; this is great for keeping your Xaml tidy and easy to understand!\n\n\nMFractor uses the following rules when sorting:\n\n\n\n\nAttributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example \nxmlns:forms=\"http://xamarin.com/schemas/2014/forms\"\n will appear before \nxmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n.\n\n\nAttributes that belong to the Microsoft Xaml schema \nhttp://schemas.microsoft.com/winfx/2009/xaml\n are ordered next. For example, the \nx:Class\n or \nx:Name\n declaration.\n\n\nAttributes belonging to the default namespace are ordered next, sorted alphabetically ascending.\n\n\nAttributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.\n\n\n\n\nTo access the \nsort\n operation, right click on a Xaml node definition, select \nOrganise\n and then \nSort Attributes\n:\n\n\n\n\nExpanding And Collapsing Attributes\n\n\nWe can use the following organise refactorings to arrange a xaml nodes attributes:\n\n\n\n\nSplit attributes onto separate lines\n will breakout each xaml attribute onto it's own line, aligning themselves with a slight indentation from their parent node.\n\n\nCollapse attributes onto same line\n will move all attributes onto the same line as their parents opening tag.\n\n\n\n\n\n\nExpanding And Collapsing Nodes\n\n\nWe can use the following organise refactorings to expand and collapse a Xaml node:\n\n\n\n\nExpand node into opening and clossing tag\n take a self-closing Xaml node (IE: \nLabel /\n) and generate a closing tag for it (IE: \nLabel\n/Label\n).\n\n\nCollapse closing tag\n takes an empty node with a closing tag (IE: \nLabel\n/Label\n) and remove the closing tag, making the node self-closing (IE: \nLabel /\n).", 
            "title": "Organising Xaml Code"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/#organising-xaml-code", 
            "text": "Tidy up your Xaml code with the expand, collapse and sort tools", 
            "title": "Organising Xaml Code"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/#introduction", 
            "text": "In this tutorial we'll go over the most useful Xaml organising refactorings. We'll cover MFractors Xaml formatting conventions, how to sort attributes and how to expand and collapse attributes and nodes.  These refactorings make it very easy to keep your Xaml organised and thus easier to understand.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/#sorting-attributes", 
            "text": "The  Sort Attributes  operation arranges a Xaml nodes attributes in order of namespace and name; this is great for keeping your Xaml tidy and easy to understand!  MFractor uses the following rules when sorting:   Attributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example  xmlns:forms=\"http://xamarin.com/schemas/2014/forms\"  will appear before  xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" .  Attributes that belong to the Microsoft Xaml schema  http://schemas.microsoft.com/winfx/2009/xaml  are ordered next. For example, the  x:Class  or  x:Name  declaration.  Attributes belonging to the default namespace are ordered next, sorted alphabetically ascending.  Attributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.   To access the  sort  operation, right click on a Xaml node definition, select  Organise  and then  Sort Attributes :", 
            "title": "Sorting Attributes"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/#expanding-and-collapsing-attributes", 
            "text": "We can use the following organise refactorings to arrange a xaml nodes attributes:   Split attributes onto separate lines  will breakout each xaml attribute onto it's own line, aligning themselves with a slight indentation from their parent node.  Collapse attributes onto same line  will move all attributes onto the same line as their parents opening tag.", 
            "title": "Expanding And Collapsing Attributes"
        }, 
        {
            "location": "/tutorials/xamarin-forms/organising-xaml-code/#expanding-and-collapsing-nodes", 
            "text": "We can use the following organise refactorings to expand and collapse a Xaml node:   Expand node into opening and clossing tag  take a self-closing Xaml node (IE:  Label / ) and generate a closing tag for it (IE:  Label /Label ).  Collapse closing tag  takes an empty node with a closing tag (IE:  Label /Label ) and remove the closing tag, making the node self-closing (IE:  Label / ).", 
            "title": "Expanding And Collapsing Nodes"
        }, 
        {
            "location": "/release-notes/v2-10/", 
            "text": "Release Notes - v2.10.0\n\n\n6th March 2017\n\n\nDownload MFractor 2.10.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.10.0 of MFractor for Xamarin Studio.\n\n\nThis release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:\n\n\n\n\nFeatures\n\n\n\n\nThe quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!\n\n\nThe xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now\n\n\nAn improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.\n\n\n\n\nEnhancements\n\n\n\n\nImprove the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.", 
            "title": "v2.10"
        }, 
        {
            "location": "/release-notes/v2-10/#release-notes-v2100", 
            "text": "6th March 2017  Download MFractor 2.10.0", 
            "title": "Release Notes - v2.10.0"
        }, 
        {
            "location": "/release-notes/v2-10/#introduction", 
            "text": "This is a summary of the changes introduced in v2.10.0 of MFractor for Xamarin Studio.  This release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-10/#features", 
            "text": "The quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!  The xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now  An improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-10/#enhancements", 
            "text": "Improve the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-10/#bug-fixes", 
            "text": "Fixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-9/", 
            "text": "Release Notes - v2.9.4\n\n\n22nd February 2017\n\n\nDownload MFractor 2.9.4\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.9.4 of MFractor for Xamarin Studio.\n\n\nImportant: If Xamarin Studio loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version\n\n\nThis release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.\n\n\nIt's also easier than ever to build out custom controls, the new \nImplement Missing Members\n code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!\n\n\nHold onto your socks!\n\n\n\n\nFeatures\n\n\n\n\nNew Refactorings\n\n\nRight click on an \nxmlns\n declaration on the root node and select \nRefactor\n -\n \nRename Xaml Namespace\n to rename all occurrences of that namespace in the doc!\n\n\n\n\n\n\nNew Code Organisers\n\n\nRight click on the root xaml node and select \nOrganise\n -\n \nFormat\n to organise your entire xaml document.\n\n\n\n\n\n\nNew Code Generators\n\n\nQuickly build out Grids by using the \nInsert Row Definitions\n and \nInsert Column Definitions\n actions.\n\n\nBulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting \nImplement missing members\n.\n\n\n\n\n\n\nNew Xaml Analysers\n\n\nDetect if the root xaml element uses a \nx:Name\n attribute as this is redundant.\n\n\nDetect duplicate xaml namespaces that reference the same namespace and assembly.\n\n\nDetect when the xaml views code behind class derives from a different type than what is declared by it's root element.\n\n\n\n\n\n\nNew Code Fixes\n\n\nWhen a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nFreshMVVM style page models (EG: LoginPageModel) are now supported for view \n-\n view model \n-\n code behind association.\n\n\nThe \nModel\n suffix (EG: LoginModel) is now supported for view \n-\n view model \n-\n code behind association.\n\n\nThis release targets Xamarin Studio v6.2.\n\n\n\n\nBug Fixes\n\n\n\n\nUndefined StaticResource detection has been disabled in this release.\n\n\nFixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using \nSystem.Object\n.\n\n\nFixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use \nSystem.Object\n.\n\n\nFixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.\n\n\nFixed: When the Xamarin Studio Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.", 
            "title": "v2.9"
        }, 
        {
            "location": "/release-notes/v2-9/#release-notes-v294", 
            "text": "22nd February 2017  Download MFractor 2.9.4", 
            "title": "Release Notes - v2.9.4"
        }, 
        {
            "location": "/release-notes/v2-9/#introduction", 
            "text": "This is a summary of the changes introduced in v2.9.4 of MFractor for Xamarin Studio.  Important: If Xamarin Studio loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version  This release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.  It's also easier than ever to build out custom controls, the new  Implement Missing Members  code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!  Hold onto your socks!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-9/#features", 
            "text": "New Refactorings  Right click on an  xmlns  declaration on the root node and select  Refactor  -   Rename Xaml Namespace  to rename all occurrences of that namespace in the doc!    New Code Organisers  Right click on the root xaml node and select  Organise  -   Format  to organise your entire xaml document.    New Code Generators  Quickly build out Grids by using the  Insert Row Definitions  and  Insert Column Definitions  actions.  Bulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting  Implement missing members .    New Xaml Analysers  Detect if the root xaml element uses a  x:Name  attribute as this is redundant.  Detect duplicate xaml namespaces that reference the same namespace and assembly.  Detect when the xaml views code behind class derives from a different type than what is declared by it's root element.    New Code Fixes  When a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-9/#enhancements", 
            "text": "FreshMVVM style page models (EG: LoginPageModel) are now supported for view  -  view model  -  code behind association.  The  Model  suffix (EG: LoginModel) is now supported for view  -  view model  -  code behind association.  This release targets Xamarin Studio v6.2.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-9/#bug-fixes", 
            "text": "Undefined StaticResource detection has been disabled in this release.  Fixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using  System.Object .  Fixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use  System.Object .  Fixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.  Fixed: When the Xamarin Studio Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-8/", 
            "text": "Release Notes - v2.8.0\n\n\n12th February 2017\n\n\nDownload MFractor 2.8.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.8.0 of MFractor for Xamarin Studio.\n\n\nThis release focuses on adding new refactoring and code generation actions into the Xaml editor.\n\n\nYou can now sort your xaml, edit colors interactively, extract values into binding expressions and more:\n\n\n\n\nFeatures\n\n\n\n\nNew Refactorings\n\n\nRight click on a xaml attribute property that's a \nSystem.Drawing.Color\n or a \nXamarin.Forms.Color\n and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.\n\n\nRight click on a xaml attribute property that has a literal value and extract it into a \nBinding\n expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.\n\n\nOrganise Refactorings:\n\n\nThe \nCollapse Xaml Attributes\n refactoring will collapse all xaml attributes onto the same line as the parent xaml node.\n\n\nThe \nExpand Xaml Attributes\n refactoring will expand all xaml attributes onto separate lines.\n\n\nThe \nSort Xaml Attributes\n refactoring will sort the attributes for a xaml node by namespace and name.\n\n\nThe \nExpand Node\n refactoring takes a self-closing xaml node and generate a closing tag for it.\n\n\nThe \nCollapse Node\n refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.\n\n\n\n\n\n\n\n\n\n\nNew Code Generators\n\n\nRight click on an xaml node that inherits from \nXamarin.Forms.VisualElement\n or \nXamarin.Forms.Application\n and select \nAdd Resource Dictionary\n to generate a resource dictionary for that element.\n\n\n\n\n\n\nNew Xaml Analysers\n\n\nDetect when an \nx:Name\n code-behind field declaration is empty.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Xamarin Studio v6.1.5\n\n\nThe \nImplement View Model\n refactoring has been moved from the \nRefactor\n menu to \nGenerate\n.\n\n\nHover over a xaml attribute property that's a \nSystem.Drawing.Color\n or a \nXamarin.Forms.Color\n to see the color value inside the tooltip.\n\n\nThe Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the \nHelp\n -\n \nMFractor\n -\n \nInstall Android SDK Meta-Data\n menu item.\n\n\n\n\nBug Fixes\n\n\n\n\nCorrectly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.\n\n\nDon't allow the 'Simplify' refactoring to run against expressions.\n\n\nFix multiple type conversion checking bugs in the ValueConversion attribute validation.", 
            "title": "v2.8"
        }, 
        {
            "location": "/release-notes/v2-8/#release-notes-v280", 
            "text": "12th February 2017  Download MFractor 2.8.0", 
            "title": "Release Notes - v2.8.0"
        }, 
        {
            "location": "/release-notes/v2-8/#introduction", 
            "text": "This is a summary of the changes introduced in v2.8.0 of MFractor for Xamarin Studio.  This release focuses on adding new refactoring and code generation actions into the Xaml editor.  You can now sort your xaml, edit colors interactively, extract values into binding expressions and more:", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-8/#features", 
            "text": "New Refactorings  Right click on a xaml attribute property that's a  System.Drawing.Color  or a  Xamarin.Forms.Color  and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.  Right click on a xaml attribute property that has a literal value and extract it into a  Binding  expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.  Organise Refactorings:  The  Collapse Xaml Attributes  refactoring will collapse all xaml attributes onto the same line as the parent xaml node.  The  Expand Xaml Attributes  refactoring will expand all xaml attributes onto separate lines.  The  Sort Xaml Attributes  refactoring will sort the attributes for a xaml node by namespace and name.  The  Expand Node  refactoring takes a self-closing xaml node and generate a closing tag for it.  The  Collapse Node  refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.      New Code Generators  Right click on an xaml node that inherits from  Xamarin.Forms.VisualElement  or  Xamarin.Forms.Application  and select  Add Resource Dictionary  to generate a resource dictionary for that element.    New Xaml Analysers  Detect when an  x:Name  code-behind field declaration is empty.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-8/#enhancements", 
            "text": "This release targets Xamarin Studio v6.1.5  The  Implement View Model  refactoring has been moved from the  Refactor  menu to  Generate .  Hover over a xaml attribute property that's a  System.Drawing.Color  or a  Xamarin.Forms.Color  to see the color value inside the tooltip.  The Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the  Help  -   MFractor  -   Install Android SDK Meta-Data  menu item.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-8/#bug-fixes", 
            "text": "Correctly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.  Don't allow the 'Simplify' refactoring to run against expressions.  Fix multiple type conversion checking bugs in the ValueConversion attribute validation.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-7/", 
            "text": "Release Notes - v2.7.0\n\n\n8th January 2017\n\n\nDownload MFractor 2.7.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.7.0 of MFractor for Xamarin Studio.\n\n\nThis release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.\n\n\nI recommend taking a moment to read these tutorials:\n\n\n\n\nImplementing View Models\n: Learn implement entire view models using the \nImplement View Model\n refactoring.\n\n\nValue Converter Type Safety\n: Learn to annotate \nIValueConverter\ns with value conversion attributes for \nConverter\n expression type-safety.\n\n\n\n\nIntroducing View Model Generation\n\n\nYou already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa\n\n\n\n\nGot a heap of unimplemented bindings? Right click anywhere in your Xaml document and select \nRefactor\n -\n \nImplement View Model\n.\n\n\nMFractor will collect all the missing bindings and then generate a new class with \nall\n of those properties into a namespace named \nMyDefaultNamespace.ViewModels\n.\n\n\nDoes the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.\n\n\nI think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b\n\n\nFeatures\n\n\n\n\nBy right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n\n\nImplement view model properties with a getter and setter.\n\n\nImplement view model properties with a backing field.\n\n\nBound properties that return \nICommand\n will have an empty \nXamarin.Forms.Command\n instance generated.\n\n\nWhen MFractor encounters binding expressions that use a \nConverter\n, it inspects the converter for a \nValueConversion\n attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using \nSystem.Object\n.\n\n\nWhen implementing a new view model with getter and setters, MFractor will inspect for references to Fody's \nImplementPropertyChanged\n and annotate the new class with it.\n\n\n\n\n\n\nNew Xaml Analysers:\n\n\nValidate that elements declared inside a resource dictionary have an x:Key.\n\n\nValidate that elements declared inside a resource dictionary have a unique x:Key value.\n\n\nDetect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n\n\nDetect when a property setter node (\nMyClass.MyProperty/\n) references a non-existent member on the parent class.\n\n\nDetect when a property setter attribute is empty.\n\n\nDetect when an undefined static resource is referenced by a \nStaticResource\n expression.\n\n\nDetect when the value returned by a \nStaticResource\n expression causes a type mismatch.\n\n\nDetect when an unknown type is being provided to a \nx:TypeArguments\n attribute.\n\n\nValidate that \nOnIdiom\n elements return the correct type for the outer property setter.\n\n\nValidate that \nOnPlatform\n elements return the correct type for the outer property setter.\n\n\nDetect when a developer has misused a property setter inside another xaml element. For example, \nOnIdiom.Phone\n doesn't make any sense when wrapped by the outer element \nOnPlatform\n.\n\n\nDetect when an incorrect input type is provided to a \nConverter\n. The value converter must have a \nValueConversion\n attribute for this to trigger.\n\n\nDetect when an incorrect output type is returned by a \nConverter\n expression. The value converter must have a \nValueConversion\n attribute for this to trigger.\n\n\nDetect when multiple occurrences of the same automation ID exists within a Xaml document.\n\n\n\n\n\n\nNew Xaml Fixes:\n\n\nGenerate missing resource dictionary keys.\n\n\nAuto-correct misspelt \nStaticResource\n references.\n\n\n\n\n\n\nNew Simplify Refactorings:\n\n\nAttributes that use a static instance to initialize the property (eg \nVerticalOptions=\"LayoutOptions.CentreAndExpand\"\n) can now be simplified to just the instance name (eg \nVerticalOptions=\"CentreAndExpand\"\n).\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Xamarin Studio v6.1.3\n\n\nThe \nAbout MFractor\n dialog now contains a button to copy version and IDE information into the clipboard for bug reports. See \nSupport - Filing A Bug Report\n for more information on filing a bug report.\n\n\nThis release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n\n\nAnnotating value converters with a \nValueConversion(typeof(InputType), typeof(OutputType))\n attribute will trigger the conversion information to render into tooltip. See \nFormsCommunityToolkit.Converters\n for examples.\n\n\n\n\nBug Fixes\n\n\n\n\nSometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n\n\nThe View \n - \n Code Behind navigation shortcuts would break when an AST parse was in progress. View \n - \n Code Behind shortcuts will now always be active.\n\n\nWhen property setter nodes are used (\nMyClass.MyProperty/\n), the class component is now correctly validated.\n\n\nWhen importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n\n\nWhen resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n\n\nMore resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n\n\nSave the project after adding a new file to it.", 
            "title": "v2.7"
        }, 
        {
            "location": "/release-notes/v2-7/#release-notes-v270", 
            "text": "8th January 2017  Download MFractor 2.7.0", 
            "title": "Release Notes - v2.7.0"
        }, 
        {
            "location": "/release-notes/v2-7/#introduction", 
            "text": "This is a summary of the changes introduced in v2.7.0 of MFractor for Xamarin Studio.  This release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.  I recommend taking a moment to read these tutorials:   Implementing View Models : Learn implement entire view models using the  Implement View Model  refactoring.  Value Converter Type Safety : Learn to annotate  IValueConverter s with value conversion attributes for  Converter  expression type-safety.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-7/#introducing-view-model-generation", 
            "text": "You already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa   Got a heap of unimplemented bindings? Right click anywhere in your Xaml document and select  Refactor  -   Implement View Model .  MFractor will collect all the missing bindings and then generate a new class with  all  of those properties into a namespace named  MyDefaultNamespace.ViewModels .  Does the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.  I think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b", 
            "title": "Introducing View Model Generation"
        }, 
        {
            "location": "/release-notes/v2-7/#features", 
            "text": "By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:  Implement view model properties with a getter and setter.  Implement view model properties with a backing field.  Bound properties that return  ICommand  will have an empty  Xamarin.Forms.Command  instance generated.  When MFractor encounters binding expressions that use a  Converter , it inspects the converter for a  ValueConversion  attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using  System.Object .  When implementing a new view model with getter and setters, MFractor will inspect for references to Fody's  ImplementPropertyChanged  and annotate the new class with it.    New Xaml Analysers:  Validate that elements declared inside a resource dictionary have an x:Key.  Validate that elements declared inside a resource dictionary have a unique x:Key value.  Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.  Detect when a property setter node ( MyClass.MyProperty/ ) references a non-existent member on the parent class.  Detect when a property setter attribute is empty.  Detect when an undefined static resource is referenced by a  StaticResource  expression.  Detect when the value returned by a  StaticResource  expression causes a type mismatch.  Detect when an unknown type is being provided to a  x:TypeArguments  attribute.  Validate that  OnIdiom  elements return the correct type for the outer property setter.  Validate that  OnPlatform  elements return the correct type for the outer property setter.  Detect when a developer has misused a property setter inside another xaml element. For example,  OnIdiom.Phone  doesn't make any sense when wrapped by the outer element  OnPlatform .  Detect when an incorrect input type is provided to a  Converter . The value converter must have a  ValueConversion  attribute for this to trigger.  Detect when an incorrect output type is returned by a  Converter  expression. The value converter must have a  ValueConversion  attribute for this to trigger.  Detect when multiple occurrences of the same automation ID exists within a Xaml document.    New Xaml Fixes:  Generate missing resource dictionary keys.  Auto-correct misspelt  StaticResource  references.    New Simplify Refactorings:  Attributes that use a static instance to initialize the property (eg  VerticalOptions=\"LayoutOptions.CentreAndExpand\" ) can now be simplified to just the instance name (eg  VerticalOptions=\"CentreAndExpand\" ).", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-7/#enhancements", 
            "text": "This release targets Xamarin Studio v6.1.3  The  About MFractor  dialog now contains a button to copy version and IDE information into the clipboard for bug reports. See  Support - Filing A Bug Report  for more information on filing a bug report.  This release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.  Annotating value converters with a  ValueConversion(typeof(InputType), typeof(OutputType))  attribute will trigger the conversion information to render into tooltip. See  FormsCommunityToolkit.Converters  for examples.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-7/#bug-fixes", 
            "text": "Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.  The View   -   Code Behind navigation shortcuts would break when an AST parse was in progress. View   -   Code Behind shortcuts will now always be active.  When property setter nodes are used ( MyClass.MyProperty/ ), the class component is now correctly validated.  When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.  When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables  More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.  Save the project after adding a new file to it.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-6/", 
            "text": "Release Notes - v2.6.0\n\n\n31st October 2016\n\n\nDownload MFractor 2.6.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Xamarin Studio.\n\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code.\n\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\n\nEnjoy!\n\n\nFeatures\n\n\n\n\nNew code generation actions:\n\n\nGenerate classes from \nmy_namespace:MyMissingClass\n in xaml.\n\n\nGenerate views from \nmy_namespace:MyMissingView\n in xaml.\n\n\nGenerate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n\n\n\n\n\n\nNew Xaml analysers:\n\n\nFor generics, validate that an x:TypeArguments attribute or xml node setter exists.\n\n\nFor generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n\n\nValidate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Xamarin Studio v6.1.1\n\n\n\n\nBug Fixes\n\n\n\n\nFix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n\n\nAllow importing of xaml namespaces from x:Static symbols.\n\n\nFor Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n\n\nWhen a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n\n\nRemove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.\n\n\nWhen using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": "v2.6"
        }, 
        {
            "location": "/release-notes/v2-6/#release-notes-v260", 
            "text": "31st October 2016  Download MFractor 2.6.0", 
            "title": "Release Notes - v2.6.0"
        }, 
        {
            "location": "/release-notes/v2-6/#introduction", 
            "text": "This is a summary of the changes introduced in v2.6.0 of MFractor for Xamarin Studio.  As a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...  Just right click on that little yellow squiggle and use the fix to generate a whole lotta code.  There are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.  Enjoy!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-6/#features", 
            "text": "New code generation actions:  Generate classes from  my_namespace:MyMissingClass  in xaml.  Generate views from  my_namespace:MyMissingView  in xaml.  Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.    New Xaml analysers:  For generics, validate that an x:TypeArguments attribute or xml node setter exists.  For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.  Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-6/#enhancements", 
            "text": "This release targets Xamarin Studio v6.1.1", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-6/#bug-fixes", 
            "text": "Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.  Allow importing of xaml namespaces from x:Static symbols.  For Setters, don't validate TargetType property that the provided type is a static member of System.Type.  When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.  Remove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.  When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-5/", 
            "text": "Release Notes - v2.5.3\n\n\n10th of October 2016\n\n\nDownload MFractor 2.5.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.5.3 of MFractor for Xamarin Studio.\n\n\nThis release adds support for native view declaration and property generation for missing view attributes.\n\n\nFeatures\n\n\n\n\nGenerate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n\n\nFull support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n\n\n\nBug Fixes\n\n\n\n\nXaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n\n\nThe analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "v2.5"
        }, 
        {
            "location": "/release-notes/v2-5/#release-notes-v253", 
            "text": "10th of October 2016  Download MFractor 2.5.0", 
            "title": "Release Notes - v2.5.3"
        }, 
        {
            "location": "/release-notes/v2-5/#introduction", 
            "text": "This is a summary of the changes introduced in v2.5.3 of MFractor for Xamarin Studio.  This release adds support for native view declaration and property generation for missing view attributes.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-5/#features", 
            "text": "Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.  Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-5/#bug-fixes", 
            "text": "Xaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.  The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "Bug Fixes"
        }
    ]
}