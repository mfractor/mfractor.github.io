## Xamarin.Forms Feature Configuration
*Autogenerated by MFractor v3.5.9*
## Android Custom Renderer Code Snippets

**Configuration Id: com.mfractor.configuration.forms.android_custom_renderers**

Groups the Android specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for Android, this configuration should be changed in the Android project rather than the PCL/Shared Project/netstandard library.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **PageRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the page that this custom renderer is for.</li><li>`control_name`: The name of the page that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.Android;<br/>using Xamarin.Forms;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public (Android.Content.Context context) : base(context)<br/>        {<br/>        }<br/>    }<br/>}</code> | The code snippet to use for customised pages. |
| **LayoutRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the layout that this custom renderer is for.</li><li>`control_name`: The name of the layout that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.Android;<br/>using Xamarin.Forms;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public (Android.Content.Context context) : base(context)<br/>        {<br/>        }<br/>    }<br/>}</code> | The code snippet to use for customised layouts. |
| **ViewRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the control that this custom renderer is for.</li><li>`control_name`: The name of the control that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.Android;<br/>using Xamarin.Forms;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public   => Element as ;<br/><br/>        public (Android.Content.Context context) : base(context)<br/>        {<br/>        }<br/><br/>        protected override void OnElementChanged(ElementChangedEventArgs<> e)<br/>        {<br/>            base.OnElementChanged(e);<br/>        }<br/><br/>        protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)<br/>        {<br/>            base.OnElementPropertyChanged(sender, e);<br/>        }<br/>    }<br/><br/>}<br/></code> | The code snippet to use for customised controls. |
| **CellRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the control that this custom renderer is for.</li><li>`control_name`: The name of the control that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using System;<br/>using System.ComponentModel;<br/>using Android.Content;<br/>using Android.Views;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.Android;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer(typeof(), typeof(.))]<br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public (Android.Content.Context context) : base(context)<br/>        {<br/>        }<br/><br/>        protected override Android.Views.View GetCellCore(Xamarin.Forms.Cell item, Android.Views.View convertView, Android.Views.ViewGroup parent, Android.Content.Context context)<br/>        {<br/>            throw new System.NotImplementedException();<br/>        }<br/>    }<br/>}</code> | The code snippet to use for customised cells in ListViews. |
| **RenderersFolder** | System.String | Renderers | What is the folder path that new renderers should be placed into? |
| **RenderersNamespace** | System.String | .Renderers | What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace. |

## Behaviors Configuration

**Configuration Id: com.mfractor.configuration.forms.behaviors**

Groups all configuration settings related to Xamarin.Forms.Behavior's into a single place.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **BehaviorsFolder** | System.String | Behaviors | The default folder to place new behaviors into. |
| **BehaviorsNamespace** | System.String | .Behaviors | The default names that new behaviors will be placed into. Prepending the namespace with a `.` will cause the namespace to be appended to the projects default namespace. |

## Event To Command Behavior Configuration

**Configuration Id: com.mfractor.configuration.forms.event_to_command_behavior**

Groups all configuration settings and code snippets for the Event to Command code generation feature suite.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **EventToCommandBehaviorSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the event to command behaviour</li><li>`namespace`: The namespace that encapsulates the event to command behaviour</li></ul> | <code>using System;<br/>using System.Reflection;<br/>using System.Windows.Input;<br/>using Xamarin.Forms;<br/><br/>namespace <br/>{<br/>    public class  : BehaviorBase<View><br/>    {<br/>        Delegate eventHandler;<br/><br/>        public static readonly BindableProperty EventNameProperty = BindableProperty.Create (nameof(EventName), typeof(string), typeof(), null, propertyChanged: OnEventNameChanged);<br/>        public static readonly BindableProperty CommandProperty = BindableProperty.Create (nameof(Command), typeof(ICommand), typeof(), null);<br/>        public static readonly BindableProperty CommandParameterProperty = BindableProperty.Create (nameof(CommandParameter), typeof(object), typeof(), null);<br/>        public static readonly BindableProperty InputConverterProperty = BindableProperty.Create (nameof(Converter), typeof(IValueConverter), typeof(), null);<br/><br/>        public string EventName {<br/>            get { return (string)GetValue (EventNameProperty); }<br/>            set { SetValue (EventNameProperty, value); }<br/>        }<br/><br/>        public ICommand Command {<br/>            get { return (ICommand)GetValue (CommandProperty); }<br/>            set { SetValue (CommandProperty, value); }<br/>        }<br/><br/>        public object CommandParameter {<br/>            get { return GetValue (CommandParameterProperty); }<br/>            set { SetValue (CommandParameterProperty, value); }<br/>        }<br/><br/>        public IValueConverter Converter {<br/>            get { return (IValueConverter)GetValue (InputConverterProperty); }<br/>            set { SetValue (InputConverterProperty, value); }<br/>        }<br/><br/>        protected override void OnAttachedTo (View bindable)<br/>        {<br/>            base.OnAttachedTo (bindable);<br/>            RegisterEvent (EventName);<br/>        }<br/><br/>        protected override void OnDetachingFrom (View bindable)<br/>        {<br/>            DeregisterEvent (EventName);<br/>            base.OnDetachingFrom (bindable);<br/>        }<br/><br/>        void RegisterEvent (string name)<br/>        {<br/>            if (string.IsNullOrWhiteSpace (name)) {<br/>                return;<br/>            }<br/><br/>            EventInfo eventInfo = AssociatedObject.GetType ().GetRuntimeEvent (name);<br/>            if (eventInfo == null) {<br/>                throw new ArgumentException (string.Format (": Can't register the '{0}' event.", EventName));<br/>            }<br/>            MethodInfo methodInfo = typeof().GetTypeInfo ().GetDeclaredMethod ("OnEvent");<br/>            eventHandler = methodInfo.CreateDelegate (eventInfo.EventHandlerType, this);<br/>            eventInfo.AddEventHandler (AssociatedObject, eventHandler);<br/>        }<br/><br/>        void DeregisterEvent (string name)<br/>        {<br/>            if (string.IsNullOrWhiteSpace (name)) {<br/>                return;<br/>            }<br/><br/>            if (eventHandler == null) {<br/>                return;<br/>            }<br/>            EventInfo eventInfo = AssociatedObject.GetType ().GetRuntimeEvent (name);<br/>            if (eventInfo == null) {<br/>                throw new ArgumentException (string.Format (": Can't de-register the '{0}' event.", EventName));<br/>            }<br/>            eventInfo.RemoveEventHandler (AssociatedObject, eventHandler);<br/>            eventHandler = null;<br/>        }<br/><br/>        void OnEvent (object sender, object eventArgs)<br/>        {<br/>            if (Command == null) {<br/>                return;<br/>            }<br/><br/>            object resolvedParameter;<br/>            if (CommandParameter != null) {<br/>                resolvedParameter = CommandParameter;<br/>            } else if (Converter != null) {<br/>                resolvedParameter = Converter.Convert (eventArgs, typeof(object), null, null);<br/>            } else {<br/>                resolvedParameter = eventArgs;<br/>            }       <br/><br/>            if (Command.CanExecute (resolvedParameter)) {<br/>                Command.Execute (resolvedParameter);<br/>            }<br/>        }<br/><br/>        static void OnEventNameChanged (BindableObject bindable, object oldValue, object newValue)<br/>        {<br/>            var behavior = ()bindable;<br/>            if (behavior.AssociatedObject == null) {<br/>                return;<br/>            }<br/><br/>            string oldEventName = (string)oldValue;<br/>            string newEventName = (string)newValue;<br/><br/>            behavior.DeregisterEvent (oldEventName);<br/>            behavior.RegisterEvent (newEventName);<br/>        }<br/>    }<br/>}</code> | The code snippet to use for the event to command behavior. |
| **SelectedItemEventArgsToSelectedItemConverterSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the converter.</li><li>`namespace`: The namespace that encapsulates the converter</li></ul> | <code>using System;<br/>using System.Globalization;<br/>using Xamarin.Forms;<br/><br/>namespace <br/>{<br/>    public class  : IValueConverter<br/>    {<br/>        public object Convert (object value, Type targetType, object parameter, CultureInfo culture)<br/>        {<br/>            var eventArgs = value as SelectedItemChangedEventArgs;<br/>            return eventArgs.SelectedItem;<br/>        }<br/><br/>        public object ConvertBack (object value, Type targetType, object parameter, CultureInfo culture)<br/>        {<br/>            throw new NotImplementedException ();<br/>        }<br/>    }<br/>}</code> | The code snippet to use for the `SelectedItemEventArgsToSelectedItemConverter`. |
| **EventToCommandBehaviorName** | System.String | EventToCommandBehavior | The class name of the event to command behavior. |
| **SelectedItemEventArgsToSelectedItemConverterName** | System.String | SelectedItemEventArgsToSelectedItemConverter | The class name of the event to command behavior class. |

## IOS Custom Renderer Code Snippets

**Configuration Id: com.mfractor.configuration.forms.ios_custom_renderers**

Groups the iOS specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for iOS, this configuration should be changed in the iOS project rather than the PCL/Shared Project/netstandard library.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **PageRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the page that this custom renderer is for.</li><li>`control_name`: The name of the page that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.iOS;<br/>using Xamarin.Forms;<br/>using UIKit;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>    }<br/>}</code> | The code snippet to use for customised pages. |
| **LayoutRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the layout that this custom renderer is for.</li><li>`control_name`: The name of the layou that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.iOS;<br/>using Xamarin.Forms;<br/>using UIKit;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>    }<br/>}</code> | The code snippet to use for customised layouts. |
| **ViewRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the control that this custom renderer is for.</li><li>`control_name`: The name of the control that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using Xamarin.Forms.Platform.iOS;<br/>using Xamarin.Forms;<br/>using UIKit;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer (typeof(), typeof(.))]<br/><br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public   => Element as ;<br/><br/>        protected override void OnElementChanged(ElementChangedEventArgs<> e)<br/>        {<br/>            base.OnElementChanged(e);<br/>        }<br/><br/>        protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)<br/>        {<br/>            base.OnElementPropertyChanged(sender, e);<br/>        }<br/>    }<br/>}</code> | The code snippet to use for customised controls. |
| **CellRendererSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`control_type`: The fully qualified type of the control that this custom renderer is for.</li><li>`control_name`: The name of the control that this custom renderer is for.</li><li>`namespace`: The namespace that the custom renderer will be placed into.</li><li>`renderer_name`: The name of the new custom renderer.</li><li>`renderer_control`: The name of the base control type. For example, if your control is `MyCustomLabel` that extends a `Label`, **renderer_control** will be `Label`.</li><li>`base_type`: The fully qualified type of the renderers base type.</li></ul> | <code>using System;<br/>using System.ComponentModel;<br/>using UIKit;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.iOS;<br/><br/>[assembly: Xamarin.Forms.ExportRenderer(typeof(), typeof(.))]<br/>namespace <br/>{<br/>    public class  : <br/>    {<br/>        public override UITableViewCell GetCell(Cell item, UITableViewCell reusableCell, UITableView tv)<br/>        {<br/>            throw new System.NotImplementedException();<br/>        }<br/>    }<br/>}</code> | The code snippet to use for customised cells in ListViews. |
| **RenderersFolder** | System.String | Renderers | What is the folder path that new renderers should be placed into? |
| **RenderersNamespace** | System.String | .Renderers | What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace. |

## MVVM Resolution Settings

**Configuration Id: com.mfractor.configuration.forms.mvvm_resolution**

The MVVM resolution settings can be used to specify the project that your views or view models sit within. If you prefer to separate your views and view models into separate projects, these settings enable MFractor to resolve the MVVM relationship across project boundaries.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **ViewsProjectName** | System.String | <code>null</code> | If the apps XAML views and view models are in separate projects, what is the name of project that contains the XAML views? |
| **ViewModelsProjectName** | System.String | <code>null</code> | If the apps XAML views and view models are in separate projects, what is the name of project that contains the ViewModels? |

## Value Conversion Settings

**Configuration Id: com.mfractor.configuration.forms.value_conversions**

A collection of common settings to use for value converters.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Namespace** | System.String | .Converters | The namespace to place value conversion code inside. When empty, new value conversion code will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace. |
| **Folder** | System.String | Converters | The folder to place value conversion code inside. When empty, new value conversion code will be placed inside the proejcts root folder. |
| **DefaultConverterXmlns** | System.String | converters | The namespace name of the xmlns import statement for the newly created value converter |

