## Xamarin.Forms C# Code Generation
*Autogenerated by MFractor v3.4.6*
## Generate Bindable Property

**Configuration Id: com.mfractor.code_gen.forms.csharp.bindable_property**

Generates a Xamarin.Forms bindable property implementation and a proxy property that calls the `BindableProperty` implementation.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new bindable property.</li><li>`type`: The type of the new bindable property.</li><li>`control_type`: The control type that the new bindable property has been created inside.</li></ul> | <code>public static readonly Xamarin.Forms.BindableProperty Property = Xamarin.Forms.BindableProperty.Create(nameof(), typeof(), typeof(), default());<br/>public  <br/>{<br/>    get<br/>    {<br/>        return ()GetValue(Property);<br/>    }<br/><br/>    set<br/>    {<br/>        SetValue(Property, value);<br/>    }<br/>}</code> | When creating the new bindable property, what is the default code snippet MFractor should use? |

## Generate ICommand Implementation

**Configuration Id: com.mfractor.code_gen.forms.csharp.command_implementation**

Generates a boilerplate implementation of ICommand using an inline Xamarin.Forms.Command.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new command.</li><li>`type`: The fully qualified type of the new command</li></ul> | <code>public System.Windows.Input.ICommand <br/>{<br/>    get<br/>    {<br/>        return new (() =><br/>        {<br/>            throw new System.NotImplementedException();<br/>        });<br/>    }<br/>}</code> | What is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub `Xamarin.Forms.Command` implementation |
| **CommandType** | System.String | Xamarin.Forms.Command | The fully qualified type to use as the command implementation. For example, using `Xamarin.Forms.Command` would cause the new expression to be `new Xamarin.Forms.Command` |

## Generate IValueConverter Implementation

**Configuration Id: com.mfractor.code_gen.forms.csharp.value_converter**

Generates an implementation of a value converter.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **CreateMissingValueConversionAttribute** | Boolean | True | If an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation? |
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new value converter.</li><li>`namespace`: The namespace the new converter will be placed inside.</li><li>`value_conversion_attribute`: The fully qualified type of the value conversion attribute (if available).</li><li>`input_type`: The fully qualified type that the value converter should accept as it's input type. If unavailable, defaults to `System.Object`.</li><li>`output_type`: The fully qualified type that the value converter should accept as it's output type. If unavailable, defaults to `System.Object`.</li><li>`parameter_type`: The fully qualified type that the value converter should accept as it's parameter type. If unavailable, defaults to `System.Object`.</li></ul> | <code>using System;<br/>using System.Globalization;<br/>using Xamarin.Forms;<br/><br/>namespace <br/>{<br/>    [(typeof(), typeof())]<br/>    public class  : IValueConverter<br/>    {<br/>        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)<br/>        {<br/>            if (value is  == false)<br/>            {<br/>                return default();<br/>            }<br/><br/>            var input = ()value;<br/><br/>            // TODO: Put your value conversion logic here.<br/><br/>            return default();<br/>        }<br/><br/>        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)<br/>        {<br/>            throw new NotImplementedException();<br/>        }<br/>    }<br/>}</code> | What is the code snippet to use when generating the value converter class file? |

### Uses:

 * [Generate Value Conversion Attribute](/code-generation/xamarin-forms.md#generate-value-conversion-attribute)
 * [Value Conversion Settings](/configuration/xamarin-forms.md#value-conversion-settings)


## Generate Platform Specific Effect

**Configuration Id: com.mfractor.code_gen.forms.csharp.platform_effect**

Generates a new effect, creating the effect inside the common project as well as linked Android and iOS projects.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **iOSEffectsFolder** | System.String | Effects | What is the folder that iOS platform-specific effects should be placed into? |
| **AndroidEffectsFolder** | System.String | Effects | What is the folder that Android platform-specific effects should be placed into? |
| **EffectsFolder** | System.String | Effects | What is the folder that the effects declaration be placed into? |
| **ResolutionGroupName** | System.String | Effects | What is the name of the resolution group? |
| **iOSEffectSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new effect.</li><li>`group_name`: The resolution group name of the new effect.</li><li>`namespace`: The iOS projects default namespace.</li><li>`platform`: If you wish to shared the platform-specific effect template, this is the name of the effects platform.</li></ul> | <code>using .Effects;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.;<br/><br/>[assembly: ResolutionGroupName("")]<br/>[assembly: ExportEffect(typeof(), "")]<br/>namespace .Effects<br/>{<br/>    public class  : PlatformEffect<br/>    {<br/>        protected override void OnAttached()<br/>        {<br/>            // TODO: Apply your effect.<br/>        }<br/><br/>        protected override void OnDetached()<br/>        {<br/>            // TODO: Remove your effect.<br/>        }<br/>    }<br/>}<br/></code> | What is the code snippet for the iOS platform-specific effect? |
| **AndroidEffectSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new effect.</li><li>`group_name`: The resolution group name of the new effect.</li><li>`namespace`: The Android projects default namespace.</li><li>`platform`: If you wish to shared the platform-specific effect template, this is the name of the effects platform.</li></ul> | <code>using .Effects;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.;<br/><br/>[assembly: ResolutionGroupName("")]<br/>[assembly: ExportEffect(typeof(), "")]<br/>namespace .Effects<br/>{<br/>    public class  : PlatformEffect<br/>    {<br/>        protected override void OnAttached()<br/>        {<br/>            // TODO: Apply your effect.<br/>        }<br/><br/>        protected override void OnDetached()<br/>        {<br/>            // TODO: Remove your effect.<br/>        }<br/>    }<br/>}<br/></code> | What is the code snippet for the Android platform-specific effect? |
| **EffectSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new effect.</li><li>`group_name`: The resolution group name of the new effect.</li><li>`namespace`: The common projects default namespace.</li></ul> | <code><br/>using System;<br/>using Xamarin.Forms;<br/><br/>namespace <br/>{<br/>    public class  : RoutingEffect<br/>    {<br/>        public () : base(".")<br/>        {<br/>        }<br/>    }<br/>}<br/></code> | What is the code snippet for the effect? |

## Generate Value Conversion Attribute

**Configuration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute**

Generates an implementation of the `ValueConversionAttribute`; the attribute used to hint type-flow in a value converter for design time tools like MFractor.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`namespace`: The namespace that the new value conversion attribute should be placed within.</li></ul> | <code>using System;<br/>namespace <br/>{<br/>    /// <summary><br/>    /// When annotated onto an IValueConverter implementation, enables third party tools to analyse the type-flow of binding expressions.<br/>    /// </summary><br/>    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]<br/>    public class ValueConversionAttribute : Attribute<br/>    {<br/>        public ValueConversionAttribute(Type input, Type output)<br/>        {<br/>        }<br/><br/>        public Type ParameterType<br/>        {<br/>            get;<br/>            set;<br/>        }<br/>    }<br/>}</code> | What is the default code snippet to use when creating the value conversion attribute implementation? |

### Uses:

 * [Value Conversion Settings](/configuration/xamarin-forms.md#value-conversion-settings)


## Generate View With XAML and Code-Behind Class

**Configuration Id: com.mfractor.code_gen.forms.xaml_view_with_code_behind**

Creates a new view/control using a XAML to define the UI and a code-behind class to encapsulate backing logic.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **ViewsFolder** | System.String | <code>null</code> | What is the folder that new XAML views be placed into? |
| **CodeBehindSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new class.</li><li>`namespace`: The namespace that the new class resides inside.</li><li>`type`: The base type of the new class.</li></ul> | <code>using System;<br/><br/>namespace <br/>{<br/>    public partial class  : <br/>    {<br/>        public ()<br/>        {<br/>            InitializeComponent();<br/>        }<br/>    }<br/>}</code> | What is the default implementation of the new XAML control's code behind class? |

### Uses:

 * [Using Directive Generator](/code-generation/csharp.md#using-directive-generator)
 * [Namespace Declaration](/code-generation/csharp.md#namespace-declaration)


## String Localisation Generator

**Configuration Id: com.mfractor.code_gen.forms.replace_with_localisation_lookup**

The string localisation generator converts literal string value inside a XAML document to a localised value lookup. This replaces the text with a localistaion lookup extension and generates a resx entry for the old value.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **TranslateExtensionSymbol** | System.String | .il8n.TranslateExtension | What is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using `.Localisation.TranslateExtension` when the default namespace is `MyApp` would cause the full symbol name to become `MyApp.Localisation.TranslateExtension`. |
| **TranslationXamlNamespace** | System.String | i18n | When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used? |

### Uses:

 * [Generate ResX Entry](/code-generation/resx.md#generate-resx-entry)
 * [Default Resource File](/configuration/resx.md#default-resource-file)


## View Model Property Generator

**Configuration Id: com.mfractor.code_gen.forms.csharp.view_model_property**

Generates a property declaration for a Xamarin.Forms ViewModel. By default, this code generator routes to the standard PropertyGenerator. However, specifying a code snippet will cause the code generator to use that instead.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`type`: The fully qualified type of the new property.</li><li>`name`: The name of the new property.</li></ul> | <code>public  <br/>{<br/>    get;<br/>    set;<br/>}</code> | What is the code snippet to use when creating the property declaration? |
| **ValueSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`type`: The fully qualified type of the new property.</li><li>`name`: The name of the new property.</li><li>`value`: The value to assign to the new property.</li></ul> | <code>public  <br/>{<br/>    get;<br/>    set;<br/>} = ;</code> | What is the code snippet to use when creating a property declaration with a default value? |
| **DefaultEnumerableType** | System.String | System.Collections.ObjectModel.ObservableCollection<object> | When the new view model property is an `IEnumerable`, what is the default type that should be used instead of `IEnumerable`? To use the provided `IEnumerable` type, set this to an empty string. |

## XAML Localisation Infrastructure Generation

**Configuration Id: com.mfractor.code_gen.forms.xaml_localisation_infrastructure**

Builds the necessary infrustructure needed for XAML localisation using the best practice outlined in [Localizing Xamarin.Forms Apps with RESX Resource Files](https://developer.xamarin.com/guides/xamarin-forms/advanced/localization/).

This code generator will create the following:

**MyApp.Core**

 - **il8n/TranslateExtension.cs**:
 - *il8n/ILocalize.cs*: The interface that provides the current culture on each platform.

**MyApp.iOS**
 - **Localize.cs**: The iOS implementation of `ILocalize` to provide iOS's current culture.

**MyApp.Android**
 - **Localize.cs**: The Android implementation of `ILocalize` to provide iOS's current culture.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **LocalizationFolder** | System.String | il8n | What is the folder that the translation extension and localizer class should be placed into? |
| **LocalizerName** | System.String | ILocalize | What is the name of the class that provides the culture information for translation extension? |
| **ILocalizeSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`namespace`: The projects namespace</li><li>`name`: The name of the new localizer interface. Defaults to `ILocalize`</li></ul> | <code>using System;<br/>using System.Globalization;<br/><br/>namespace <br/>{<br/>    public interface ILocalize<br/>    {<br/>        CultureInfo GetCurrentCultureInfo();<br/><br/>        void SetLocale();<br/>    }<br/>}</code> | The code snippet to use for the `ILocalize` interface that each platform project should implement. |
| **TranslateExtensionSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`namespace`: The projects namespace</li><li>`name`: The name of the translation extension class. This will be derived from the string localisation generations *TranslateExtensionSymbol* property.</li><li>`resource`: The fully qualified type of the resource file that the translate extension should use when looking for localisation values. This will be provided by the apps default resource file config.</li><li>`localizer`: The name of the localization interface that provides the current culture.</li></ul> | <code>using System;<br/>using System.Globalization;<br/>using System.Reflection;<br/>using System.Resources;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Xaml;<br/><br/>namespace <br/>{<br/>    // You exclude the 'Extension' suffix when using in Xaml markup<br/>    [ContentProperty ("Text")]<br/>    public class  : IMarkupExtension<br/>    {<br/>        readonly CultureInfo ci;<br/>        const string ResourceId = "";<br/><br/>        private static readonly Lazy<ResourceManager> ResMgr = new Lazy<ResourceManager>(()=> new ResourceManager(ResourceId, typeof().GetTypeInfo().Assembly));<br/><br/>        public ()<br/>        {<br/>            if (Device.RuntimePlatform == Device.iOS || Device.RuntimePlatform == Device.Android)<br/>            {<br/>                ci = DependencyService.Get<>().GetCurrentCultureInfo();<br/>            }<br/>        }<br/><br/>        public string Text { get; set; }<br/><br/>        public object ProvideValue (IServiceProvider serviceProvider)<br/>        {<br/>            if (Text == null)<br/>                return "";<br/><br/>            var translation = ResMgr.Value.GetString(Text, ci);<br/><br/>            if (translation == null)<br/>            {<br/>                #if DEBUG<br/>                throw new ArgumentException(<br/>                    String.Format("Key '{0}' was not found in resources '{1}' for culture '{2}'.", Text, ResourceId, ci.Name),<br/>                    "Text");<br/>                #else<br/>                translation = Text; // returns the key, which GETS DISPLAYED TO THE USER<br/>                #endif<br/>            }<br/>            return translation;<br/>        }<br/>    }<br/>}</code> | The code snippet to use for the translation extension. |
| **AndroidLocalizeSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`namespace`: The projects namespace</li><li>`platform`: The platform such as iOS or Android</li><li>`localizer`: The name of the localization interface that provides the current culture.</li></ul> | <code>using System;<br/>using System.Globalization;<br/>using System.Linq;<br/>using System.Threading;<br/>using Java.Util;<br/>using Xamarin.Forms;<br/><br/>[assembly: Dependency(typeof(..Localize))]<br/><br/>namespace  .<br/>{<br/>    public class Localize : <br/>    {<br/>        #region Public Methods<br/><br/>        public CultureInfo GetCurrentCultureInfo()<br/>        {<br/>            var androidLocale = Locale.Default;<br/><br/>            var language = androidLocale.ToString().Replace("_", "-");<br/><br/>            var cultures = CultureInfo.GetCultures(CultureTypes.AllCultures);<br/>            if (!cultures.Any(c => c.Name == language))<br/>            {<br/>                language = "en";<br/>            }<br/><br/>            return new CultureInfo(language);<br/>        }<br/><br/>        public void SetLocale()<br/>        {<br/>            var culture = GetCurrentCultureInfo();<br/><br/>            Thread.CurrentThread.CurrentCulture = culture;<br/>            Thread.CurrentThread.CurrentUICulture = culture;<br/>        }<br/><br/>        #endregion<br/>    }<br/>}<br/></code> | The code snippet to use for the Android implementation of the localization interface to provide the current culture. |
| **iOSLocalizeSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`namespace`: The projects namespace</li><li>`platform`: The platform such as iOS or Android</li><li>`localizer`: The name of the localization interface that provides the current culture.</li></ul> | <code>using System;<br/>using System.Globalization;<br/>using System.Threading;<br/>using Foundation;<br/>using Xamarin.Forms;<br/><br/>[assembly: Dependency(typeof(..Localize))]<br/><br/>namespace .<br/>{<br/>    public class Localize : <br/>    {<br/>        public CultureInfo GetCurrentCultureInfo()<br/>        {<br/>            var netLanguage = "en";<br/>            var prefLanguageOnly = "en";<br/>            if (NSLocale.PreferredLanguages.Length > 0)<br/>            {<br/>                var pref = NSLocale.PreferredLanguages[0];<br/><br/>                // HACK: Apple treats portuguese fallbacks in a strange way<br/>                // https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/LocalizingYourApp/LocalizingYourApp.html<br/>                // "For example, use pt as the language ID for Portuguese as it is used in Brazil and pt-PT as the language ID for Portuguese as it is used in Portugal"<br/>                prefLanguageOnly = pref.Substring(0, 2);<br/>                if (prefLanguageOnly == "pt")<br/>                    if (pref == "pt")<br/>                        pref =<br/>                            "pt-BR"; // get the correct Brazilian language strings from the PCL RESX (note the local iOS folder is still "pt")<br/>                    else<br/>                        pref = "pt-PT"; // Portugal<br/>                netLanguage = pref.Replace("_", "-");<br/>            }<br/><br/>            // this gets called a lot - try/catch can be expensive so consider caching or something<br/>            CultureInfo ci = null;<br/>            try<br/>            {<br/>                ci = new CultureInfo(netLanguage);<br/>            }<br/>            catch<br/>            {<br/>                // iOS locale not valid .NET culture (eg. "en-ES" : English in Spain)<br/>                // fallback to first characters, in this case "en"<br/>                ci = new CultureInfo(prefLanguageOnly);<br/>            }<br/><br/>            return ci;<br/>        }<br/><br/>        public void SetLocale()<br/>        {<br/>            var iosLocaleAuto = NSLocale.AutoUpdatingCurrentLocale.LocaleIdentifier;<br/>            var netLocale = iosLocaleAuto.Replace("_", "-");<br/>            CultureInfo ci;<br/>            try<br/>            {<br/>                ci = new CultureInfo(netLocale);<br/>            }<br/>            catch<br/>            {<br/>                ci = GetCurrentCultureInfo();<br/>            }<br/>            Thread.CurrentThread.CurrentCulture = ci;<br/>            Thread.CurrentThread.CurrentUICulture = ci;<br/>        }<br/>    }<br/>}</code> | The code snippet to use for the iOS implementation of the localization interface to provide the current culture. |

### Uses:

 * [String Localisation Generator](/code-generation/xamarin-forms.md#string-localisation-generator)
 * [Default Resource File](/configuration/resx.md#default-resource-file)
 * [Generate ResX File](/code-generation/resx.md#generate-resx-file)


