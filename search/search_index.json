{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to the documentation for MFractor, a powerful productivity tool for Xamarin developers. MFractor is available for the Visual Studio Windows and Visual Studio Mac. Feature Matrix Check out the MFractor Feature Matrix for a list of all the featuers available to the product and to what editions and platforms it's available. Getting Started To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac Licensing MFractor's licensing levels and end user license can be found in our Licensing article. MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. Help And Support To get help using MFractor, please see our Support article. Release Notes MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Home"},{"location":"#welcome","text":"Welcome to the documentation for MFractor, a powerful productivity tool for Xamarin developers. MFractor is available for the Visual Studio Windows and Visual Studio Mac.","title":"Welcome"},{"location":"#feature-matrix","text":"Check out the MFractor Feature Matrix for a list of all the featuers available to the product and to what editions and platforms it's available.","title":"Feature Matrix"},{"location":"#getting-started","text":"To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac","title":"Getting Started"},{"location":"#licensing","text":"MFractor's licensing levels and end user license can be found in our Licensing article.","title":"Licensing"},{"location":"#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy .","title":"MFractor Professional"},{"location":"#mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day.","title":"MFractor Lite"},{"location":"#help-and-support","text":"To get help using MFractor, please see our Support article.","title":"Help And Support"},{"location":"#release-notes","text":"MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Release Notes"},{"location":"code-actions/","text":"Enhance your developer productivity with contextual refactorings, code generation and utilities Introduction Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code. Using the Code Actions MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documentation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied. Code Actions for C# Code The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu: Code Actions for XAML Code The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to reference it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action.","title":"Code Actions"},{"location":"code-actions/#introduction","text":"Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code.","title":"Introduction"},{"location":"code-actions/#using-the-code-actions","text":"MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documentation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied.","title":"Using the Code Actions"},{"location":"code-actions/#code-actions-for-c-code","text":"The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu:","title":"Code Actions for C# Code"},{"location":"code-actions/#code-actions-for-xaml-code","text":"The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to reference it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action.","title":"Code Actions for XAML Code"},{"location":"contributing/","text":"Help us enhance and fix MFractor docs so everyone can get the most of this tool. Introduction The MFractor Documentation site is an open source project created and maintained by MFractor. Our goal is to provide rich documentation and reference to our users and customers so they can get the most of the tool. The docs is not only about the tool features itself, but we always try to bring knowledge on development platforms that MFractor assists. Mission Our readers must learn something new beyond the product feature they're searching information itself and enrich their knowledge of the platforms that our tool assists. Documenting a product is critical and hard to do right and keep up to date. The MFractor team is very small and strive to keep up with the ever changing product features. Community contribution is very desired and welcome to achieve the goal of having this site not only as a source of information for MFractor but also as an important knowledge base for developers. Contribution Workflow Contributing to MFractor Documentation is much like any Git hosted open source project: Pick an issue you wish to contribute and comment on Fork the project repository at GitHub Make your changes to your forked repository Open a Pull Request to merge your changes to the main repo If your changes are accepted we'll merge it and notify you about it. We may ask you for additional changes or reply with suggestions through comments on the Pull Request. In case we add suggestions to your Pull Request we will provide a 3 day time-frame for you to review before merging your changes. We may decide to apply the suggestions internally after the merge. This is the high level diagram of the Contribution Workflow: Important All the work to this repository is tracked through issues. We can't track forks to know about ongoing contributions to the project, so please keep your comments on the issues you may be working on so we can manage conflicts. If you've found a problem or a missing documentation that is not listed on the issues, please open one before starting your work. Info We may change parts of your contribution to fix typos, correct data or add missing information. This will be done without notice. Accepted contributions will be acknowledge on a specific section of the home page. Don't add the acknowledgements to your Pull Requests , otherwise they will be rejected. Citations will be only handled internally by our moderation team. Requirements This documentation is written using mkdocs , a popular platform for software documentation sites, and takes advantage of the mkdocs-material a plugin that adds material design concepts and themes to the site. To contribute you can use the mkdocs-material docker image (preferred) or will need to install a few things: Install Python . Install pip . Depending on your terminal shell, configure PATH to point to pips binary folder: For zsh , create the file ~\\.zshrc with the contents: export PATH=\"$PATH:/Users/matthewrobbins/Library/Python/2.7/bin\" For bash , create the file ~\\.bash_profile with the contents: export PATH=\"$PATH:/Users/matthewrobbins/Library/Python/2.7/bin\" Install mkdocs from the pip tool pip install mkdocs . Install the [Material Theme for mkdocs] from pip install mkdocs-material * Important Make sure to install mkdocs and the material theme both using pip . If you install mkdocs from Homebrew and them install the material theme from pip (the only place where its available as a package) you will get errors trying to compile the docs or running it locally. Local installation is error prone. Consider using the docker image for faster and simpler setup. The script file dsrv at the root of the repository ( docs branch) will try to download the correct image and run the local server. Note The publish.sh and dpub scripts are intended for publishing are only used internally. Trying to use them without the required permissions will fail. Extensions admonition and codehilite are part of the material theme. The tabbed and superfences extensions are part of the PyMdown Extensions that are bundled with material theme. markdown_extensions: - attr_list - admonition - codehilite - pymdownx.tabbed - pymdownx.superfences Troubleshooting If the Material Theme isn't installed when you try to run the project it won't work and you'll get the following error: mkdocs serve INFO - Building documentation... ERROR - Config value: 'theme'. Error: Unrecognised theme name: 'material'. The available installed themes are: readthedocs, mkdocs Make sure to install mkdocs and material theme from pip . Get in touch If you need further assistance on contribution please refer to Matthew Robins or Rafael Veronezi or open an issue. We'll be glad to assist.","title":"Contributing"},{"location":"contributing/#introduction","text":"The MFractor Documentation site is an open source project created and maintained by MFractor. Our goal is to provide rich documentation and reference to our users and customers so they can get the most of the tool. The docs is not only about the tool features itself, but we always try to bring knowledge on development platforms that MFractor assists. Mission Our readers must learn something new beyond the product feature they're searching information itself and enrich their knowledge of the platforms that our tool assists. Documenting a product is critical and hard to do right and keep up to date. The MFractor team is very small and strive to keep up with the ever changing product features. Community contribution is very desired and welcome to achieve the goal of having this site not only as a source of information for MFractor but also as an important knowledge base for developers.","title":"Introduction"},{"location":"contributing/#contribution-workflow","text":"Contributing to MFractor Documentation is much like any Git hosted open source project: Pick an issue you wish to contribute and comment on Fork the project repository at GitHub Make your changes to your forked repository Open a Pull Request to merge your changes to the main repo If your changes are accepted we'll merge it and notify you about it. We may ask you for additional changes or reply with suggestions through comments on the Pull Request. In case we add suggestions to your Pull Request we will provide a 3 day time-frame for you to review before merging your changes. We may decide to apply the suggestions internally after the merge. This is the high level diagram of the Contribution Workflow: Important All the work to this repository is tracked through issues. We can't track forks to know about ongoing contributions to the project, so please keep your comments on the issues you may be working on so we can manage conflicts. If you've found a problem or a missing documentation that is not listed on the issues, please open one before starting your work. Info We may change parts of your contribution to fix typos, correct data or add missing information. This will be done without notice. Accepted contributions will be acknowledge on a specific section of the home page. Don't add the acknowledgements to your Pull Requests , otherwise they will be rejected. Citations will be only handled internally by our moderation team.","title":"Contribution Workflow"},{"location":"contributing/#requirements","text":"This documentation is written using mkdocs , a popular platform for software documentation sites, and takes advantage of the mkdocs-material a plugin that adds material design concepts and themes to the site. To contribute you can use the mkdocs-material docker image (preferred) or will need to install a few things: Install Python . Install pip . Depending on your terminal shell, configure PATH to point to pips binary folder: For zsh , create the file ~\\.zshrc with the contents: export PATH=\"$PATH:/Users/matthewrobbins/Library/Python/2.7/bin\" For bash , create the file ~\\.bash_profile with the contents: export PATH=\"$PATH:/Users/matthewrobbins/Library/Python/2.7/bin\" Install mkdocs from the pip tool pip install mkdocs . Install the [Material Theme for mkdocs] from pip install mkdocs-material * Important Make sure to install mkdocs and the material theme both using pip . If you install mkdocs from Homebrew and them install the material theme from pip (the only place where its available as a package) you will get errors trying to compile the docs or running it locally. Local installation is error prone. Consider using the docker image for faster and simpler setup. The script file dsrv at the root of the repository ( docs branch) will try to download the correct image and run the local server. Note The publish.sh and dpub scripts are intended for publishing are only used internally. Trying to use them without the required permissions will fail.","title":"Requirements"},{"location":"contributing/#extensions","text":"admonition and codehilite are part of the material theme. The tabbed and superfences extensions are part of the PyMdown Extensions that are bundled with material theme. markdown_extensions: - attr_list - admonition - codehilite - pymdownx.tabbed - pymdownx.superfences","title":"Extensions"},{"location":"contributing/#troubleshooting","text":"If the Material Theme isn't installed when you try to run the project it won't work and you'll get the following error: mkdocs serve INFO - Building documentation... ERROR - Config value: 'theme'. Error: Unrecognised theme name: 'material'. The available installed themes are: readthedocs, mkdocs Make sure to install mkdocs and material theme from pip .","title":"Troubleshooting"},{"location":"contributing/#get-in-touch","text":"If you need further assistance on contribution please refer to Matthew Robins or Rafael Veronezi or open an issue. We'll be glad to assist.","title":"Get in touch"},{"location":"faq/","text":"Answers to commonly asked questions Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. Where do I find the latest version of MFractor? Visual Studio Macs The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300 Visual Studio Windows The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS What version of Visual Studio does MFractor support? Visual Studio Mac MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release. Visual Studio Window MFractor for Visual Studio Windows supports Visual Studio 2019 and higher. How do I get a refund? Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d Do you offer company licenses? Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing. I require an invoice or quote to purchase MFractor, can you provide one? Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order. How do I report a bug? To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug. I've got a great feature idea, how do I request it? Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality. I'd like to try MFractor Professional, how do I get a trial? To request an MFractor Professional trial, please email matthew@mfractor.com. How do I recover my MFractor Professional license? To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license. Where can I find MFracor's release notes? MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes Does MFractor support the Preview versions of Visual Studio? No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk. MFractor is not visible in Visual Studio Macs Extension Manager. MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ; I'd like to write a blog about MFractor. Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding. What is the .mfractor folder? The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it. Should I check .mfractor into source control? No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default. How do I uninstall MFractor for Visual Studio Windows manually? Locate the VSIXInstaller executable and run the following command: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE>VSIXInstaller.exe /u:9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c Our VSIX identifier is 9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c . Can you help me make a Visual Studio extension? Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call. Are you available for hire to develop Xamarin applications? Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with. Are you available for hire to develop Visual Studio extension? Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor. What is the licensing agreement? Please see our End User License . What is your privacy policy? Please see our Privacy Policy .","title":"FAQ"},{"location":"faq/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"faq/#where-do-i-find-the-latest-version-of-mfractor","text":"","title":"Where do I find the latest version of MFractor?"},{"location":"faq/#visual-studio-macs","text":"The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300","title":"Visual Studio Macs"},{"location":"faq/#visual-studio-windows","text":"The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS","title":"Visual Studio Windows"},{"location":"faq/#what-version-of-visual-studio-does-mfractor-support","text":"","title":"What version of Visual Studio does MFractor support?"},{"location":"faq/#visual-studio-mac","text":"MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release.","title":"Visual Studio Mac"},{"location":"faq/#visual-studio-window","text":"MFractor for Visual Studio Windows supports Visual Studio 2019 and higher.","title":"Visual Studio Window"},{"location":"faq/#how-do-i-get-a-refund","text":"Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d","title":"How do I get a refund?"},{"location":"faq/#do-you-offer-company-licenses","text":"Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing.","title":"Do you offer company licenses?"},{"location":"faq/#i-require-an-invoice-or-quote-to-purchase-mfractor-can-you-provide-one","text":"Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order.","title":"I require an invoice or quote to purchase MFractor, can you provide one?"},{"location":"faq/#how-do-i-report-a-bug","text":"To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug.","title":"How do I report a bug?"},{"location":"faq/#ive-got-a-great-feature-idea-how-do-i-request-it","text":"Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality.","title":"I've got a great feature idea, how do I request it?"},{"location":"faq/#id-like-to-try-mfractor-professional-how-do-i-get-a-trial","text":"To request an MFractor Professional trial, please email matthew@mfractor.com.","title":"I'd like to try MFractor Professional, how do I get a trial?"},{"location":"faq/#how-do-i-recover-my-mfractor-professional-license","text":"To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license.","title":"How do I recover my MFractor Professional license?"},{"location":"faq/#where-can-i-find-mfracors-release-notes","text":"MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes","title":"Where can I find MFracor's release notes?"},{"location":"faq/#does-mfractor-support-the-preview-versions-of-visual-studio","text":"No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk.","title":"Does MFractor support the Preview versions of Visual Studio?"},{"location":"faq/#mfractor-is-not-visible-in-visual-studio-macs-extension-manager","text":"MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ;","title":"MFractor is not visible in Visual Studio Macs Extension Manager."},{"location":"faq/#id-like-to-write-a-blog-about-mfractor","text":"Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding.","title":"I'd like to write a blog about MFractor."},{"location":"faq/#what-is-the-mfractor-folder","text":"The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it.","title":"What is the .mfractor folder?"},{"location":"faq/#should-i-check-mfractor-into-source-control","text":"No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default.","title":"Should I check .mfractor into source control?"},{"location":"faq/#how-do-i-uninstall-mfractor-for-visual-studio-windows-manually","text":"Locate the VSIXInstaller executable and run the following command: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE>VSIXInstaller.exe /u:9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c Our VSIX identifier is 9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c .","title":"How do I uninstall MFractor for Visual Studio Windows manually?"},{"location":"faq/#can-you-help-me-make-a-visual-studio-extension","text":"Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call.","title":"Can you help me make a Visual Studio extension?"},{"location":"faq/#are-you-available-for-hire-to-develop-xamarin-applications","text":"Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with.","title":"Are you available for hire to develop Xamarin applications?"},{"location":"faq/#are-you-available-for-hire-to-develop-visual-studio-extension","text":"Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor.","title":"Are you available for hire to develop Visual Studio extension?"},{"location":"faq/#what-is-the-licensing-agreement","text":"Please see our End User License .","title":"What is the licensing agreement?"},{"location":"faq/#what-is-your-privacy-policy","text":"Please see our Privacy Policy .","title":"What is your privacy policy?"},{"location":"feature-matrix/","text":"An overview of all features provided by MFractor Last Updated: Friday 7th of August 2020 This feature matrix presents all the features provided by MFractor. All features are available in MFractor for Visual Studio for Mac. The third column shows the features available to the Windows version. MFractor currently provides 247 features. We have currently documented 56% of the product features. Asset Management Image Management Feature Lite Pro Platforms Import Image Assets Manage Image Assets Delete Image Tool Optimise Image Tools Image Tooltips Mobile.BuildTools Support ResizetizerNT Support Font Management Feature Lite Pro Platforms Import Font Generate Font Glyph Code Class Font Glyph Tooltips Font Glyph IntelliSense Font Viewer Font Text Preview Tooltips Embedded Font Tooltip Wizards Xamarin.Forms Feature Lite Pro Platforms Localization Wizard MVVM Wizard Value Converter Wizard C# Wizards Feature Lite Pro Platforms Create Class From Clipboard Code Actions C# Language Code Actions Feature Lite Pro Platforms Generate Interface Implementation Simplify Qualified Types Locate in Solution Explorer Convert to Interpolated String Create constructor to initialize all readonly members Create Lazy Accessor Select String Span Align Namespace To Folder Path Copy Var Type To Clipboard Simplify Qualified Type Simplify All Qualified Types Invert Event Handler Assignment Convert To Is Null Xamarin Code Actions Feature Lite Pro Platforms Exclude Symbol from Linker Xamarin.Forms Code Actions Feature Lite Pro Platforms Create Bindable Property Create Attached Property Generate Custom Renderers Xaml Editor Code Actions Feature Lite Pro Platforms Extract XAML Style Extract Custom Control Convert StackLayout to Grid Generate Resource Dictionary Generate New Value Converter for Type Flow Encapsulate Content Page Children With StackLayout Encapsulate Content Page Children With Grid Encapsulate Content View Children With StackLayout Encapsulate Content View Children With Grid Correct Member Name Create Missing Property For Class Fixs Malformed Color Using Color Editor Replace Color Value With StaticResource Replace Hexadecimal Value With Named Color Generate Event Handler Correct Name To Matching Callback Remove Redundant Grid Properties Autocorrect Invalid FontSize Correct Property Binding Name Import Value Converter For Binding Type Flow Correct Image Resource name Import Missing Image Resource Encapsulate Scroll View Children With Grid Encapsulate Scroll View Children With StackLayout Correct Static Resource Name Apply Available Style Remove Redundant Style Property Initialisation Replace Style Setter Property With Autocorrection Add Missing Target Type Attribute Replace Thickness Value With Static Resource Simplify Thickness Value Add Trigger Target Type Fix Trigger Target Type Import Namespace And Assembly For Unresolved XAML Node Replace Node With Auto-Correction Rename Duplicate Namespace References Move Grid Properties To Parent Element Create Missing Style Consolidate Thicknesses Escape Newline Characters Auto-Correct Embedded Font Reference Move Property To Parent Element Migrate Icon To IconImageSource Insert Grid Row Insert Grid Column Delete Grid Row Delete Grid Column View All Duplicate Thickness Usages Convert Grid Row/Columns To Attribute Format Convert Grid Row/Columns To Node Format Add Transparency Channel To Color Convert Named Color To Hex Edit Color Using Color Editor Set Font Build Action To Embedded Resource Intellisense Feature Lite Pro Platforms x:Name Shorthand Completion x:Key Shorthand Completion Color Value Completion DataBinding Shorthand Completion DataTrigger Binding Shorthand Completion Event Handler Completion Font Asset Completion Grid Boilerplate Completion Grid Location Completion Grid Unit Completion Image Asset Completion Import Font Asset Completion Property Setter Completion RepeaterView Boilerplate Completion Row/Column Shorthand Completion Setter Shorthand Completion StackLayout Orientation Shorthand Completion Star/Auto Shorthand Completion Thickness Attribute Completion ViewModel Data Binding Completion Embedded Font Asset Completion Adornments Feature Lite Pro Platforms Grid Index Adornments Color Adornments Escaped Characters Adornments Tooltips Feature Lite Pro Platforms Grid Index Tooltips Color Format Tooltips Named FontSize Platform Values Tooltips Thickness Formats Tooltips Static Resource Tooltips Value Converter Input/Output Type Tootips SVG Tooltips Localisation Tooltips XAML Code Analysis Feature Lite Pro Platforms CollectionView Requires IsGrouped Xamarin.Forms Navigation Feature Lite Pro Platforms Go To View Model Go To Code Behind Go To Xaml View Go To Xaml Symbol Search and Navigation Feature Lite Pro Platforms Find Custom Renderers Code Analysis XAML Code Analysis Feature Lite Pro Platforms Duplicate AutomationIds Empty AutomationId Declaration x:Name Has Invalid Characters Duplicate Code Behind Field Declarations Empty Code Behind Field Declaration ContentPage Has Multiple Direct Children ContentView Has Multiple Direct Children Class Does Not Have Attached Property Empty Value Assignment Empty Event Handler Assignment Verify Event Handler Exists In Code Behind Class Event Handler Signature Mismatch Verify Referenced Code Behind Field Exists Value Converter Input Type Mismatch Value Converter Output Type Mismatch Unresolved .NET Symbols Within Xaml Expression Unresolved Namespace Within Xaml Expression Invalid Named Font Size Generic Usage Is Missing x:TypeArguments x:TypeArguments Used On Non-Generic Class Unknown Type Provided To Generic Column Is Outside Grid Boundaries ColumnSpan Is Outside Grid Boundaries ColumnSpan Is Zero Grid.Column Usage Is Redundant Grid.ColumnSpan Usage Is Redundant Grid.Row Usage Is Redundant Grid.RowSpan Usage Is Redundant Row Is Outside Grid Boundaries RowSpan Is Outside Grid Boundaries RowSpan Is Zero Obsolete Property Used OnIdiom Return Type Mismatch OnPlatform Return Type Mismatch Referenced Attribute Member Exists In Parent Type Property Node Maps To Member In Parent Type Property Setter Node Misuse Property Setter Type Mismatch Duplicate Resource Dictionary Keys Resource Entry Does Not Define Key Missing Microsoft Schema ScrollView Has Multiple Direct Children Style Is Missing TargetType Property Setter Does Not Exist In Style TargetType Invalid Thickness Attribute Value Unknown Field Modifier Unknown Static Property Value Validate Value Types Duplicate Namespace Declaration Unresolved Xml Namespace Unresolved Xmlns Assembly Xaml Node Resolves Trigger Is Missing Target Type Trigger TargetType Does Not Match Parent Thickness Value Can Be Replaced By Static Resource Thickness Value Can Be Simplified Element Can Use Available Style Property Value Is Already Applied By Style Style TargetType Does Not Match BasedOn TargetType Ambiguous Static Resource Reference No Key Provided To Static Resource Expression StaticResource Return Type Mismatch Static Resource Style Target Type Is Incompatible x:Static Return Type Mismatch Undefined Static Resource Usage Slider Minimum Set Before Maximum Duplicate ShellItem Route Empty Shell Route Scheme Multiple VisualElements Defined In Shell Content Shell Requires At Least One Shell Item Validate Setter Attached Property Usage Setter Property Exists Style Or Trigger Has Duplicate Setters Resource Key Conflict Detect Missing Image In Linked Projects Grid Row/Column Setter Is Not A Number No Key Provided To DynamicResource Expression Validate Binding Expressions Return A Property Binding Against Non-Public Property Binding Expressions Resolve Binding Expression Return Type Mismatch Color Value Matches Static Resource Color Value Closely Matches Available Static Resource Hexadecimal Value Matches Named Color Malformed Hexadecimal Color Value Cell Usage Within CollectionView ItemTemplate Glyph Does Not Exist In Font Thickness Value Can Be Consolidated Color Value Can Be Consolidated Unescaped Newline In String Literal Unknown Embedded Font Reference Unknown OnPlatform Value RefreshView Content Should Be Scrollable Layout Font Reference Is Not Embedded Resource Scaffolding General Feature Lite Pro Platforms Scaffolder Overview Android Utilities Feature Lite Pro Platforms Copy Android Package ID To Clipboard Open Android Manifest Utilities Project and Solution Utilities Feature Lite Pro Platforms Copy Resource Id To Clipboard Delete Output Folder Clean and Compress Edit Shared Project Items Search Categories Feature Lite Pro Platforms MFractor Commands Search ResX Localisation Search Xamarin.Forms Automation Identifiers Search Xamarin.Forms Static Resources Search Xamarin.Forms Dynamic Resources Search Web Navigation Feature Lite Pro Platforms Go To Razor File Go To Razor Code Behind Go To View Model Scaffolding Feature Lite Pro Platforms Razor Page Scaffolder Razor Component Scaffolder ASP.NET Controller Scaffolder General Miscellaneous Scaffolding Feature Lite Pro Platforms FodyWeavers Scaffolder C# Scaffolding Feature Lite Pro Platforms C# Class Scaffolder C# Contextual Base Class Scaffolder Interface Scaffolder Attribute Scaffolder EventArgs Scaffolder iOS Utilities Feature Lite Pro Platforms Copy Bundle ID C# Editor Tooltips Feature Lite Pro Platforms DateTime Format Preview Tooltips","title":"Feature Matrix"},{"location":"feature-matrix/#asset-management","text":"","title":"Asset Management"},{"location":"feature-matrix/#image-management","text":"Feature Lite Pro Platforms Import Image Assets Manage Image Assets Delete Image Tool Optimise Image Tools Image Tooltips Mobile.BuildTools Support ResizetizerNT Support","title":"Image Management"},{"location":"feature-matrix/#font-management","text":"Feature Lite Pro Platforms Import Font Generate Font Glyph Code Class Font Glyph Tooltips Font Glyph IntelliSense Font Viewer Font Text Preview Tooltips Embedded Font Tooltip","title":"Font Management"},{"location":"feature-matrix/#wizards","text":"","title":"Wizards"},{"location":"feature-matrix/#xamarinforms","text":"Feature Lite Pro Platforms Localization Wizard MVVM Wizard Value Converter Wizard","title":"Xamarin.Forms"},{"location":"feature-matrix/#c-wizards","text":"Feature Lite Pro Platforms Create Class From Clipboard","title":"C# Wizards"},{"location":"feature-matrix/#code-actions","text":"","title":"Code Actions"},{"location":"feature-matrix/#c-language-code-actions","text":"Feature Lite Pro Platforms Generate Interface Implementation Simplify Qualified Types Locate in Solution Explorer Convert to Interpolated String Create constructor to initialize all readonly members Create Lazy Accessor Select String Span Align Namespace To Folder Path Copy Var Type To Clipboard Simplify Qualified Type Simplify All Qualified Types Invert Event Handler Assignment Convert To Is Null","title":"C# Language Code Actions"},{"location":"feature-matrix/#xamarin-code-actions","text":"Feature Lite Pro Platforms Exclude Symbol from Linker","title":"Xamarin Code Actions"},{"location":"feature-matrix/#xamarinforms-code-actions","text":"Feature Lite Pro Platforms Create Bindable Property Create Attached Property Generate Custom Renderers","title":"Xamarin.Forms Code Actions"},{"location":"feature-matrix/#xaml-editor","text":"","title":"Xaml Editor"},{"location":"feature-matrix/#code-actions_1","text":"Feature Lite Pro Platforms Extract XAML Style Extract Custom Control Convert StackLayout to Grid Generate Resource Dictionary Generate New Value Converter for Type Flow Encapsulate Content Page Children With StackLayout Encapsulate Content Page Children With Grid Encapsulate Content View Children With StackLayout Encapsulate Content View Children With Grid Correct Member Name Create Missing Property For Class Fixs Malformed Color Using Color Editor Replace Color Value With StaticResource Replace Hexadecimal Value With Named Color Generate Event Handler Correct Name To Matching Callback Remove Redundant Grid Properties Autocorrect Invalid FontSize Correct Property Binding Name Import Value Converter For Binding Type Flow Correct Image Resource name Import Missing Image Resource Encapsulate Scroll View Children With Grid Encapsulate Scroll View Children With StackLayout Correct Static Resource Name Apply Available Style Remove Redundant Style Property Initialisation Replace Style Setter Property With Autocorrection Add Missing Target Type Attribute Replace Thickness Value With Static Resource Simplify Thickness Value Add Trigger Target Type Fix Trigger Target Type Import Namespace And Assembly For Unresolved XAML Node Replace Node With Auto-Correction Rename Duplicate Namespace References Move Grid Properties To Parent Element Create Missing Style Consolidate Thicknesses Escape Newline Characters Auto-Correct Embedded Font Reference Move Property To Parent Element Migrate Icon To IconImageSource Insert Grid Row Insert Grid Column Delete Grid Row Delete Grid Column View All Duplicate Thickness Usages Convert Grid Row/Columns To Attribute Format Convert Grid Row/Columns To Node Format Add Transparency Channel To Color Convert Named Color To Hex Edit Color Using Color Editor Set Font Build Action To Embedded Resource","title":"Code Actions"},{"location":"feature-matrix/#intellisense","text":"Feature Lite Pro Platforms x:Name Shorthand Completion x:Key Shorthand Completion Color Value Completion DataBinding Shorthand Completion DataTrigger Binding Shorthand Completion Event Handler Completion Font Asset Completion Grid Boilerplate Completion Grid Location Completion Grid Unit Completion Image Asset Completion Import Font Asset Completion Property Setter Completion RepeaterView Boilerplate Completion Row/Column Shorthand Completion Setter Shorthand Completion StackLayout Orientation Shorthand Completion Star/Auto Shorthand Completion Thickness Attribute Completion ViewModel Data Binding Completion Embedded Font Asset Completion","title":"Intellisense"},{"location":"feature-matrix/#adornments","text":"Feature Lite Pro Platforms Grid Index Adornments Color Adornments Escaped Characters Adornments","title":"Adornments"},{"location":"feature-matrix/#tooltips","text":"Feature Lite Pro Platforms Grid Index Tooltips Color Format Tooltips Named FontSize Platform Values Tooltips Thickness Formats Tooltips Static Resource Tooltips Value Converter Input/Output Type Tootips SVG Tooltips Localisation Tooltips","title":"Tooltips"},{"location":"feature-matrix/#xaml-code-analysis","text":"Feature Lite Pro Platforms CollectionView Requires IsGrouped","title":"XAML Code Analysis"},{"location":"feature-matrix/#xamarinforms_1","text":"","title":"Xamarin.Forms"},{"location":"feature-matrix/#navigation","text":"Feature Lite Pro Platforms Go To View Model Go To Code Behind Go To Xaml View Go To Xaml Symbol","title":"Navigation"},{"location":"feature-matrix/#search-and-navigation","text":"Feature Lite Pro Platforms Find Custom Renderers","title":"Search and Navigation"},{"location":"feature-matrix/#code-analysis","text":"","title":"Code Analysis"},{"location":"feature-matrix/#xaml-code-analysis_1","text":"Feature Lite Pro Platforms Duplicate AutomationIds Empty AutomationId Declaration x:Name Has Invalid Characters Duplicate Code Behind Field Declarations Empty Code Behind Field Declaration ContentPage Has Multiple Direct Children ContentView Has Multiple Direct Children Class Does Not Have Attached Property Empty Value Assignment Empty Event Handler Assignment Verify Event Handler Exists In Code Behind Class Event Handler Signature Mismatch Verify Referenced Code Behind Field Exists Value Converter Input Type Mismatch Value Converter Output Type Mismatch Unresolved .NET Symbols Within Xaml Expression Unresolved Namespace Within Xaml Expression Invalid Named Font Size Generic Usage Is Missing x:TypeArguments x:TypeArguments Used On Non-Generic Class Unknown Type Provided To Generic Column Is Outside Grid Boundaries ColumnSpan Is Outside Grid Boundaries ColumnSpan Is Zero Grid.Column Usage Is Redundant Grid.ColumnSpan Usage Is Redundant Grid.Row Usage Is Redundant Grid.RowSpan Usage Is Redundant Row Is Outside Grid Boundaries RowSpan Is Outside Grid Boundaries RowSpan Is Zero Obsolete Property Used OnIdiom Return Type Mismatch OnPlatform Return Type Mismatch Referenced Attribute Member Exists In Parent Type Property Node Maps To Member In Parent Type Property Setter Node Misuse Property Setter Type Mismatch Duplicate Resource Dictionary Keys Resource Entry Does Not Define Key Missing Microsoft Schema ScrollView Has Multiple Direct Children Style Is Missing TargetType Property Setter Does Not Exist In Style TargetType Invalid Thickness Attribute Value Unknown Field Modifier Unknown Static Property Value Validate Value Types Duplicate Namespace Declaration Unresolved Xml Namespace Unresolved Xmlns Assembly Xaml Node Resolves Trigger Is Missing Target Type Trigger TargetType Does Not Match Parent Thickness Value Can Be Replaced By Static Resource Thickness Value Can Be Simplified Element Can Use Available Style Property Value Is Already Applied By Style Style TargetType Does Not Match BasedOn TargetType Ambiguous Static Resource Reference No Key Provided To Static Resource Expression StaticResource Return Type Mismatch Static Resource Style Target Type Is Incompatible x:Static Return Type Mismatch Undefined Static Resource Usage Slider Minimum Set Before Maximum Duplicate ShellItem Route Empty Shell Route Scheme Multiple VisualElements Defined In Shell Content Shell Requires At Least One Shell Item Validate Setter Attached Property Usage Setter Property Exists Style Or Trigger Has Duplicate Setters Resource Key Conflict Detect Missing Image In Linked Projects Grid Row/Column Setter Is Not A Number No Key Provided To DynamicResource Expression Validate Binding Expressions Return A Property Binding Against Non-Public Property Binding Expressions Resolve Binding Expression Return Type Mismatch Color Value Matches Static Resource Color Value Closely Matches Available Static Resource Hexadecimal Value Matches Named Color Malformed Hexadecimal Color Value Cell Usage Within CollectionView ItemTemplate Glyph Does Not Exist In Font Thickness Value Can Be Consolidated Color Value Can Be Consolidated Unescaped Newline In String Literal Unknown Embedded Font Reference Unknown OnPlatform Value RefreshView Content Should Be Scrollable Layout Font Reference Is Not Embedded Resource","title":"XAML Code Analysis"},{"location":"feature-matrix/#scaffolding","text":"","title":"Scaffolding"},{"location":"feature-matrix/#general","text":"Feature Lite Pro Platforms Scaffolder Overview","title":"General"},{"location":"feature-matrix/#android","text":"","title":"Android"},{"location":"feature-matrix/#utilities","text":"Feature Lite Pro Platforms Copy Android Package ID To Clipboard Open Android Manifest","title":"Utilities"},{"location":"feature-matrix/#utilities_1","text":"","title":"Utilities"},{"location":"feature-matrix/#project-and-solution-utilities","text":"Feature Lite Pro Platforms Copy Resource Id To Clipboard Delete Output Folder Clean and Compress Edit Shared Project Items","title":"Project and Solution Utilities"},{"location":"feature-matrix/#search-categories","text":"Feature Lite Pro Platforms MFractor Commands Search ResX Localisation Search Xamarin.Forms Automation Identifiers Search Xamarin.Forms Static Resources Search Xamarin.Forms Dynamic Resources Search","title":"Search Categories"},{"location":"feature-matrix/#web","text":"","title":"Web"},{"location":"feature-matrix/#navigation_1","text":"Feature Lite Pro Platforms Go To Razor File Go To Razor Code Behind Go To View Model","title":"Navigation"},{"location":"feature-matrix/#scaffolding_1","text":"Feature Lite Pro Platforms Razor Page Scaffolder Razor Component Scaffolder ASP.NET Controller Scaffolder","title":"Scaffolding"},{"location":"feature-matrix/#general_1","text":"","title":"General"},{"location":"feature-matrix/#miscellaneous-scaffolding","text":"Feature Lite Pro Platforms FodyWeavers Scaffolder","title":"Miscellaneous Scaffolding"},{"location":"feature-matrix/#c-scaffolding","text":"Feature Lite Pro Platforms C# Class Scaffolder C# Contextual Base Class Scaffolder Interface Scaffolder Attribute Scaffolder EventArgs Scaffolder","title":"C# Scaffolding"},{"location":"feature-matrix/#ios","text":"","title":"iOS"},{"location":"feature-matrix/#utilities_2","text":"Feature Lite Pro Platforms Copy Bundle ID","title":"Utilities"},{"location":"feature-matrix/#c-editor","text":"","title":"C# Editor"},{"location":"feature-matrix/#tooltips_1","text":"Feature Lite Pro Platforms DateTime Format Preview Tooltips","title":"Tooltips"},{"location":"installation-and-setup/","text":"Installing, activating and updating MFractor. Introduction This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows. Visual Studio Mac Installation (Marketplace) MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation. Installation (File) Note You can also use this procedure to update an existing installation of MFractor. Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version. Uninstallation MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor. Release Note The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article. Visual Studio Windows Installation (Marketplace) MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019 Uninstallation MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor. Release Notes The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Installation And Setup"},{"location":"installation-and-setup/#introduction","text":"This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows.","title":"Introduction"},{"location":"installation-and-setup/#visual-studio-mac","text":"","title":"Visual Studio Mac"},{"location":"installation-and-setup/#installation-marketplace","text":"MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file","text":"Note You can also use this procedure to update an existing installation of MFractor. Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation.","title":"Installation (File)"},{"location":"installation-and-setup/#activation","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades","text":"MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version.","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation","text":"MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-note","text":"The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article.","title":"Release Note"},{"location":"installation-and-setup/#visual-studio-windows","text":"","title":"Visual Studio Windows"},{"location":"installation-and-setup/#installation-marketplace_1","text":"MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file_1","text":"Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows.","title":"Installation (File)"},{"location":"installation-and-setup/#activation_1","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license_1","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades_1","text":"Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation_1","text":"MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-notes","text":"The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Release Notes"},{"location":"licensing/","text":"Information about MFractor's licensing and terms of use Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows. End User License Please find our End User License here. Privacy policy Please find our Private Policy here.","title":"Licensing"},{"location":"licensing/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"licensing/#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"MFractor Professional"},{"location":"licensing/#mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows.","title":"MFractor Lite"},{"location":"licensing/#end-user-license","text":"Please find our End User License here.","title":"End User License"},{"location":"licensing/#privacy-policy","text":"Please find our Private Policy here.","title":"Privacy policy"},{"location":"quickstart-mac/","text":"Getting started with MFractor for Visual Studio Mac Introduction This guide outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Mac documentation. Main Menu Overview When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Mac"},{"location":"quickstart-mac/#introduction","text":"This guide outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-mac/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Mac documentation.","title":"Setup And Maintenance"},{"location":"quickstart-mac/#main-menu-overview","text":"When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-mac/#feature-overview","text":"MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-mac/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-mac/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-mac/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-mac/#formatting","text":"","title":"Formatting"},{"location":"quickstart-windows/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Windows documentation. Main Menu Overview When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Windows"},{"location":"quickstart-windows/#introduction","text":"This guide outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-windows/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Windows documentation.","title":"Setup And Maintenance"},{"location":"quickstart-windows/#main-menu-overview","text":"When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-windows/#feature-overview","text":"MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-windows/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-windows/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-windows/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-windows/#formatting","text":"","title":"Formatting"},{"location":"resharper-compatibility/","text":"Using MFractor alongside ReSharper Introduction ReSharper is a very popular productivity extension for Visual Studio and it is important that MFractor works smoothly along side it. This guide covers how to enable MFractor to work alongside ReSharper. Enabling MFractor with ReSharper In a default ReSharper installation, MFractor's code actions will not appear in ReSharpers light-bulb menu. To ensure ReSharper merges in our code actions, first go to the top Extensions menu, then ReSharper -> Options . In the options window, go to Editor -> Visual Studio Features and then check Merge Visual Studio light bulb actions into ReSharper action indicator. In ReSharper Ultimate, go to Code Inspection -> Settings -> Merge Visual Studio light bulb actions into ReSharper action indicator","title":"ReSharper Compatibility"},{"location":"resharper-compatibility/#introduction","text":"ReSharper is a very popular productivity extension for Visual Studio and it is important that MFractor works smoothly along side it. This guide covers how to enable MFractor to work alongside ReSharper.","title":"Introduction"},{"location":"resharper-compatibility/#enabling-mfractor-with-resharper","text":"In a default ReSharper installation, MFractor's code actions will not appear in ReSharpers light-bulb menu. To ensure ReSharper merges in our code actions, first go to the top Extensions menu, then ReSharper -> Options . In the options window, go to Editor -> Visual Studio Features and then check Merge Visual Studio light bulb actions into ReSharper action indicator. In ReSharper Ultimate, go to Code Inspection -> Settings -> Merge Visual Studio light bulb actions into ReSharper action indicator","title":"Enabling MFractor with ReSharper"},{"location":"scaffolder/","text":"Efficiently generate new files using MFractors Scaffolder Introduction This guide provides an overview of the Scaffolder, a powerful file generation wizard included in MFractor. The Scaffolder is a rethink of the File -> New workflow to make it smarter, more efficient and more personal according to the conventions established in your project. What separates the Scaffolder from the standard New File Wizard is: It understands your input and automatically suggests file types based on naming conventions and file extensions. It is context aware . The Scaffolder considers the conventions established by other files in a folder and project when it generates code files. It provides a live-preview of the generated code. Please note the Scaffolder is in it's early stages. We would love feedback on improving its UX and requests for new scaffolds. Accessing The Scaffolder Documentation in progress Solution Pad The Scaffolder is Text Editor Main Menu Using The Scaffolder Available Scaffolders MFractor currently includes 17 scaffolders. Name Description Criteria Generate Attribute Declaration Inspects that the name provided into the composition engine ends with Attribute to suggest creating a new Attribute declaration. Activates when the scaffolding input is within a C# project and the file name ends with 'Attribute' Generate Class Declaration The default scaffolder, creates a new C# class file. Activates when the scaffolding input is within a C# project. Generate Class Using Contextual Base Class Creates a new C# class using the most common base class in the provided project path. Activates when the scaffolding input is within a C# project and the target folder path has one or more C# classes that hint . Generate Data Template Selector Generates a new Data Template Selector declaration Activates when the project references Xamarin.Forms and the file name ends with 'DataTemplateSelector'. Generate DesignTimeBindingContextAttribute Generates new DesignTimeBindingContextAttribute declaration Activates when the project references Xamarin.Forms and the file name is 'DesignTimeBindingContextAttribute'. Generate EventArgs Declaration Inspects that the name provided into the composition engine starts ends with EventArgs to suggest creating a new EventArgs declaration. Activates when the scaffolding input is within a C# project and the file name ends with 'EventArgs' Generate FodyWeavers.xml Generates new FodyWeavers.xml file. Activates when the scaffolding input matches 'FodyWeavers.xml' Generate Interface Declaration Inspects that the name provided into the composition engine starts with I and ends with .cs to suggest creating a new interface. Activates when the scaffolding input is within a C# project and the file name starts with 'I'' Generate Interface Declaration With Implementation Inspects that the name provided into the composition engine starts with I and ends with .cs to suggest creating a new interface. This scaffolder will also generate a declaration for the new interface in the same folder. Activates when the scaffolding input is within a C# project and the file name starts with 'I'' Generate New File Creates a new file with the given file extension No special criteria required. Generate Project Folders Creates a new file with the given file extension Activates when the scaffolding input ends with a path separator such as \\ or /. Linker Configuration File Generate a linker.xml configuration file for Android and iOS projects. Activates when the project is an iOS or Android project and the file name is 'linker.xml'. Razor Component Scaffolder Scaffolds a new Razor component with an optional code-behind Requires that the current project be a Razor project and the input file path ends with .razor or .razor.cs Razor Page Scaffolder Scaffolds a new Razor page with an optional code-behind Requires that the current project be a Razor project and the input file path ends with .razor or .razor.cs Value Conversion Attribute Scaffolder Generates new ValueConversionAttribute declaration Activates when the project references Xamarin.Forms and the file name is 'ValueConversionAttribute'. XAML Control Scaffolder Creates a new XAML control inheriting from Grid with a code behind class Activates when the project references Xamarin.Forms and the file extension is '.xaml'. XAML Page Scaffolder Creates a new XAML page with a code behind class Activates when the project references Xamarin.Forms, the file name ends with 'Page' and the file extension is '.xaml'.","title":"Scaffolder"},{"location":"scaffolder/#introduction","text":"This guide provides an overview of the Scaffolder, a powerful file generation wizard included in MFractor. The Scaffolder is a rethink of the File -> New workflow to make it smarter, more efficient and more personal according to the conventions established in your project. What separates the Scaffolder from the standard New File Wizard is: It understands your input and automatically suggests file types based on naming conventions and file extensions. It is context aware . The Scaffolder considers the conventions established by other files in a folder and project when it generates code files. It provides a live-preview of the generated code. Please note the Scaffolder is in it's early stages. We would love feedback on improving its UX and requests for new scaffolds.","title":"Introduction"},{"location":"scaffolder/#accessing-the-scaffolder","text":"Documentation in progress","title":"Accessing The Scaffolder"},{"location":"scaffolder/#solution-pad","text":"The Scaffolder is","title":"Solution Pad"},{"location":"scaffolder/#text-editor","text":"","title":"Text Editor"},{"location":"scaffolder/#main-menu","text":"","title":"Main Menu"},{"location":"scaffolder/#using-the-scaffolder","text":"","title":"Using The Scaffolder"},{"location":"scaffolder/#available-scaffolders","text":"MFractor currently includes 17 scaffolders. Name Description Criteria Generate Attribute Declaration Inspects that the name provided into the composition engine ends with Attribute to suggest creating a new Attribute declaration. Activates when the scaffolding input is within a C# project and the file name ends with 'Attribute' Generate Class Declaration The default scaffolder, creates a new C# class file. Activates when the scaffolding input is within a C# project. Generate Class Using Contextual Base Class Creates a new C# class using the most common base class in the provided project path. Activates when the scaffolding input is within a C# project and the target folder path has one or more C# classes that hint . Generate Data Template Selector Generates a new Data Template Selector declaration Activates when the project references Xamarin.Forms and the file name ends with 'DataTemplateSelector'. Generate DesignTimeBindingContextAttribute Generates new DesignTimeBindingContextAttribute declaration Activates when the project references Xamarin.Forms and the file name is 'DesignTimeBindingContextAttribute'. Generate EventArgs Declaration Inspects that the name provided into the composition engine starts ends with EventArgs to suggest creating a new EventArgs declaration. Activates when the scaffolding input is within a C# project and the file name ends with 'EventArgs' Generate FodyWeavers.xml Generates new FodyWeavers.xml file. Activates when the scaffolding input matches 'FodyWeavers.xml' Generate Interface Declaration Inspects that the name provided into the composition engine starts with I and ends with .cs to suggest creating a new interface. Activates when the scaffolding input is within a C# project and the file name starts with 'I'' Generate Interface Declaration With Implementation Inspects that the name provided into the composition engine starts with I and ends with .cs to suggest creating a new interface. This scaffolder will also generate a declaration for the new interface in the same folder. Activates when the scaffolding input is within a C# project and the file name starts with 'I'' Generate New File Creates a new file with the given file extension No special criteria required. Generate Project Folders Creates a new file with the given file extension Activates when the scaffolding input ends with a path separator such as \\ or /. Linker Configuration File Generate a linker.xml configuration file for Android and iOS projects. Activates when the project is an iOS or Android project and the file name is 'linker.xml'. Razor Component Scaffolder Scaffolds a new Razor component with an optional code-behind Requires that the current project be a Razor project and the input file path ends with .razor or .razor.cs Razor Page Scaffolder Scaffolds a new Razor page with an optional code-behind Requires that the current project be a Razor project and the input file path ends with .razor or .razor.cs Value Conversion Attribute Scaffolder Generates new ValueConversionAttribute declaration Activates when the project references Xamarin.Forms and the file name is 'ValueConversionAttribute'. XAML Control Scaffolder Creates a new XAML control inheriting from Grid with a code behind class Activates when the project references Xamarin.Forms and the file extension is '.xaml'. XAML Page Scaffolder Creates a new XAML page with a code behind class Activates when the project references Xamarin.Forms, the file name ends with 'Page' and the file extension is '.xaml'.","title":"Available Scaffolders"},{"location":"support/","text":"How to get support or report issues for MFractor Reporting a Bug We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE. Visual Studio Mac To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log . Visual Studio Windows To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback . Support Channels In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support"},{"location":"support/#reporting-a-bug","text":"We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE.","title":"Reporting a Bug"},{"location":"support/#visual-studio-mac","text":"To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log .","title":"Visual Studio Mac"},{"location":"support/#visual-studio-windows","text":"To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback .","title":"Visual Studio Windows"},{"location":"support/#support-channels","text":"In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support Channels"},{"location":"analysis/disabling-analysers/","text":"How to disable code analysers in MFractor Introduction MFractor includes several code analysers that aid in managing various parts of you app and in surfacing issues at design time. Sometimes you will want to control whether these run on particular files; this is possible with a suppression comment. Disabling A Code Analyser You can disable XAML analysers at the document level by adding a suppress comment, structured as MFractor: Suppress(ID) , to top of your document. MFractor supports disabling analysers by both it's Diagnostic ID (EG: MF1001 ) or its MFractor ID (EG: com.mfractor.analysis.xaml.binding_expression_resolves ) Disabling Using Diagnostic ID <!-- [MFractor: Suppress(MF1000)] --> Disabling Using MFractor ID <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] --> Links Tweet","title":"Disabling Analysers"},{"location":"analysis/disabling-analysers/#introduction","text":"MFractor includes several code analysers that aid in managing various parts of you app and in surfacing issues at design time. Sometimes you will want to control whether these run on particular files; this is possible with a suppression comment.","title":"Introduction"},{"location":"analysis/disabling-analysers/#disabling-a-code-analyser","text":"You can disable XAML analysers at the document level by adding a suppress comment, structured as MFractor: Suppress(ID) , to top of your document. MFractor supports disabling analysers by both it's Diagnostic ID (EG: MF1001 ) or its MFractor ID (EG: com.mfractor.analysis.xaml.binding_expression_resolves ) Disabling Using Diagnostic ID <!-- [MFractor: Suppress(MF1000)] --> Disabling Using MFractor ID <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] -->","title":"Disabling A Code Analyser"},{"location":"analysis/disabling-analysers/#links","text":"Tweet","title":"Links"},{"location":"analysis/overview/","text":"Detect errors, improvements and maintainability suggestions with code analysis. Introduction MFractor includes a code-analysis engine that inspects your XAML code for a wide range of common issues. Managing Analysers MFractors code analysers can be enabled or disabled at the application-level through the product Preferences . To enable or disable a particular code analyser, first, navigate to the top menu bar, find the MFractor tab and then click Preferences . Scroll down to Code Analysis and you can search for a specific one or toggle to disable at an application level. If you'd like to disable at for only a particular document, please see our Disabling Analysers article. MFractor currently includes 95 analysers. Available Code Analysers Diagnostic ID Name Description MF1000 Duplicate AutomationIds Inspects a Xaml document for occurances of duplicate AutomationId declarations. MF1001 Empty AutomationId Declaration Inspects a Xaml document for occurances of duplicate AutomationId declarations. MF1002 x:Name Has Invalid Characters Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters. MF1003 Duplicate Code Behind Field Declarations Checks that the value assigned to an x:Name attribute is unique within the scope of the document. MF1004 Empty Code Behind Field Declaration Inspects occurances of the x:Name attribute and validates that a value is assigned; empty x:Name expressions generate an empty named code-behind field, causing compilation errors. MF1005 ContentPage Has Multiple Direct Children Inspects usages of ContentPage and checks that it only has a single child view. Assigning multiple children into a ContentPage is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout . MF1006 ContentView Has Multiple Direct Children Inspects usages of the ContentView element and checks that it only has a single child view. Assigning multiple children into a ContentView is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout . MF1007 Validate Binding Expressions Return A Property Evaluates a Binding expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context. MF1008 Binding Against Non-Public Property Inspects data-binding expressions and validates that the property return is a public property. Data-binding against a non-public property causes data-binding to fail. MF1009 Binding Expressions Resolve Inspects Binding expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context. MF1010 Binding Expression Return Type Mismatch Validates that the .NET symbol returned by a binding expression matches the expected type for the property. MF1011 No Key Provided To DynamicResource Expression Inspects DynamicResource expressions and validates that a resource key has been provided. MF1012 Empty Event Handler Assignment Checks that an event handler assignment is not empty as empty event handler assignments will cause a compilation error. MF1013 Event Handler Exists In Code Behind Class Checks that an event callback referenced referenced by an attribute value exists in the code behind class. MF1014 Event Handler Signature Mismatch Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to. MF1015 Referenced Code Behind Field Exists Inspects usages of the x:Reference expression and validates the referenced element has been declared within the document. x:Reference expressions are used to resolve another Xaml node has a code behind field defined using the x:Name attribute. MF1016 Value Converter Input Type Mismatch Inspects the Converter property of a Binding expression and validates that the input type is correct. This analyser requires that the IValueConverter implementation uses the ValueConversion attribute to declare it input type. MF1017 Value Converter Output Type Mismatch Inspects the Converter component of a Binding expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the IValueConverter implementation uses the ValueConversion attribute to declare it input type. MF1018 Unresolved .NET Symbols Within Xaml Expression Inspects a .net symbol reference (eg local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references. MF1019 Unresolved Namespace Within Xaml Expression Inspects a .net symbol reference (eg local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document. MF1020 Invalid Named Font Size Inspects FontSize attributes and validates that the named size provided to it is a valid font size name (Micro, Small, Medium, Large). MF1021 Generic Usage Is Missing x:TypeArguments Inspects generic classes that are instantiated through Xaml and validates that an x:TypeArguments attribute or property assignment node is present. MF1022 x:TypeArguments Used On Non-Generic Class Inspects for usages of x:TypeArguments on elements that are non-generic classes. MF1023 Unknown Type Provided To Generic Inspects usages of x:TypeArguments and validates that the type provided exists. MF1024 Column Is Outside Grid Boundaries This code analyser inspects usages of the Grid.Column attribute and validates that the column provided is within the total columns declared by the parent grid. MF1025 ColumnSpan Is Outside Grid Boundaries This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the span provided is within the total columns declared by the parent grid. MF1026 ColumnSpan Is Zero This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the span provided is a non-zero value. MF1027 Grid Row/Column Setter Is Not A Number This code analyser inspects usages of the Grid.Column attribute and validates that the element is inside a Grid . MF1028 Grid.Column Usage Is Redundant This code analyser inspects usages of the Grid.Column attribute and validates that the element is inside a Grid . MF1029 Grid.ColumnSpan Usage Is Redundant This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the element is inside a Grid . MF1030 Grid.Row Usage Is Redundant This code analyser inspects usages of the Grid.Row attribute and validates that the element is inside a Grid . MF1031 Grid.RowSpan Usage Is Redundant This code analyser inspects usages of the Grid.RowSpan attribute and validates that the element is inside a Grid . MF1032 Row Is Outside Grid Boundaries This code analyser inspects usages of the Grid.Row attribute and validates that the row provided is within the total rows declared by the parent grid. MF1033 RowSpan Is Outside Grid Boundaries This code analyser inspects usages of the Grid.RowSpan attribute and validates that the span provided is within the total rows declared by the parent grid. MF1034 RowSpan Is Zero This code analyser inspects usages of the Grid.RowSpan attribute and validates that the span provided is a non-zero value. MF1035 Detect Missing Image In Linked Projects This code analyser inspects the value provided into an ImageSource and validates that an image of that name exists within any iOS or Android projects that reference this shared project or PCL. MF1036 OnIdiom Return Type Mismatch Checks the type returned by a Xamarin.Forms.OnIdiom element is valid with the parent property type. MF1037 OnPlatform Return Type Mismatch Checks the type returned by a Xamarin.Forms.OnPlatform element is valid with the parent property type. MF1038 Referenced Attribute Member Exists In Parent Type Checks that an attribute resolves to a member within its parent type. MF1039 Property Node Maps To Member In Parent Type Checks that a property node resolves to a member within its parent type. MF1040 Property Setter Node Misuse Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context. MF1041 Property Setter Type Mismatch When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property. MF1042 Duplicate Resource Dictionary Keys Validates the each resource entry within a resource dictionary has a unique key. MF1043 Resource Entry Does Not Define Key Validates the elements provided to a resource dictionary supply an x:Key attribute to declare their resource dictionary key. MF1044 Resource Key Conflict Inspects resource key declarations and validates that the resource key is not already defined in other files that are used by this file. MF1045 Unused Resource Inspects that resource dictionary entries are used via the StaticResource markup extension expression within this document. MF1046 Missing Microsoft Schema Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema: http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents. MF1047 Duplicate ShellItem Route Inspects Xamarin.Forms.ShellItem elements and validates that their Route is unique. MF1048 Validate Setter Attached Property Usage Inspects the Property attribute for a Xamarin.Forms.Setter and, when it is referencing an attached property, validates that the namespace, class and attached property exist. MF1049 Setter Property Exists Inspects the Property attribute for a Xamarin.Forms.Setter and validates that it exists in the parents specified TargetType . MF1051 Empty Shell Route Scheme Providing an empty value into the RouteScheme property of a Xamarin.Forms.Shell element will cause the application to crash. This code inspection validates that a value is provided to the RouteScheme property. MF1052 Multiple VisualElements Defined In Shell Content Inspects usages of the Xamarin.Forms.ShellContent and validates that only one page or view is declared within it. MF1053 Shell Requires At Least One Item When using Xamarin.Forms.Shell you must provide at least one item declaration. MF1054 Ambiguous Static Resource Reference Inspects StaticResource expressions and checks if one or more static resources will be returned from the resource expression. MF1055 No Key Provided To Static Resource Expression Inspects StaticResource expressions and validates that a resource key has been provided. MF1056 StaticResource Return Type Mismatch Validates that the symbol returned by a StaticResource expression matches the expected type for the property. MF1057 x:Static Return Type Mismatch Validates that the .NET symbol returned by an x:Static expressions matches the expected type for the property. MF1058 Undefined Static Resource Usage Validates that the element referenced by a StaticResource expression resource lookup resolves to a resource defined in the xaml file. MF1059 Style Is Missing TargetType When a Style is used within XAML, it should always specify a type it targets using the TargetType property. This analysis check inspects for usages of Style that don't assign the TargetType property. MF1060 Style Or Trigger Has Duplicate Setters Inspects Style and Trigger declarations and checks if there is are multiple Setter's for a property. MF1061 Property Setter Does Not Exist In Style TargetType This code inspection looks at Setter elements when they are used inside a Style and validates that the member specified in the Property attribute exists on the type symbol referenced in the parent Style s TargetType attribute. MF1062 Style TargetType Does Not Match BasedOn TargetType Inspects XAML styles that use the BasedOn property to inherit from another style and validates the TargetType of the current style matches the TargetType defined by the BasedOn style. MF1063 Invalid Thickness Attribute Value Inspects attribute properties that use the Xamarin.Forms.Thickness type and checks the value used can be translated to a thickness. For example, Thickness could accidentally be provided 0,5,05 , with the intention of it being 0,5,0,5 ; the first example has three arguments while the second has four. This misuse would cause the app to crash when using inflated XAML or for XAMLC to fail. MF1064 Trigger Is Missing Target Type Inspects XAML elements that derive from Xamarin.Forms.TriggerBase and validates that they include a TargetType attribute MF1065 Trigger TargetType Does Not Match Parent Inspects usages of the TargetType property for a Xamarin.Forms.TriggerBase and validates that the type provided matches the outer XAML node. MF1066 Duplicate Namespace Declaration Checks that an xml namespace points to a unique namespace and assembly. For example if both xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\" and xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\" were declared, this analyser would warn that they both reference the same assembly and namespace. MF1067 Unresolved Xml Namespace Checks that the namespace used on the xml nodes is defined within the current document. MF1068 Unresolved Xmlns Assembly Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project. MF1069 Class Does Not Have Attached Property Looks for attached properties (for example Grid.Row ) and validates they exist in the class that they are attempting to use. MF1070 Empty Value Assignment Detects when a boolean, double, long or integer value is being assigned an empty value and will cause a compilation error. MF1071 Obsolete Property Used Checks for attributes that are marked as obsolete/deprecated. MF1072 Unknown Static Property Value For attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the LayoutOptions class has the static fields Fill or CentreAndExpand that can be used a literal attribute values. If CentreAndFill was provided (an invalid value), this analyser would inspect the LayoutOptions class for a static field named CentreAndFill and trigger an analysis error when it couldn't be found. MF1074 Validate Value Types Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid. MF1075 Xaml Node Resolves Checks that xaml nodes map to a valid .NET symbol. MF1076 Hexadecimal Value Matches Named Color Inspects HexaDecimal color values and matches them against the named color constants. MF1077 Static Resource Style Target Type Is Incompatible When a static resource expression returns a style, this code inspection verifies that the TargetType of the given style is compatible with MF1078 Thickness Value Can Be Simplified Inspect's thickness attribute values and verifies if the values can be simplified. For example, a thickness value of 20,0,20,0 could be simplified to 20,0 . MF1079 Color Value Matches Static Resource When assigning a color a hexadecimal or named constant, this code inspection detects if that color value matches an available color resource. MF1080 Thickness Value Can Be Replaced By Static Resource Inspects assignments of Xamarin.Forms.Thickness values in XAML and matches them to declared static resources. MF1081 Property Value Is Already Applied By Style When a Style is applied within XAML, it should always specify a type it targets using the TargetType property. This analysis check inspects for usages of Style that don't assign the TargetType property. MF1082 Element Can Use Available Style Inspects XAML elements that do not have a style applied and, if possible, matches them to an available style that targets the element type and also applies the same properties. MF1084 Malformed Hexadecimal Color Value Inspects hexadecimal color values and validates that they are in a format supported by Xamarin.Forms. MF1085 Unknown Field Modifier Inspects occurances of the x:FieldModifer attribute and validates that the value is one of the following keywords.<\br> private: Specifies that the generated field for the XAML element is accessible only within the body of the class in which it is declared. public: Specifies that the generated field for the XAML element has no access restrictions. protected: Specifies that the generated field for the XAML element is accessible within its class and by derived class instances. internal: Specifies that the generated field for the XAML element is accessible only within types in the same assembly. notpublic: Specifies that the generated field for the XAML element is accessible only within types in the same assembly. MF1086 Color Value Closely Matches Available Static Resource Inspects color values and checks if they closely match the color value defined by a static resource. MF1088 Slider Minimum Set Before Maximum Inspects slider elements and verifies that the user sets the maximum before the minimum MF1090 Cell Usage Within CollectionView ItemTemplate Inspects the DataTemplate within a CollectionViews ItemTemplate property and verify that it does not use a cell. MF1091 Glyph Does Not Exist In Font When a font is applied to a XAML element via the FontFamily attribute, this analyser inspects the character code provided and verifies that it exists in the referenced font asset. MF1092 Thickness Value Can Be Consolidated Inspects thickness values and verifies if there are other thickness in the projects that also declare MF1093 RefreshView Content Should Be Scrollable Layout Inspects the inner element of a refresh view and verifies that it derives from either a ListView, ScrollView or CollectionView. MF1094 Color Value Can Be Consolidated Inspects color values and verifies if there are other colors in the projects that also declare that specific color. MF1095 Unknown Embedded Font Reference Inspects FontFamily attributes and validates that the referenced embedded font asset is defined. MF1096 Unescaped Newline In String Literal When a newline character, \\n, is used within a string literal in XAML, it will not render as expected. Newlines should be added to XAML using the escaped character code. MF1097 Unknown OnPlatform Value Checks the Platform value provided to a Xamarin.Forms.On element and verifies that it is a known platform within the Xamarin.Forms.Device class. MF1098 Data Template Expected Inspects property nodes that accept a data template and verifies that the content is a DataTemplate. MF1099 ScrollView Has Multiple Direct Children Inspects usages of ScrollView and checks that it only has a single child view. Assigning multiple children to a ScrollView is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout.","title":"Overview"},{"location":"analysis/overview/#introduction","text":"MFractor includes a code-analysis engine that inspects your XAML code for a wide range of common issues.","title":"Introduction"},{"location":"analysis/overview/#managing-analysers","text":"MFractors code analysers can be enabled or disabled at the application-level through the product Preferences . To enable or disable a particular code analyser, first, navigate to the top menu bar, find the MFractor tab and then click Preferences . Scroll down to Code Analysis and you can search for a specific one or toggle to disable at an application level. If you'd like to disable at for only a particular document, please see our Disabling Analysers article. MFractor currently includes 95 analysers.","title":"Managing Analysers"},{"location":"analysis/overview/#available-code-analysers","text":"Diagnostic ID Name Description MF1000 Duplicate AutomationIds Inspects a Xaml document for occurances of duplicate AutomationId declarations. MF1001 Empty AutomationId Declaration Inspects a Xaml document for occurances of duplicate AutomationId declarations. MF1002 x:Name Has Invalid Characters Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters. MF1003 Duplicate Code Behind Field Declarations Checks that the value assigned to an x:Name attribute is unique within the scope of the document. MF1004 Empty Code Behind Field Declaration Inspects occurances of the x:Name attribute and validates that a value is assigned; empty x:Name expressions generate an empty named code-behind field, causing compilation errors. MF1005 ContentPage Has Multiple Direct Children Inspects usages of ContentPage and checks that it only has a single child view. Assigning multiple children into a ContentPage is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout . MF1006 ContentView Has Multiple Direct Children Inspects usages of the ContentView element and checks that it only has a single child view. Assigning multiple children into a ContentView is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout . MF1007 Validate Binding Expressions Return A Property Evaluates a Binding expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context. MF1008 Binding Against Non-Public Property Inspects data-binding expressions and validates that the property return is a public property. Data-binding against a non-public property causes data-binding to fail. MF1009 Binding Expressions Resolve Inspects Binding expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context. MF1010 Binding Expression Return Type Mismatch Validates that the .NET symbol returned by a binding expression matches the expected type for the property. MF1011 No Key Provided To DynamicResource Expression Inspects DynamicResource expressions and validates that a resource key has been provided. MF1012 Empty Event Handler Assignment Checks that an event handler assignment is not empty as empty event handler assignments will cause a compilation error. MF1013 Event Handler Exists In Code Behind Class Checks that an event callback referenced referenced by an attribute value exists in the code behind class. MF1014 Event Handler Signature Mismatch Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to. MF1015 Referenced Code Behind Field Exists Inspects usages of the x:Reference expression and validates the referenced element has been declared within the document. x:Reference expressions are used to resolve another Xaml node has a code behind field defined using the x:Name attribute. MF1016 Value Converter Input Type Mismatch Inspects the Converter property of a Binding expression and validates that the input type is correct. This analyser requires that the IValueConverter implementation uses the ValueConversion attribute to declare it input type. MF1017 Value Converter Output Type Mismatch Inspects the Converter component of a Binding expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the IValueConverter implementation uses the ValueConversion attribute to declare it input type. MF1018 Unresolved .NET Symbols Within Xaml Expression Inspects a .net symbol reference (eg local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references. MF1019 Unresolved Namespace Within Xaml Expression Inspects a .net symbol reference (eg local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document. MF1020 Invalid Named Font Size Inspects FontSize attributes and validates that the named size provided to it is a valid font size name (Micro, Small, Medium, Large). MF1021 Generic Usage Is Missing x:TypeArguments Inspects generic classes that are instantiated through Xaml and validates that an x:TypeArguments attribute or property assignment node is present. MF1022 x:TypeArguments Used On Non-Generic Class Inspects for usages of x:TypeArguments on elements that are non-generic classes. MF1023 Unknown Type Provided To Generic Inspects usages of x:TypeArguments and validates that the type provided exists. MF1024 Column Is Outside Grid Boundaries This code analyser inspects usages of the Grid.Column attribute and validates that the column provided is within the total columns declared by the parent grid. MF1025 ColumnSpan Is Outside Grid Boundaries This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the span provided is within the total columns declared by the parent grid. MF1026 ColumnSpan Is Zero This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the span provided is a non-zero value. MF1027 Grid Row/Column Setter Is Not A Number This code analyser inspects usages of the Grid.Column attribute and validates that the element is inside a Grid . MF1028 Grid.Column Usage Is Redundant This code analyser inspects usages of the Grid.Column attribute and validates that the element is inside a Grid . MF1029 Grid.ColumnSpan Usage Is Redundant This code analyser inspects usages of the Grid.ColumnSpan attribute and validates that the element is inside a Grid . MF1030 Grid.Row Usage Is Redundant This code analyser inspects usages of the Grid.Row attribute and validates that the element is inside a Grid . MF1031 Grid.RowSpan Usage Is Redundant This code analyser inspects usages of the Grid.RowSpan attribute and validates that the element is inside a Grid . MF1032 Row Is Outside Grid Boundaries This code analyser inspects usages of the Grid.Row attribute and validates that the row provided is within the total rows declared by the parent grid. MF1033 RowSpan Is Outside Grid Boundaries This code analyser inspects usages of the Grid.RowSpan attribute and validates that the span provided is within the total rows declared by the parent grid. MF1034 RowSpan Is Zero This code analyser inspects usages of the Grid.RowSpan attribute and validates that the span provided is a non-zero value. MF1035 Detect Missing Image In Linked Projects This code analyser inspects the value provided into an ImageSource and validates that an image of that name exists within any iOS or Android projects that reference this shared project or PCL. MF1036 OnIdiom Return Type Mismatch Checks the type returned by a Xamarin.Forms.OnIdiom element is valid with the parent property type. MF1037 OnPlatform Return Type Mismatch Checks the type returned by a Xamarin.Forms.OnPlatform element is valid with the parent property type. MF1038 Referenced Attribute Member Exists In Parent Type Checks that an attribute resolves to a member within its parent type. MF1039 Property Node Maps To Member In Parent Type Checks that a property node resolves to a member within its parent type. MF1040 Property Setter Node Misuse Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context. MF1041 Property Setter Type Mismatch When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property. MF1042 Duplicate Resource Dictionary Keys Validates the each resource entry within a resource dictionary has a unique key. MF1043 Resource Entry Does Not Define Key Validates the elements provided to a resource dictionary supply an x:Key attribute to declare their resource dictionary key. MF1044 Resource Key Conflict Inspects resource key declarations and validates that the resource key is not already defined in other files that are used by this file. MF1045 Unused Resource Inspects that resource dictionary entries are used via the StaticResource markup extension expression within this document. MF1046 Missing Microsoft Schema Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema: http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents. MF1047 Duplicate ShellItem Route Inspects Xamarin.Forms.ShellItem elements and validates that their Route is unique. MF1048 Validate Setter Attached Property Usage Inspects the Property attribute for a Xamarin.Forms.Setter and, when it is referencing an attached property, validates that the namespace, class and attached property exist. MF1049 Setter Property Exists Inspects the Property attribute for a Xamarin.Forms.Setter and validates that it exists in the parents specified TargetType . MF1051 Empty Shell Route Scheme Providing an empty value into the RouteScheme property of a Xamarin.Forms.Shell element will cause the application to crash. This code inspection validates that a value is provided to the RouteScheme property. MF1052 Multiple VisualElements Defined In Shell Content Inspects usages of the Xamarin.Forms.ShellContent and validates that only one page or view is declared within it. MF1053 Shell Requires At Least One Item When using Xamarin.Forms.Shell you must provide at least one item declaration. MF1054 Ambiguous Static Resource Reference Inspects StaticResource expressions and checks if one or more static resources will be returned from the resource expression. MF1055 No Key Provided To Static Resource Expression Inspects StaticResource expressions and validates that a resource key has been provided. MF1056 StaticResource Return Type Mismatch Validates that the symbol returned by a StaticResource expression matches the expected type for the property. MF1057 x:Static Return Type Mismatch Validates that the .NET symbol returned by an x:Static expressions matches the expected type for the property. MF1058 Undefined Static Resource Usage Validates that the element referenced by a StaticResource expression resource lookup resolves to a resource defined in the xaml file. MF1059 Style Is Missing TargetType When a Style is used within XAML, it should always specify a type it targets using the TargetType property. This analysis check inspects for usages of Style that don't assign the TargetType property. MF1060 Style Or Trigger Has Duplicate Setters Inspects Style and Trigger declarations and checks if there is are multiple Setter's for a property. MF1061 Property Setter Does Not Exist In Style TargetType This code inspection looks at Setter elements when they are used inside a Style and validates that the member specified in the Property attribute exists on the type symbol referenced in the parent Style s TargetType attribute. MF1062 Style TargetType Does Not Match BasedOn TargetType Inspects XAML styles that use the BasedOn property to inherit from another style and validates the TargetType of the current style matches the TargetType defined by the BasedOn style. MF1063 Invalid Thickness Attribute Value Inspects attribute properties that use the Xamarin.Forms.Thickness type and checks the value used can be translated to a thickness. For example, Thickness could accidentally be provided 0,5,05 , with the intention of it being 0,5,0,5 ; the first example has three arguments while the second has four. This misuse would cause the app to crash when using inflated XAML or for XAMLC to fail. MF1064 Trigger Is Missing Target Type Inspects XAML elements that derive from Xamarin.Forms.TriggerBase and validates that they include a TargetType attribute MF1065 Trigger TargetType Does Not Match Parent Inspects usages of the TargetType property for a Xamarin.Forms.TriggerBase and validates that the type provided matches the outer XAML node. MF1066 Duplicate Namespace Declaration Checks that an xml namespace points to a unique namespace and assembly. For example if both xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\" and xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\" were declared, this analyser would warn that they both reference the same assembly and namespace. MF1067 Unresolved Xml Namespace Checks that the namespace used on the xml nodes is defined within the current document. MF1068 Unresolved Xmlns Assembly Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project. MF1069 Class Does Not Have Attached Property Looks for attached properties (for example Grid.Row ) and validates they exist in the class that they are attempting to use. MF1070 Empty Value Assignment Detects when a boolean, double, long or integer value is being assigned an empty value and will cause a compilation error. MF1071 Obsolete Property Used Checks for attributes that are marked as obsolete/deprecated. MF1072 Unknown Static Property Value For attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the LayoutOptions class has the static fields Fill or CentreAndExpand that can be used a literal attribute values. If CentreAndFill was provided (an invalid value), this analyser would inspect the LayoutOptions class for a static field named CentreAndFill and trigger an analysis error when it couldn't be found. MF1074 Validate Value Types Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid. MF1075 Xaml Node Resolves Checks that xaml nodes map to a valid .NET symbol. MF1076 Hexadecimal Value Matches Named Color Inspects HexaDecimal color values and matches them against the named color constants. MF1077 Static Resource Style Target Type Is Incompatible When a static resource expression returns a style, this code inspection verifies that the TargetType of the given style is compatible with MF1078 Thickness Value Can Be Simplified Inspect's thickness attribute values and verifies if the values can be simplified. For example, a thickness value of 20,0,20,0 could be simplified to 20,0 . MF1079 Color Value Matches Static Resource When assigning a color a hexadecimal or named constant, this code inspection detects if that color value matches an available color resource. MF1080 Thickness Value Can Be Replaced By Static Resource Inspects assignments of Xamarin.Forms.Thickness values in XAML and matches them to declared static resources. MF1081 Property Value Is Already Applied By Style When a Style is applied within XAML, it should always specify a type it targets using the TargetType property. This analysis check inspects for usages of Style that don't assign the TargetType property. MF1082 Element Can Use Available Style Inspects XAML elements that do not have a style applied and, if possible, matches them to an available style that targets the element type and also applies the same properties. MF1084 Malformed Hexadecimal Color Value Inspects hexadecimal color values and validates that they are in a format supported by Xamarin.Forms. MF1085 Unknown Field Modifier Inspects occurances of the x:FieldModifer attribute and validates that the value is one of the following keywords.<\br> private: Specifies that the generated field for the XAML element is accessible only within the body of the class in which it is declared. public: Specifies that the generated field for the XAML element has no access restrictions. protected: Specifies that the generated field for the XAML element is accessible within its class and by derived class instances. internal: Specifies that the generated field for the XAML element is accessible only within types in the same assembly. notpublic: Specifies that the generated field for the XAML element is accessible only within types in the same assembly. MF1086 Color Value Closely Matches Available Static Resource Inspects color values and checks if they closely match the color value defined by a static resource. MF1088 Slider Minimum Set Before Maximum Inspects slider elements and verifies that the user sets the maximum before the minimum MF1090 Cell Usage Within CollectionView ItemTemplate Inspects the DataTemplate within a CollectionViews ItemTemplate property and verify that it does not use a cell. MF1091 Glyph Does Not Exist In Font When a font is applied to a XAML element via the FontFamily attribute, this analyser inspects the character code provided and verifies that it exists in the referenced font asset. MF1092 Thickness Value Can Be Consolidated Inspects thickness values and verifies if there are other thickness in the projects that also declare MF1093 RefreshView Content Should Be Scrollable Layout Inspects the inner element of a refresh view and verifies that it derives from either a ListView, ScrollView or CollectionView. MF1094 Color Value Can Be Consolidated Inspects color values and verifies if there are other colors in the projects that also declare that specific color. MF1095 Unknown Embedded Font Reference Inspects FontFamily attributes and validates that the referenced embedded font asset is defined. MF1096 Unescaped Newline In String Literal When a newline character, \\n, is used within a string literal in XAML, it will not render as expected. Newlines should be added to XAML using the escaped character code. MF1097 Unknown OnPlatform Value Checks the Platform value provided to a Xamarin.Forms.On element and verifies that it is a known platform within the Xamarin.Forms.Device class. MF1098 Data Template Expected Inspects property nodes that accept a data template and verifies that the content is a DataTemplate. MF1099 ScrollView Has Multiple Direct Children Inspects usages of ScrollView and checks that it only has a single child view. Assigning multiple children to a ScrollView is a common mistake where the developer usually intended to wrap the chid views with a Grid or a StackLayout.","title":"Available Code Analysers"},{"location":"android/tools/copy-package-id/","text":"Quickly copy the package ID of an Android Project. This feature is available in MFractor Professional Introduction When developing Android apps you often need to copy the Package ID of the app to setup store publishing or platforms like Firebase. The Copy Android Package ID to Clipboard tool allows you to quickly copy the package of any Android project in your solution. To access this command: On macOS : right-click on the Android project on the Solution Pad . Under the Tools menu you'll find the Copy Packaged Id to Clipboard option. On Windows : right-click on the Android project on the Solution Explorer , the Copy Package Id to Clipboard will appear on the second section of the menu. The project Package ID (as defined on the AndroidManifest.xml file) will be copied to your clipboard. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Copy Package ID"},{"location":"android/tools/copy-package-id/#introduction","text":"When developing Android apps you often need to copy the Package ID of the app to setup store publishing or platforms like Firebase. The Copy Android Package ID to Clipboard tool allows you to quickly copy the package of any Android project in your solution. To access this command: On macOS : right-click on the Android project on the Solution Pad . Under the Tools menu you'll find the Copy Packaged Id to Clipboard option. On Windows : right-click on the Android project on the Solution Explorer , the Copy Package Id to Clipboard will appear on the second section of the menu. The project Package ID (as defined on the AndroidManifest.xml file) will be copied to your clipboard. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Introduction"},{"location":"android/tools/open-android-manifest/","text":"Quickly open the manifest file of an Android Project. This feature is available in MFractor Professional Introduction When developing Android apps you often need to edit the manifest file of the app. The Open Android Manifest tool allows you to quickly edit the Android Manifest in your solution. To access this command: macOS Right-click on the Android project on the Solution Pad , the Open Android Manifest will appear on the ninth section of the menu. Windows Right-click on the Android project on the Solution Explorer , the Open Android Manifest will appear on the second section of the menu. The AndroidManifest.xml file will be opened ready to edit. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Open Android Manifest"},{"location":"android/tools/open-android-manifest/#introduction","text":"When developing Android apps you often need to edit the manifest file of the app. The Open Android Manifest tool allows you to quickly edit the Android Manifest in your solution. To access this command: macOS Right-click on the Android project on the Solution Pad , the Open Android Manifest will appear on the ninth section of the menu. Windows Right-click on the Android project on the Solution Explorer , the Open Android Manifest will appear on the second section of the menu. The AndroidManifest.xml file will be opened ready to edit. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Introduction"},{"location":"csharp/create-class-from-clipboard/","text":"Generate a new class using the contents of the clipboard This feature is available in MFractor Professional Introduction When working as developers, we often need to add a class copied into the clipboard into our code base. This classes contents could come from a wide range of sources but some common ones are: An answer from StackOverflow. Some code from on Github or CodeProject. Code from an online code-generation tool like QuickType or IconFont2Code . Another one of our code bases. Let's consider a common example, that we are using a class from an answer on StackOverflow. You discover an answer with a class that solves your problem and now you would like add it to your project. To add the class to your code base, you would do something like so: Copy the code to the clipboard. Open your project and create a new file. Paste the class into the new file. Ensure the file name to match the class name. Cleanup the namespace to match the folder path. This involves a lot of steps and a lot of manual cleanup work, making it error prone and tedius. To simplify this process, MFractor includes the Add Class Using Clipboard tool to make this easier. This tool is very useful when copying code from Github, StackOverflow or other code bases. (Be honest, we all do it). We can use Add Class Using Clipboard to create a new class using the clipboards content; it will automatically detect the file name based on the clipboards class and also correct or create the namespace based on project and folder you are creating it from. Creating A Class From Clipboard The Create Class From Clipboard tool does not currently support shared projects To use the Create Class From Clipboard tool, copy a valid C# class (with or without it's namespace and usings) to the clipboard. Next, right click on a project or project folder and beneath the Add menu, choose the Add Class Using Clipboard A window will now appear that previews the code that will be created. In this window we can change the following: Name: The name of the class. By default this is the name of the first class found in the clipboard Folder: The folder path where the new file will be placed. This will also control the namespace of the new class. When the Create Class From Clipboard window is launched, MFractor will automatically perform the following: Inspect the clipboards contents and use the name of the first class found as the file name. If no namespaces are declared, MFractor will wrap the class in a namespace based on the projects default namespace and the folder path the file is being placed into. If a namespace is defined, MFractor will correct it to use the project and folder path.","title":"Create Class From Clipboard"},{"location":"csharp/create-class-from-clipboard/#introduction","text":"When working as developers, we often need to add a class copied into the clipboard into our code base. This classes contents could come from a wide range of sources but some common ones are: An answer from StackOverflow. Some code from on Github or CodeProject. Code from an online code-generation tool like QuickType or IconFont2Code . Another one of our code bases. Let's consider a common example, that we are using a class from an answer on StackOverflow. You discover an answer with a class that solves your problem and now you would like add it to your project. To add the class to your code base, you would do something like so: Copy the code to the clipboard. Open your project and create a new file. Paste the class into the new file. Ensure the file name to match the class name. Cleanup the namespace to match the folder path. This involves a lot of steps and a lot of manual cleanup work, making it error prone and tedius. To simplify this process, MFractor includes the Add Class Using Clipboard tool to make this easier. This tool is very useful when copying code from Github, StackOverflow or other code bases. (Be honest, we all do it). We can use Add Class Using Clipboard to create a new class using the clipboards content; it will automatically detect the file name based on the clipboards class and also correct or create the namespace based on project and folder you are creating it from.","title":"Introduction"},{"location":"csharp/create-class-from-clipboard/#creating-a-class-from-clipboard","text":"The Create Class From Clipboard tool does not currently support shared projects To use the Create Class From Clipboard tool, copy a valid C# class (with or without it's namespace and usings) to the clipboard. Next, right click on a project or project folder and beneath the Add menu, choose the Add Class Using Clipboard A window will now appear that previews the code that will be created. In this window we can change the following: Name: The name of the class. By default this is the name of the first class found in the clipboard Folder: The folder path where the new file will be placed. This will also control the namespace of the new class. When the Create Class From Clipboard window is launched, MFractor will automatically perform the following: Inspect the clipboards contents and use the name of the first class found as the file name. If no namespaces are declared, MFractor will wrap the class in a namespace based on the projects default namespace and the folder path the file is being placed into. If a namespace is defined, MFractor will correct it to use the project and folder path.","title":"Creating A Class From Clipboard"},{"location":"csharp/localisation/","text":"","title":"Localisation"},{"location":"csharp/code-actions/align-namespace-to-folder-path/","text":"Correct a files namespace so that it matches its folder path This feature is available in MFractor Professional Introduction The Align Namespace To Folder Path code action allows you to change a files namespaces so that it uses the projects default namespace joined with name of each folder. This code action allows you to correct a files namespace so that it represents the folder path it lives within the project. Consider the following project and folder path: MyCompany.MyApp.csproj (Default namespace: MyCompany.MyApp ) Services/ Login/ AuthenticationService.cs In AuthenticationService.cs , the contents are: namespace MyCompany.MyApp { public class AuthenticationService { } } The namespace in the AuthenticationService.cs file is MyCompany.MyApp , which differs to the folder path Services/Login/ . Using The Code Action This code action appears in quick actions menu when the cursor is placed on a namespace declaration that does not aligned to the ProjectDefaultNamespace.FolderPath structure. After confirming the code action, MFractor will change the namespace to use the project default namespace and each folder the file is placed within:","title":"Align Namespace To Folder Path"},{"location":"csharp/code-actions/align-namespace-to-folder-path/#introduction","text":"The Align Namespace To Folder Path code action allows you to change a files namespaces so that it uses the projects default namespace joined with name of each folder. This code action allows you to correct a files namespace so that it represents the folder path it lives within the project. Consider the following project and folder path: MyCompany.MyApp.csproj (Default namespace: MyCompany.MyApp ) Services/ Login/ AuthenticationService.cs In AuthenticationService.cs , the contents are: namespace MyCompany.MyApp { public class AuthenticationService { } } The namespace in the AuthenticationService.cs file is MyCompany.MyApp , which differs to the folder path Services/Login/ .","title":"Introduction"},{"location":"csharp/code-actions/align-namespace-to-folder-path/#using-the-code-action","text":"This code action appears in quick actions menu when the cursor is placed on a namespace declaration that does not aligned to the ProjectDefaultNamespace.FolderPath structure. After confirming the code action, MFractor will change the namespace to use the project default namespace and each folder the file is placed within:","title":"Using The Code Action"},{"location":"csharp/code-actions/convert-to-interpolated-string/","text":"Quickly convert a string literal to a interpolated string This feature is available in MFractor Professional Introduction When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string. Using The Code Action To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Convert To Interpolated String"},{"location":"csharp/code-actions/convert-to-interpolated-string/#introduction","text":"When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string.","title":"Introduction"},{"location":"csharp/code-actions/convert-to-interpolated-string/#using-the-code-action","text":"To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Using The Code Action"},{"location":"csharp/code-actions/copy-var-type-to-clipboard/","text":"Copy the fully qualified type represented by a var to the clipboard This feature is available in MFractor Professional Introduction The var keyword is a powerful C# langauge element that removes the need to explicitly declare local variable types, improving the readability and maintainability of your code. However, there are sometimes cases when you need to know the type stored by a var in order to reuse it in other parts of your code base. To solve this problem, MFractor includes the Copy var type to clipbaord code action to copy the fully qualifed type stored by a var expression to the clipboard.. Using The Code Action To use the code action, locate a var expression and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Copy type name to clipboard .","title":"Copy Var Type To Clipboard"},{"location":"csharp/code-actions/copy-var-type-to-clipboard/#introduction","text":"The var keyword is a powerful C# langauge element that removes the need to explicitly declare local variable types, improving the readability and maintainability of your code. However, there are sometimes cases when you need to know the type stored by a var in order to reuse it in other parts of your code base. To solve this problem, MFractor includes the Copy var type to clipbaord code action to copy the fully qualifed type stored by a var expression to the clipboard..","title":"Introduction"},{"location":"csharp/code-actions/copy-var-type-to-clipboard/#using-the-code-action","text":"To use the code action, locate a var expression and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Copy type name to clipboard .","title":"Using The Code Action"},{"location":"csharp/code-actions/create-lazy-accessor/","text":"Create a property to access the result of a Lazy<T> field This feature is available in MFractor Professional Introduction In C#, developers can use the Lazy<T> feature to only initialise objects when they are used. This allows developers to defer the creation or resolution cost of components and make the creation of objects much faster. To access the resultant object of a Lazy<T> , developers use the .Value property. When using class fields that use Lazy<T> , MFractor includes the Create Lazy Accessor refactoring to simplify the usage of Lazy. For example, rather than always using .Value to access the inner object and then perform an action, it is common to provide a helper property that evaluates the lazy field and returns the value. Let's consider the following code: readonly Lazy<INavigation> navigation; // Usage... await navigation.Value.PushAsync(new LoginPage()); Each time the navigation field is used, we then need to invoke the .Value property to call a method on INavigation . While we get the benefits of Lazy<T> , we also pollute our code with the .Value property each time we need to use INavigation . We can create a property that accesses the value of navigation and cleanup our code base: readonly Lazy<INavigation> navigation; INavigation Navigation => navigation.Value; // Usage... await Navigation.PushAsync(new LoginPage()); Using the Code Action To use the Create Lazy Accessor code action, place the cursor over a field declaration that uses Lazy<T> press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Create a property that accesses this fields value . MFractor will then create a wrapper property that accesses the .Value property of our field.","title":"Create Lazy Accessor"},{"location":"csharp/code-actions/create-lazy-accessor/#introduction","text":"In C#, developers can use the Lazy<T> feature to only initialise objects when they are used. This allows developers to defer the creation or resolution cost of components and make the creation of objects much faster. To access the resultant object of a Lazy<T> , developers use the .Value property. When using class fields that use Lazy<T> , MFractor includes the Create Lazy Accessor refactoring to simplify the usage of Lazy. For example, rather than always using .Value to access the inner object and then perform an action, it is common to provide a helper property that evaluates the lazy field and returns the value. Let's consider the following code: readonly Lazy<INavigation> navigation; // Usage... await navigation.Value.PushAsync(new LoginPage()); Each time the navigation field is used, we then need to invoke the .Value property to call a method on INavigation . While we get the benefits of Lazy<T> , we also pollute our code with the .Value property each time we need to use INavigation . We can create a property that accesses the value of navigation and cleanup our code base: readonly Lazy<INavigation> navigation; INavigation Navigation => navigation.Value; // Usage... await Navigation.PushAsync(new LoginPage());","title":"Introduction"},{"location":"csharp/code-actions/create-lazy-accessor/#using-the-code-action","text":"To use the Create Lazy Accessor code action, place the cursor over a field declaration that uses Lazy<T> press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Create a property that accesses this fields value . MFractor will then create a wrapper property that accesses the .Value property of our field.","title":"Using the Code Action"},{"location":"csharp/code-actions/generate-interface-implementation/","text":"Generate a class stub implementation for an interface This feature is available in MFractor Professional Introduction The Generate Implementation for Interface code action generates a class that implements stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation. Using the Code Action This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. This code action can be invoked from an interface declaration, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the IntelliSense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened in the code editor.","title":"Generate Interface Implementation"},{"location":"csharp/code-actions/generate-interface-implementation/#introduction","text":"The Generate Implementation for Interface code action generates a class that implements stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation.","title":"Introduction"},{"location":"csharp/code-actions/generate-interface-implementation/#using-the-code-action","text":"This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. This code action can be invoked from an interface declaration, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the IntelliSense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened in the code editor.","title":"Using the Code Action"},{"location":"csharp/code-actions/generate-readonly-constructor/","text":"Create a constructor to initialise all readonly fields in a class or struct This feature is available in MFractor Professional Introduction In C#, developers can use immutability to prevent the state of objects from changing after initialisation. Immutability is useful as it helps to prevent bugs caused by unexpected state changes and simplifies threading considerations. To accomplish immutability in C#, we can use the readonly keyword on fields and use get -only properties. public class MyImmutable { public string ImmutableProperty { get; } public readonly string immutableField; public MyImmutable(string a, string b) { ImmutableProperty = a; immutableField = b; } } var instance = new MyImmutable(\"Hello\", \"World\"); // Valid, immutable field/property setup in constructor. instance.ImmutableProperty = \"Hello\"; // Invalid, compilation error. instance.immutableField = \"World\"; // Invalid, compilation error. When we build types that are immutable, readonly fields and properties may only be initialised in the types constructor. This means we must create a constructor to initialise all readonly members. To assist, MFractor provides the Generate Readonly Constructor refactoring to generate a constructor that inclues a parameter for each readonly member that initialises it. Using the Code Action To use the Generate Readonly Constructor code action, place the cursor over a type declaration and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Create constructor to initialise all readonly members . MFractor will then create a constructor to initialise each readonly property or field using a constructor argument.","title":"Generate ReadOnly Constructor"},{"location":"csharp/code-actions/generate-readonly-constructor/#introduction","text":"In C#, developers can use immutability to prevent the state of objects from changing after initialisation. Immutability is useful as it helps to prevent bugs caused by unexpected state changes and simplifies threading considerations. To accomplish immutability in C#, we can use the readonly keyword on fields and use get -only properties. public class MyImmutable { public string ImmutableProperty { get; } public readonly string immutableField; public MyImmutable(string a, string b) { ImmutableProperty = a; immutableField = b; } } var instance = new MyImmutable(\"Hello\", \"World\"); // Valid, immutable field/property setup in constructor. instance.ImmutableProperty = \"Hello\"; // Invalid, compilation error. instance.immutableField = \"World\"; // Invalid, compilation error. When we build types that are immutable, readonly fields and properties may only be initialised in the types constructor. This means we must create a constructor to initialise all readonly members. To assist, MFractor provides the Generate Readonly Constructor refactoring to generate a constructor that inclues a parameter for each readonly member that initialises it.","title":"Introduction"},{"location":"csharp/code-actions/generate-readonly-constructor/#using-the-code-action","text":"To use the Generate Readonly Constructor code action, place the cursor over a type declaration and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Create constructor to initialise all readonly members . MFractor will then create a constructor to initialise each readonly property or field using a constructor argument.","title":"Using the Code Action"},{"location":"csharp/code-actions/invert-event-handler/","text":"Toggle an event subscription between += and -= This feature is available in MFractor Professional Introduction The Invert Event Handler code action allows you to toggle an event subscription between a += to bind the event and -= to unbind the event. This code action is useful as you can quickly invert an event subscription to generate either the binding or unbinding code. Using the Code Action This code action appears in quick actions menu when the cursor is placed on the += or -= operator within an event subscription statement. Changing to a event binding statement Changing to a event unbinding statement","title":"Invert Event Handler"},{"location":"csharp/code-actions/invert-event-handler/#introduction","text":"The Invert Event Handler code action allows you to toggle an event subscription between a += to bind the event and -= to unbind the event. This code action is useful as you can quickly invert an event subscription to generate either the binding or unbinding code.","title":"Introduction"},{"location":"csharp/code-actions/invert-event-handler/#using-the-code-action","text":"This code action appears in quick actions menu when the cursor is placed on the += or -= operator within an event subscription statement. Changing to a event binding statement Changing to a event unbinding statement","title":"Using the Code Action"},{"location":"csharp/code-actions/locate-in-solution-explorer/","text":"Locate the project file in the solution pad for a given type declaration This feature is available in MFractor Professional Introduction When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration. Using The Code Action To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Locate In Solution Explorer"},{"location":"csharp/code-actions/locate-in-solution-explorer/#introduction","text":"When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration.","title":"Introduction"},{"location":"csharp/code-actions/locate-in-solution-explorer/#using-the-code-action","text":"To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Using The Code Action"},{"location":"csharp/code-actions/select-string-span/","text":"Select the span of a string literal in the C# code editor This feature is available in MFractor Professional Introduction When editing a string within C# code, sometimes you might need to copy the inner contents of a string literal to the clipboard. The standard keyboard shortcuts in Visual Studio allow selection of string parts by character, word or line, however, not by the string syntax element. To make it easier to select the inner contents of a string solve, MFractor includes the Select string span code action. Using The Code Action To use the code action, locate a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Select string span . MFractor will then set the editors selection to the inner bounds of the string literal.","title":"Select String Span"},{"location":"csharp/code-actions/select-string-span/#introduction","text":"When editing a string within C# code, sometimes you might need to copy the inner contents of a string literal to the clipboard. The standard keyboard shortcuts in Visual Studio allow selection of string parts by character, word or line, however, not by the string syntax element. To make it easier to select the inner contents of a string solve, MFractor includes the Select string span code action.","title":"Introduction"},{"location":"csharp/code-actions/select-string-span/#using-the-code-action","text":"To use the code action, locate a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Select string span . MFractor will then set the editors selection to the inner bounds of the string literal.","title":"Using The Code Action"},{"location":"csharp/code-actions/simplify-qualified-types/","text":"Generate a new using statement from a qualified type usage This feature is available in MFractor Professional Introduction In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System.IO.FileInfo fileInfo; // Qualified type is 'System.IO.FileInfo' var myTask = System.Threading.Tasks.Task.Run(); // Qualified type is 'System.Threading.Tasks.Task' To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System.IO; using System.Threading.Tasks; FileInfo fileInfo; var myTask = Task.Run(); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings. Using the Code Action To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name: The Simplify Types Wizard In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"Simplifying Qualified Types"},{"location":"csharp/code-actions/simplify-qualified-types/#introduction","text":"In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System.IO.FileInfo fileInfo; // Qualified type is 'System.IO.FileInfo' var myTask = System.Threading.Tasks.Task.Run(); // Qualified type is 'System.Threading.Tasks.Task' To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System.IO; using System.Threading.Tasks; FileInfo fileInfo; var myTask = Task.Run(); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings.","title":"Introduction"},{"location":"csharp/code-actions/simplify-qualified-types/#using-the-code-action","text":"To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name:","title":"Using the Code Action"},{"location":"csharp/code-actions/simplify-qualified-types/#the-simplify-types-wizard","text":"In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"The Simplify Types Wizard"},{"location":"fonts/fontfamily-xaml-entry/","text":"Inject the Font Family XAML entry for a font asset the Resource Dictionary of a Xamarin.Forms App Introduction Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: <ResourceDictionary> <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"OpenSans\" > <On Platform= \"iOS\" Value= \"OpenSans\" /> <On Platform= \"Android\" Value= \"OpenSans-Regular.ttf#Regular\" /> </OnPlatform> <!-- Other dictionary resources --> </ResourceDictionary> The Font Importer can add this to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customise the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.CustomFontPage\" > <StackLayout VerticalOptions= \"Center\" > <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> </StackLayout> </ContentPage> References Fonts in Xamarin.Forms","title":"FontFamily XAML Entry"},{"location":"fonts/fontfamily-xaml-entry/#introduction","text":"Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: <ResourceDictionary> <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"OpenSans\" > <On Platform= \"iOS\" Value= \"OpenSans\" /> <On Platform= \"Android\" Value= \"OpenSans-Regular.ttf#Regular\" /> </OnPlatform> <!-- Other dictionary resources --> </ResourceDictionary> The Font Importer can add this to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customise the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.CustomFontPage\" > <StackLayout VerticalOptions= \"Center\" > <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> </StackLayout> </ContentPage>","title":"Introduction"},{"location":"fonts/fontfamily-xaml-entry/#references","text":"Fonts in Xamarin.Forms","title":"References"},{"location":"fonts/generate-font-character-code-class/","text":"Create a helper class that includes named constants for all character codes in a font asset This feature is available in MFractor Professional Introduction When building mobile apps, we can use font glyphs instead of image assets for icons to simplify our codebase and make it more maintainable. There are several major benefits when using fonts for our iconography: Our app size becomes smaller by reducing the amount of image assetsin our app. Font icons are rendered vectors. You can be recolour and resize them in code. No need to wrangle many different image asset densities in your Android and iOS projects. However, a drawback of this approach is we need to refer to font glyphs by their unicode character like so: label.Text = \"/uf00c\"; This impacts code readability as it becomes difficult to understand what icon the code /uf00c translates to visually. To address this issue Android improve readability, it's best practice to use a helper class that contains a named constant for each glyph in the font. For example: FontAwesomeIcons.cs public class FontAwesomeIcons { // ... public const string Check = \"\\uf00c\"; public const string CheckCircle = \"\\uf058\"; public const string CheckDouble = \"\\uf560\"; public const string CheckSquare = \"\\uf14a\"; // ... } We can now use this class to reference a named constant when setting icons: label.Text = FontAwesome.FontAwesomeIcons.Check; It is now obvious that the icon is a check from FontAwesome, making the code cleaner, more readable and more maintainable. To help improve your code-bases readability by using a helper class for font icons, MFractor contains a Generate Font Glyph Code Class tool. Using the Generate Font Glyph Code Class tool Desktop Fonts vs Web Fonts When generating a glyph class, MFractor requires that the font asset be a Web Font . Typically, desktop font assets do not include the glyph names associated with a unicode characters whereas web fonts include these names to allow referencing by name via CSS. If the Generate Font Glyph Code Code tool does not generate a class, verify that the font asset is a web font. To use the Generate Font Glyph Code Class tool, locate a font asset (otf or ttf) in your solution, right click on it and choose Generate Font Glyph Glyph Class tool : MFractor will present a preview of the code it will generating and allow you to select the target project and change the class name. To generate the class, press Generate :","title":"Generate Font Glyph Code Class"},{"location":"fonts/generate-font-character-code-class/#introduction","text":"When building mobile apps, we can use font glyphs instead of image assets for icons to simplify our codebase and make it more maintainable. There are several major benefits when using fonts for our iconography: Our app size becomes smaller by reducing the amount of image assetsin our app. Font icons are rendered vectors. You can be recolour and resize them in code. No need to wrangle many different image asset densities in your Android and iOS projects. However, a drawback of this approach is we need to refer to font glyphs by their unicode character like so: label.Text = \"/uf00c\"; This impacts code readability as it becomes difficult to understand what icon the code /uf00c translates to visually. To address this issue Android improve readability, it's best practice to use a helper class that contains a named constant for each glyph in the font. For example: FontAwesomeIcons.cs public class FontAwesomeIcons { // ... public const string Check = \"\\uf00c\"; public const string CheckCircle = \"\\uf058\"; public const string CheckDouble = \"\\uf560\"; public const string CheckSquare = \"\\uf14a\"; // ... } We can now use this class to reference a named constant when setting icons: label.Text = FontAwesome.FontAwesomeIcons.Check; It is now obvious that the icon is a check from FontAwesome, making the code cleaner, more readable and more maintainable. To help improve your code-bases readability by using a helper class for font icons, MFractor contains a Generate Font Glyph Code Class tool.","title":"Introduction"},{"location":"fonts/generate-font-character-code-class/#using-the-generate-font-glyph-code-class-tool","text":"Desktop Fonts vs Web Fonts When generating a glyph class, MFractor requires that the font asset be a Web Font . Typically, desktop font assets do not include the glyph names associated with a unicode characters whereas web fonts include these names to allow referencing by name via CSS. If the Generate Font Glyph Code Code tool does not generate a class, verify that the font asset is a web font. To use the Generate Font Glyph Code Class tool, locate a font asset (otf or ttf) in your solution, right click on it and choose Generate Font Glyph Glyph Class tool : MFractor will present a preview of the code it will generating and allow you to select the target project and change the class name. To generate the class, press Generate :","title":"Using the Generate Font Glyph Code Class tool"},{"location":"fonts/importing-fonts/","text":"Add new assets into your Android and iOS applications This feature is available in MFractor Professional Introduction The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way. Using the Font Importer The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Importing Fonts"},{"location":"fonts/importing-fonts/#introduction","text":"The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way.","title":"Introduction"},{"location":"fonts/importing-fonts/#using-the-font-importer","text":"The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Using the Font Importer"},{"location":"fonts/uiappfonts-plist-entry/","text":"Inject the UIAppFonts entry for a font asset into the info.plist Introduction When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: <key> UIAppFonts </key> <array> <string> OpenSans-Regular.ttf </string> </array> You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button . Example of using custom font in UIKit","title":"UIAppFonts Entry"},{"location":"fonts/uiappfonts-plist-entry/#introduction","text":"When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: <key> UIAppFonts </key> <array> <string> OpenSans-Regular.ttf </string> </array> You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button .","title":"Introduction"},{"location":"fonts/uiappfonts-plist-entry/#example-of-using-custom-font-in-uikit","text":"","title":"Example of using custom font in UIKit"},{"location":"image-management/deleting-image-assets/","text":"Remove all traces of image assets from your Android and iOS projects Introduction The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Identifying Image Assets Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view. Android When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable/logo.xml drawable-ldpi/logo.png drawable-mdpi/logo.png drawable-hdpi/logo.png drawable-night-mdpi/logo.png (dark mode version) drawable-landscape-hdpi/logo.png (landscape version ) mipmap-de-ldpi/logo.png (Deutsch translation) mipmap-ldpi/logo.png mipmap-mdpi/logo.png mipmap-hdpi/logo1.png MFractor would delete the following assets: drawable-ldpi/logo.png drawable-night-mdpi/logo.png drawable-landscape-hdpi/logo.png mipmap-de-ldpi/logo.png mipmap-ldpi/logo.png mipmap-mdpi/logo.png MFractor would ignore the following assets: drawable/logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/logo1.png (Excluded as logo1 is not a match with logo). iOS The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog. Deleting stand-alone images MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources/logo.png Resources/logo@2x.png Resources/logo@3x.png Resources/logo1@2x.png Resources/logo2@3x.png The deletion tool will track and delete the following files as the image set of the logo asset: Resources/logo.png Resources/logo@2x.png Resources/logo@3x.png MFractor will ignore the following files: Resources/logo1@2x.png (Excluded as logo1 is not a match with logo) Resources/logo2@3x.png (Excluded as logo2 is not a match with logo) Deleting images from Asset Catalogs For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets.xcassets/logo.imageset/logo.png Assets.xcassets/logo.imageset/logo@2x.png Assets.xcassets/logo.imageset/logo@3x.png Assets.xcassets/logo.imageset/sample.png Assets.xcassets/logo.imageset/sample@3x.png Assets.xcassets/logo.imageset/other.png Assets.xcassets/logo.imageset/other@2x.png Assets.xcassets/logo.imageset/Contents.json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { \"images\" : [ { \"filename\" : \"logo.png\" , \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@2x.png\" , \"scale\" : \"2x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@3x.png\" , \"scale\" : \"3x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample@3x.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"3x\" , \"idiom\" : \"universal\" } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets.xcassets/logo.imageset/logo.png Assets.xcassets/logo.imageset/logo@2x.png Assets.xcassets/logo.imageset/logo@3x.png Assets.xcassets/logo.imageset/sample.png Assets.xcassets/logo.imageset/sample@3x.png Assets.xcassets/logo.imageset/Contents.json (metadata file is also deleted because its part of the asset definition) MFractor will ignore the following files: Assets.xcassets/logo.imageset/other.png (Not listed in the Contents.json file) Assets.xcassets/logo.imageset/other@2x.png (Not listed in the Contents.json file) Launching The Deletion Tool Solution Explorer The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option. Image Asset Manager The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane. Using The Deletion Tool After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Deleting Image Assets"},{"location":"image-management/deleting-image-assets/#introduction","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently.","title":"Introduction"},{"location":"image-management/deleting-image-assets/#identifying-image-assets","text":"Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view.","title":"Identifying Image Assets"},{"location":"image-management/deleting-image-assets/#android","text":"When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable/logo.xml drawable-ldpi/logo.png drawable-mdpi/logo.png drawable-hdpi/logo.png drawable-night-mdpi/logo.png (dark mode version) drawable-landscape-hdpi/logo.png (landscape version ) mipmap-de-ldpi/logo.png (Deutsch translation) mipmap-ldpi/logo.png mipmap-mdpi/logo.png mipmap-hdpi/logo1.png MFractor would delete the following assets: drawable-ldpi/logo.png drawable-night-mdpi/logo.png drawable-landscape-hdpi/logo.png mipmap-de-ldpi/logo.png mipmap-ldpi/logo.png mipmap-mdpi/logo.png MFractor would ignore the following assets: drawable/logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/logo1.png (Excluded as logo1 is not a match with logo).","title":"Android"},{"location":"image-management/deleting-image-assets/#ios","text":"The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog.","title":"iOS"},{"location":"image-management/deleting-image-assets/#deleting-stand-alone-images","text":"MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources/logo.png Resources/logo@2x.png Resources/logo@3x.png Resources/logo1@2x.png Resources/logo2@3x.png The deletion tool will track and delete the following files as the image set of the logo asset: Resources/logo.png Resources/logo@2x.png Resources/logo@3x.png MFractor will ignore the following files: Resources/logo1@2x.png (Excluded as logo1 is not a match with logo) Resources/logo2@3x.png (Excluded as logo2 is not a match with logo)","title":"Deleting stand-alone images"},{"location":"image-management/deleting-image-assets/#deleting-images-from-asset-catalogs","text":"For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets.xcassets/logo.imageset/logo.png Assets.xcassets/logo.imageset/logo@2x.png Assets.xcassets/logo.imageset/logo@3x.png Assets.xcassets/logo.imageset/sample.png Assets.xcassets/logo.imageset/sample@3x.png Assets.xcassets/logo.imageset/other.png Assets.xcassets/logo.imageset/other@2x.png Assets.xcassets/logo.imageset/Contents.json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { \"images\" : [ { \"filename\" : \"logo.png\" , \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@2x.png\" , \"scale\" : \"2x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@3x.png\" , \"scale\" : \"3x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample@3x.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"3x\" , \"idiom\" : \"universal\" } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets.xcassets/logo.imageset/logo.png Assets.xcassets/logo.imageset/logo@2x.png Assets.xcassets/logo.imageset/logo@3x.png Assets.xcassets/logo.imageset/sample.png Assets.xcassets/logo.imageset/sample@3x.png Assets.xcassets/logo.imageset/Contents.json (metadata file is also deleted because its part of the asset definition) MFractor will ignore the following files: Assets.xcassets/logo.imageset/other.png (Not listed in the Contents.json file) Assets.xcassets/logo.imageset/other@2x.png (Not listed in the Contents.json file)","title":"Deleting images from Asset Catalogs"},{"location":"image-management/deleting-image-assets/#launching-the-deletion-tool","text":"","title":"Launching The Deletion Tool"},{"location":"image-management/deleting-image-assets/#solution-explorer","text":"The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option.","title":"Solution Explorer"},{"location":"image-management/deleting-image-assets/#image-asset-manager","text":"The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane.","title":"Image Asset Manager"},{"location":"image-management/deleting-image-assets/#using-the-deletion-tool","text":"After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Using The Deletion Tool"},{"location":"image-management/image-importer/","text":"Add new image assets into your Android and iOS applications Introduction The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets. Using the Image Importer The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next. Target Projects MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images. Setting the Image Size The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image. Import Image When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Importing Images"},{"location":"image-management/image-importer/#introduction","text":"The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets.","title":"Introduction"},{"location":"image-management/image-importer/#using-the-image-importer","text":"The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next.","title":"Using the Image Importer"},{"location":"image-management/image-importer/#target-projects","text":"MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images.","title":"Target Projects"},{"location":"image-management/image-importer/#setting-the-image-size","text":"The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image.","title":"Setting the Image Size"},{"location":"image-management/image-importer/#import-image","text":"When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Import Image"},{"location":"image-management/image-tooltips/","text":"Visualise the image asset a piece of code is referencing Introduction The Image Tooltips let you preview any image asset. Using Image Tooltips Simply hover your cursor over an image name and a preview of that image will display. We even offer previews of image assets in IntelliSense! XAML Add your Image tag to your xaml file and edit the Source attribute to see the tooltip, or \"Import an image asset\". <Image Source=\"\" /> Even better, image tooltips are also supported on Android resource lookups in C#: Android var dd = Resource . Drawable . mfractor Links See the announcement in the Blog ( GitHub ).","title":"Image Tooltips"},{"location":"image-management/image-tooltips/#introduction","text":"The Image Tooltips let you preview any image asset.","title":"Introduction"},{"location":"image-management/image-tooltips/#using-image-tooltips","text":"Simply hover your cursor over an image name and a preview of that image will display. We even offer previews of image assets in IntelliSense!","title":"Using Image Tooltips"},{"location":"image-management/image-tooltips/#xaml","text":"Add your Image tag to your xaml file and edit the Source attribute to see the tooltip, or \"Import an image asset\". <Image Source=\"\" /> Even better, image tooltips are also supported on Android resource lookups in C#: Android var dd = Resource . Drawable . mfractor","title":"XAML"},{"location":"image-management/image-tooltips/#links","text":"See the announcement in the Blog ( GitHub ).","title":"Links"},{"location":"image-management/managing-image-assets/","text":"A centralised location to easily manage the image assets in your mobile solution Introduction The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Opening The Image Manager The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden: Top Menu By acessing the top menu selecting the Manage Image Assets options. Solution Pad You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list. Overview What is an image asset? MFractor works with the concept of Image Assets , where a single asset is composed by a set of files that represent a single image at each possible density supported by Android or iOS devices. This concept is implemented to facilitate managing those assets, because a single item may be represented by a large number of individual files, that can also be shared among projects. For this documentation, every time we use the term Image Asset , we are refering the set of images that form a single element as consumed by the user interface engines of the platforms, and we will use the term Asset File to refer to a specific item of this set. The Image Manager Pad is composed of the following parts: The Assets List : the main listing on the left side of the pane contains all the image assets identified by MFractor in the current solution. The list consider an asset a set of images that compose a single image as recognized by an Android or iOS project. The List of Assets File : when you select an asset from the previous list, MFractor will list the files that compose this asset in this section. Further grouping is provided by project on the Combo Box on the top of this list, where you can select the project of which you want list the files of the asset. The list provides the image size aside with it's path in the solution. The Preview Area : just above the listing of asset files on the Asset, you'll find the preview of the currently selected file along with some metadata of the image: it's current file size and dimensions. The Commands Area : you'll find buttons for the commands available to the image assets on the bottom area of the assets listing. Filtering Image assets You can filter image assets using the search bar on the top of the listing. Start typing and MFractor will filter the items that contains the text you've typed. Note The filtering tool is case-sensitive. Importing Image Assets Click on the Import New Image Asset on the bottom part of the pad to open the Import Image Asset tool. See the section docs for instructions on how to import images. Deleting Image Assets You can delete an Image Asset by selecting the image on the assets list and clicking on the Delete image name on the bottom of the listing. This will present the Delete Image Asset tool dialog, that previews the delete operations that will be run for that asset. You can also right click on a asset of the list and select Delete from the context menu. Click Delete Images button to confirm the operation. Tip For further information about the MFractor Delete Image Asset tool see the docs of the feature . Optimising Image Assets Through the Image Asset Manager you can optimise the all images of your solution, a single Image Asset or a specific Asset File. Please check the Optimising Image Assets docs for details on how to setup image optimization and launch it for the desired items of your solution. Searching For Image Asset Usages The Image Asset Manager allows you to search for places where an Image Asset is referenced in your solutions code. Warning This feature is currently in preview and will search for the exact name of the asset. This may not detect all usages of this image resource and may detect false positives. To Invoke the Search Usage feature you should use the context menu over the Image Asset you want to do the search and select the Find Usages option. MFractor will present the results on the Search Results Pane on the bottom area of the IDE. Drag And Drop The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ; Context Actions In both the Image Assets list and the Asset Files list, you may right click on any item to launch a context menu that may provide the following options: Delete Please see Deleting Image Assets Reveal In Finder/Explorer The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image. Reveal In Project Pad The Reveal Project Pad action will locate the image file in the solution pad. Copy Name To Clipboard The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard. Copy File Path To Clipboard The Copy File Path To Clipboard action copies the file path of that image file to the clipboard. Optimise Please see Optimising Image Assets Open Image The Open action opens the selected image file in the operating systems default image viewer. Search For Usages Please see Searching For Image Asset Usages","title":"Managing Images Assets"},{"location":"image-management/managing-image-assets/#introduction","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location.","title":"Introduction"},{"location":"image-management/managing-image-assets/#opening-the-image-manager","text":"The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden:","title":"Opening The Image Manager"},{"location":"image-management/managing-image-assets/#top-menu","text":"By acessing the top menu selecting the Manage Image Assets options.","title":"Top Menu"},{"location":"image-management/managing-image-assets/#solution-pad","text":"You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list.","title":"Solution Pad"},{"location":"image-management/managing-image-assets/#overview","text":"What is an image asset? MFractor works with the concept of Image Assets , where a single asset is composed by a set of files that represent a single image at each possible density supported by Android or iOS devices. This concept is implemented to facilitate managing those assets, because a single item may be represented by a large number of individual files, that can also be shared among projects. For this documentation, every time we use the term Image Asset , we are refering the set of images that form a single element as consumed by the user interface engines of the platforms, and we will use the term Asset File to refer to a specific item of this set. The Image Manager Pad is composed of the following parts: The Assets List : the main listing on the left side of the pane contains all the image assets identified by MFractor in the current solution. The list consider an asset a set of images that compose a single image as recognized by an Android or iOS project. The List of Assets File : when you select an asset from the previous list, MFractor will list the files that compose this asset in this section. Further grouping is provided by project on the Combo Box on the top of this list, where you can select the project of which you want list the files of the asset. The list provides the image size aside with it's path in the solution. The Preview Area : just above the listing of asset files on the Asset, you'll find the preview of the currently selected file along with some metadata of the image: it's current file size and dimensions. The Commands Area : you'll find buttons for the commands available to the image assets on the bottom area of the assets listing.","title":"Overview"},{"location":"image-management/managing-image-assets/#filtering-image-assets","text":"You can filter image assets using the search bar on the top of the listing. Start typing and MFractor will filter the items that contains the text you've typed. Note The filtering tool is case-sensitive.","title":"Filtering Image assets"},{"location":"image-management/managing-image-assets/#importing-image-assets","text":"Click on the Import New Image Asset on the bottom part of the pad to open the Import Image Asset tool. See the section docs for instructions on how to import images.","title":"Importing Image Assets"},{"location":"image-management/managing-image-assets/#deleting-image-assets","text":"You can delete an Image Asset by selecting the image on the assets list and clicking on the Delete image name on the bottom of the listing. This will present the Delete Image Asset tool dialog, that previews the delete operations that will be run for that asset. You can also right click on a asset of the list and select Delete from the context menu. Click Delete Images button to confirm the operation. Tip For further information about the MFractor Delete Image Asset tool see the docs of the feature .","title":"Deleting Image Assets"},{"location":"image-management/managing-image-assets/#optimising-image-assets","text":"Through the Image Asset Manager you can optimise the all images of your solution, a single Image Asset or a specific Asset File. Please check the Optimising Image Assets docs for details on how to setup image optimization and launch it for the desired items of your solution.","title":"Optimising Image Assets"},{"location":"image-management/managing-image-assets/#searching-for-image-asset-usages","text":"The Image Asset Manager allows you to search for places where an Image Asset is referenced in your solutions code. Warning This feature is currently in preview and will search for the exact name of the asset. This may not detect all usages of this image resource and may detect false positives. To Invoke the Search Usage feature you should use the context menu over the Image Asset you want to do the search and select the Find Usages option. MFractor will present the results on the Search Results Pane on the bottom area of the IDE.","title":"Searching For Image Asset Usages"},{"location":"image-management/managing-image-assets/#drag-and-drop","text":"The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ;","title":"Drag And Drop"},{"location":"image-management/managing-image-assets/#context-actions","text":"In both the Image Assets list and the Asset Files list, you may right click on any item to launch a context menu that may provide the following options:","title":"Context Actions"},{"location":"image-management/managing-image-assets/#delete","text":"Please see Deleting Image Assets","title":"Delete"},{"location":"image-management/managing-image-assets/#reveal-in-finderexplorer","text":"The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image.","title":"Reveal In Finder/Explorer"},{"location":"image-management/managing-image-assets/#reveal-in-project-pad","text":"The Reveal Project Pad action will locate the image file in the solution pad.","title":"Reveal In Project Pad"},{"location":"image-management/managing-image-assets/#copy-name-to-clipboard","text":"The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard.","title":"Copy Name To Clipboard"},{"location":"image-management/managing-image-assets/#copy-file-path-to-clipboard","text":"The Copy File Path To Clipboard action copies the file path of that image file to the clipboard.","title":"Copy File Path To Clipboard"},{"location":"image-management/managing-image-assets/#optimise","text":"Please see Optimising Image Assets","title":"Optimise"},{"location":"image-management/managing-image-assets/#open-image","text":"The Open action opens the selected image file in the operating systems default image viewer.","title":"Open Image"},{"location":"image-management/managing-image-assets/#search-for-usages","text":"Please see Searching For Image Asset Usages","title":"Search For Usages"},{"location":"image-management/optimising-image-assets/","text":"Reducing the size your image assets using the image optimiser Introduction MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries. Configuring TinyPNG API Key MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key. Launching The Optimiser The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution. To optimise a single image file Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise To optimise all files of an asset Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise To optimise all images To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user. Processing the files Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Optimising Image Assets"},{"location":"image-management/optimising-image-assets/#introduction","text":"MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries.","title":"Introduction"},{"location":"image-management/optimising-image-assets/#configuring-tinypng-api-key","text":"MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key.","title":"Configuring TinyPNG API Key"},{"location":"image-management/optimising-image-assets/#launching-the-optimiser","text":"The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution.","title":"Launching The Optimiser"},{"location":"image-management/optimising-image-assets/#to-optimise-a-single-image-file","text":"Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise","title":"To optimise a single image file"},{"location":"image-management/optimising-image-assets/#to-optimise-all-files-of-an-asset","text":"Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise","title":"To optimise all files of an asset"},{"location":"image-management/optimising-image-assets/#to-optimise-all-images","text":"To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user.","title":"To optimise all images"},{"location":"image-management/optimising-image-assets/#processing-the-files","text":"Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Processing the files"},{"location":"image-management/overview/","text":"Use MFractors image management suite to import, delete, optimise and manage the image assets in your iOS and Android apps Image Management Tool Suite Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features: Image Asset Manager The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets . Image Importer The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets . Image Deletion Tool The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets . Image Optimiser The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets . Image Tooltips The image tooltips let you preview any image asset. Read more about image tooltips at Image Tooltips . Third Party Image Tooling Support MFractor includes built-in image management support for the following third-party tools: Mobile.BuildTools . ResizetizerNT .","title":"Overview"},{"location":"image-management/overview/#image-management-tool-suite","text":"Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features:","title":"Image Management Tool Suite"},{"location":"image-management/overview/#image-asset-manager","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets .","title":"Image Asset Manager"},{"location":"image-management/overview/#image-importer","text":"The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets .","title":"Image Importer"},{"location":"image-management/overview/#image-deletion-tool","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets .","title":"Image Deletion Tool"},{"location":"image-management/overview/#image-optimiser","text":"The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Image Optimiser"},{"location":"image-management/overview/#image-tooltips","text":"The image tooltips let you preview any image asset. Read more about image tooltips at Image Tooltips .","title":"Image Tooltips"},{"location":"image-management/overview/#third-party-image-tooling-support","text":"MFractor includes built-in image management support for the following third-party tools: Mobile.BuildTools . ResizetizerNT .","title":"Third Party Image Tooling Support"},{"location":"image-management/third-party/mobile-build-tools/","text":"An overview of MFractors built-in support for Mobile.BuildTools Overview Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline designed specifically for the challenges of Xamarin.Forms development. Mobile.BuildTools exposes several useful build tasks to assist in Xamarin.Forms development, including a task that generates Android and iOS images from a single source image. MFractor automatically detects solutions that include a Mobile.BuildTools manifest and includes the image generation output into the image management engine. This activates MFractors image tool-suite (such as IntelliSense, tooltips, analysis etc) in projects that utilise the Mobile.BuildTools build tasks. Learn more about Mobile.BuildTools here.","title":"Mobile.BuildTools"},{"location":"image-management/third-party/mobile-build-tools/#overview","text":"Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline designed specifically for the challenges of Xamarin.Forms development. Mobile.BuildTools exposes several useful build tasks to assist in Xamarin.Forms development, including a task that generates Android and iOS images from a single source image. MFractor automatically detects solutions that include a Mobile.BuildTools manifest and includes the image generation output into the image management engine. This activates MFractors image tool-suite (such as IntelliSense, tooltips, analysis etc) in projects that utilise the Mobile.BuildTools build tasks. Learn more about Mobile.BuildTools here.","title":"Overview"},{"location":"image-management/third-party/resizetizer/","text":"An overview of MFractors built-in support for ResizetizerNT Overview Take SVG's and PNG's and automagically have them resized to all the different resolutions and included in your Xamarin Android, iOS, UWP, and WPF projects! ResizetizerNT is an MSBuild task to automatically generate resized image artefacts for Android and iOS from a shared project. MFractor automatically detects image assets that are defined using the SharedImage element in your .csproj files and includes them into the image management engine. This activates MFractors image tool-suite (such as IntelliSense, tooltips, analysis etc) in projects that utilise the ResizetizerNT build tasks. Learn more about ResizetizerNT here.","title":"ResizetizerNT"},{"location":"image-management/third-party/resizetizer/#overview","text":"Take SVG's and PNG's and automagically have them resized to all the different resolutions and included in your Xamarin Android, iOS, UWP, and WPF projects! ResizetizerNT is an MSBuild task to automatically generate resized image artefacts for Android and iOS from a shared project. MFractor automatically detects image assets that are defined using the SharedImage element in your .csproj files and includes them into the image management engine. This activates MFractors image tool-suite (such as IntelliSense, tooltips, analysis etc) in projects that utilise the ResizetizerNT build tasks. Learn more about ResizetizerNT here.","title":"Overview"},{"location":"ios/tools/copy-bundle-id/","text":"Quickly copy the Bundle Identifier of an iOS Project. This feature is available in MFractor Professional Introduction When developing iOS apps you often need to copy the Bundle Identifier of the app to setup store publishing or platforms like Firebase. The Copy iOS Bundle ID to Clipboard tool allows you to quickly copy this information from any iOS project in your solution. To access this command: On macOS : right-click on the iOS project on the Solution Pad . Under the Tools menu you'll find the Copy Bundle Id to Clipboard option. On Windows : right-click on the iOS project on the Solution Explorer , the Copy Bundle Id to Clipboard will appear on the second section of the menu. The project Package ID (as defined on the info.plist file) will be copied to your clipboard. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Copy Bundle ID"},{"location":"ios/tools/copy-bundle-id/#introduction","text":"When developing iOS apps you often need to copy the Bundle Identifier of the app to setup store publishing or platforms like Firebase. The Copy iOS Bundle ID to Clipboard tool allows you to quickly copy this information from any iOS project in your solution. To access this command: On macOS : right-click on the iOS project on the Solution Pad . Under the Tools menu you'll find the Copy Bundle Id to Clipboard option. On Windows : right-click on the iOS project on the Solution Explorer , the Copy Bundle Id to Clipboard will appear on the second section of the menu. The project Package ID (as defined on the info.plist file) will be copied to your clipboard. Tip If the option doesn't appear try to Resync MFractor Solution Resources .","title":"Introduction"},{"location":"legal/third-party-software/","text":"Attribution to the third party software and libraries used by MFractor Introduction This document lists the third party software and libraries used by MFractor. Third Party Attribution Android Robot Icon Url: https://developer.android.com/distribute/marketing-tools/brand-guidelines#android_robot License (Creative Commons): https://creativecommons.org/licenses/by/3.0/legalcode Microsoft.ApplicationInsights URL: https://github.com/Microsoft/ApplicationInsights-Home License (MIT): https://github.com/microsoft/ApplicationInsights-Home/blob/master/LICENSE Newtonsoft.Json URL: https://www.newtonsoft.com/json License (MIT): https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md Open Toolkit Library URL: https://github.com/opentk/opentk License (MIT): https://github.com/opentk/opentk/blob/master/LICENSE.md PeaPdf URL: https://github.com/elicym/peapdf License (Apache 2): https://github.com/elicym/peapdf/blob/master/LICENSE Portable.Licensing URL: https://github.com/dnauck/Portable.Licensing License (MIT): https://github.com/dnauck/Portable.Licensing/blob/develop/LICENSE.md SkiaSharp URL: https://github.com/mono/SkiaSharp License (MIT): https://github.com/mono/SkiaSharp/blob/master/LICENSE.md Typography URL: https://github.com/LayoutFarm/Typography License (MIT): https://github.com/LayoutFarm/Typography/blob/master/LICENSE.md tinify-net URL: https://github.com/tinify/tinify-net License (MIT): https://github.com/tinify/tinify-net/blob/master/LICENSE WebKit Sharp URL: https://github.com/mono/webkit-sharp License (Novell): Novell License XmlParser URL: https://github.com/KirillOsenkov/XmlParser License (Apache License 2.0): https://github.com/KirillOsenkov/XmlParser/blob/master/LICENSE","title":"Third Party Software"},{"location":"legal/third-party-software/#introduction","text":"This document lists the third party software and libraries used by MFractor.","title":"Introduction"},{"location":"legal/third-party-software/#third-party-attribution","text":"","title":"Third Party Attribution"},{"location":"legal/third-party-software/#android-robot-icon","text":"Url: https://developer.android.com/distribute/marketing-tools/brand-guidelines#android_robot License (Creative Commons): https://creativecommons.org/licenses/by/3.0/legalcode","title":"Android Robot Icon"},{"location":"legal/third-party-software/#microsoftapplicationinsights","text":"URL: https://github.com/Microsoft/ApplicationInsights-Home License (MIT): https://github.com/microsoft/ApplicationInsights-Home/blob/master/LICENSE","title":"Microsoft.ApplicationInsights"},{"location":"legal/third-party-software/#newtonsoftjson","text":"URL: https://www.newtonsoft.com/json License (MIT): https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md","title":"Newtonsoft.Json"},{"location":"legal/third-party-software/#open-toolkit-library","text":"URL: https://github.com/opentk/opentk License (MIT): https://github.com/opentk/opentk/blob/master/LICENSE.md","title":"Open Toolkit Library"},{"location":"legal/third-party-software/#peapdf","text":"URL: https://github.com/elicym/peapdf License (Apache 2): https://github.com/elicym/peapdf/blob/master/LICENSE","title":"PeaPdf"},{"location":"legal/third-party-software/#portablelicensing","text":"URL: https://github.com/dnauck/Portable.Licensing License (MIT): https://github.com/dnauck/Portable.Licensing/blob/develop/LICENSE.md","title":"Portable.Licensing"},{"location":"legal/third-party-software/#skiasharp","text":"URL: https://github.com/mono/SkiaSharp License (MIT): https://github.com/mono/SkiaSharp/blob/master/LICENSE.md","title":"SkiaSharp"},{"location":"legal/third-party-software/#typography","text":"URL: https://github.com/LayoutFarm/Typography License (MIT): https://github.com/LayoutFarm/Typography/blob/master/LICENSE.md","title":"Typography"},{"location":"legal/third-party-software/#tinify-net","text":"URL: https://github.com/tinify/tinify-net License (MIT): https://github.com/tinify/tinify-net/blob/master/LICENSE","title":"tinify-net"},{"location":"legal/third-party-software/#webkit-sharp","text":"URL: https://github.com/mono/webkit-sharp License (Novell): Novell License","title":"WebKit Sharp"},{"location":"legal/third-party-software/#xmlparser","text":"URL: https://github.com/KirillOsenkov/XmlParser License (Apache License 2.0): https://github.com/KirillOsenkov/XmlParser/blob/master/LICENSE","title":"XmlParser"},{"location":"linker/excluding-symbols-from-linker/","text":"Exclude assemblies, classes or members from the Xamarin linker Introduction The Linker 101 Define what the linker is? Why do we use it? Using Exclude From Linker Excluding Assemblies Excluding Types Exclude Members","title":"Excluding symbols from linker"},{"location":"linker/excluding-symbols-from-linker/#introduction","text":"The","title":"Introduction"},{"location":"linker/excluding-symbols-from-linker/#linker-101","text":"Define what the linker is? Why do we use it?","title":"Linker 101"},{"location":"linker/excluding-symbols-from-linker/#using-exclude-from-linker","text":"","title":"Using Exclude From Linker"},{"location":"linker/excluding-symbols-from-linker/#excluding-assemblies","text":"","title":"Excluding Assemblies"},{"location":"linker/excluding-symbols-from-linker/#excluding-types","text":"","title":"Excluding Types"},{"location":"linker/excluding-symbols-from-linker/#exclude-members","text":"","title":"Exclude Members"},{"location":"linker/linker-intellisense/","text":"Using the Linker.xml IntelliSense to exclude assemblies, classes or members from the Xamarin linker Introduction Linker IntelliSense","title":"Linker intellisense"},{"location":"linker/linker-intellisense/#introduction","text":"","title":"Introduction"},{"location":"linker/linker-intellisense/#linker-intellisense","text":"","title":"Linker IntelliSense"},{"location":"linker/linker-introduction/","text":"An introduction to the Xamarin linker\\ Introduction The Linker 101 Define what the linker is? Why do we use it? Linker source code: https://github.com/mono/linker Excluding Assemblies Excluding Types Exclude Members","title":"Linker introduction"},{"location":"linker/linker-introduction/#introduction","text":"The","title":"Introduction"},{"location":"linker/linker-introduction/#linker-101","text":"Define what the linker is? Why do we use it? Linker source code: https://github.com/mono/linker","title":"Linker 101"},{"location":"linker/linker-introduction/#excluding-assemblies","text":"","title":"Excluding Assemblies"},{"location":"linker/linker-introduction/#excluding-types","text":"","title":"Excluding Types"},{"location":"linker/linker-introduction/#exclude-members","text":"","title":"Exclude Members"},{"location":"release-notes/mac/current/","text":"A summary of our current release of MFractor for Visual Studio Mac About installation and upgrade to latest version Currently there's a bug on the Visual Studio for Mac Extension Gallery where MFractor is stuck on an older version. We are working with Microsoft on a fix for this issue. To get the latest versions of MFractor please check the Installation and Setup page for instructions on manual installation and update. Releases (v4) Releases (v4.3) v4.3.0 - Released on August 6th 2020 - MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements. Releases (v4.2) v4.2.12 - Released on August 2nd 2020 - Preview release for MFractor 4.3. v4.2.11 - Released on July 20th 2020 - Service release to fix exported font bugs. v4.2.10 - Released on July 14th 2020 - Service release to fix customer reported bugs and improve the XAML editor performance. v4.2.9 - Released on July 12th 2020 - Service release to fix customer reported bugs. v4.2.8 - Released on July 7th 2020 - Service release to improve performance of XAML analysis engine and reduce memory consumption. v4.2.7 - Released on July 1st 2020 - Service release to resolve several customer reported bugs and add tooltips for colors/images. v4.2.6 - Released on June 25th 2020 - Service release to resolve several customer reported bugs. v4.2.5 - Released on June 22nd 2020 - Service release to fix users being unable to activate MFractor Lite. v4.2.4 - Released on June 19th 2020 - Service release to fix several customer reported issues, support for the new grid shorthand declaration format and more. v4.2.3 - Released on June 9th 2020 - Service release to add initial support for Blazor/Razor. v4.2.2 - Released on June 8th 2020 - Service release to add initial support for Blazor/Razor. v4.2.1 - Released on May 29th 2020 - Service release to improve the UX of the Scaffolder. v4.2.0 - Released on May 27th 2020 - MFractor 4.2 for Visual Studio Mac is a major release that adds support for Visual Studio 8.6, serial key license activation and fixes several bugs in the core product. Releases (v4.1) v4.1.3 - Released on May 18th 2020 - Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. v4.1.2 - Released on May 17th 2020 - Service release to fix several small issues in the code actions Alt+Return menu. v4.1.1 - Released on May 16th 2020 - Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. v4.1.0 - Released on May 12th 2020 - MFractor 4.1 for Visual Studio Mac is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. Releases (v4.0) v4.0.17 - Released on May 11th 2020 - Service release to fix a crash caused by color adornments. v4.0.16 - Released on May 10th 2020 - Service release to include automatic 30-day trials. v4.0.15 - Released on May 7th 2020 - Service release to align Mac version to Windows. v4.0.14 - Released on May 4th 2020 - Service release to align Mac version to Windows. v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.7 - Released on March 29th 2020 - Create class from clipboard tool and Resizetizer image asset support. v4.0.6 - Released on March 24th 2020 - Support for Visual Studio Mac 8.5 and adds insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in color and grid adornments. v4.0.4 - Released on March 17th 2020 - Adds grid row/column index adornments. Adds color adornments (enabled via a feature flag). v4.0.3 - Released on March 10th 2020 - Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution and font glyph tooltips + IntelliSense. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - Marketing release to announce the launch of MFractor for Visual Studio Windows. Releases (v3) Releases (v3.10) v3.10.4 - Released on February 11th 2020 - Adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. v3.10.3 - Released on February 3rd 2020 - Fixes many small XAML IntelliSense issues and adds grouping for MFractors commands in the Key Bindings preferences. v3.10.2 - Released on January 28th 2020 - Bump release to trigger Visual Studio Macs updater mechanisms. v3.10.1 - Released on January 23rd 2020 - Maintenance release to fix a bug in color analysis. v3.10.0 - Released on January 22nd 2020 - Focuses improving our on-boarding workflow, improving the UX and discoverability of code actions plus adding tooltips for colors and images. Releases (v3.9) v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bugs. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Current Release"},{"location":"release-notes/mac/current/#releases-v4","text":"","title":"Releases (v4)"},{"location":"release-notes/mac/current/#releases-v43","text":"v4.3.0 - Released on August 6th 2020 - MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements.","title":"Releases (v4.3)"},{"location":"release-notes/mac/current/#releases-v42","text":"v4.2.12 - Released on August 2nd 2020 - Preview release for MFractor 4.3. v4.2.11 - Released on July 20th 2020 - Service release to fix exported font bugs. v4.2.10 - Released on July 14th 2020 - Service release to fix customer reported bugs and improve the XAML editor performance. v4.2.9 - Released on July 12th 2020 - Service release to fix customer reported bugs. v4.2.8 - Released on July 7th 2020 - Service release to improve performance of XAML analysis engine and reduce memory consumption. v4.2.7 - Released on July 1st 2020 - Service release to resolve several customer reported bugs and add tooltips for colors/images. v4.2.6 - Released on June 25th 2020 - Service release to resolve several customer reported bugs. v4.2.5 - Released on June 22nd 2020 - Service release to fix users being unable to activate MFractor Lite. v4.2.4 - Released on June 19th 2020 - Service release to fix several customer reported issues, support for the new grid shorthand declaration format and more. v4.2.3 - Released on June 9th 2020 - Service release to add initial support for Blazor/Razor. v4.2.2 - Released on June 8th 2020 - Service release to add initial support for Blazor/Razor. v4.2.1 - Released on May 29th 2020 - Service release to improve the UX of the Scaffolder. v4.2.0 - Released on May 27th 2020 - MFractor 4.2 for Visual Studio Mac is a major release that adds support for Visual Studio 8.6, serial key license activation and fixes several bugs in the core product.","title":"Releases (v4.2)"},{"location":"release-notes/mac/current/#releases-v41","text":"v4.1.3 - Released on May 18th 2020 - Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. v4.1.2 - Released on May 17th 2020 - Service release to fix several small issues in the code actions Alt+Return menu. v4.1.1 - Released on May 16th 2020 - Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. v4.1.0 - Released on May 12th 2020 - MFractor 4.1 for Visual Studio Mac is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more.","title":"Releases (v4.1)"},{"location":"release-notes/mac/current/#releases-v40","text":"v4.0.17 - Released on May 11th 2020 - Service release to fix a crash caused by color adornments. v4.0.16 - Released on May 10th 2020 - Service release to include automatic 30-day trials. v4.0.15 - Released on May 7th 2020 - Service release to align Mac version to Windows. v4.0.14 - Released on May 4th 2020 - Service release to align Mac version to Windows. v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.7 - Released on March 29th 2020 - Create class from clipboard tool and Resizetizer image asset support. v4.0.6 - Released on March 24th 2020 - Support for Visual Studio Mac 8.5 and adds insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in color and grid adornments. v4.0.4 - Released on March 17th 2020 - Adds grid row/column index adornments. Adds color adornments (enabled via a feature flag). v4.0.3 - Released on March 10th 2020 - Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution and font glyph tooltips + IntelliSense. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - Marketing release to announce the launch of MFractor for Visual Studio Windows.","title":"Releases (v4.0)"},{"location":"release-notes/mac/current/#releases-v3","text":"","title":"Releases (v3)"},{"location":"release-notes/mac/current/#releases-v310","text":"v3.10.4 - Released on February 11th 2020 - Adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. v3.10.3 - Released on February 3rd 2020 - Fixes many small XAML IntelliSense issues and adds grouping for MFractors commands in the Key Bindings preferences. v3.10.2 - Released on January 28th 2020 - Bump release to trigger Visual Studio Macs updater mechanisms. v3.10.1 - Released on January 23rd 2020 - Maintenance release to fix a bug in color analysis. v3.10.0 - Released on January 22nd 2020 - Focuses improving our on-boarding workflow, improving the UX and discoverability of code actions plus adding tooltips for colors and images.","title":"Releases (v3.10)"},{"location":"release-notes/mac/current/#releases-v39","text":"v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bugs. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Releases (v3.9)"},{"location":"release-notes/mac/v3/v3.10/","text":"Release notes for our 3.10 versions of MFractor for Visual Studio Mac v3.10.4 Released on 11th of February 2020 This release adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. Enhancements: A new onboarding dialog welcomes you when you first install MFractor. A new Legal top level menu. Smaller distributable package size thanks to the removal of some no longer needed assemblies. Issues Fixed: Fixed: Add Image Tooltip support for C# code and ImageSource Properties. #189 v3.10.3 Released on 3rd of February 2020 This release fixes many small XAML IntelliSense issues related to attribute value and attribute shorthand completions plus adds a grouping for MFractors commands. Enhancements: In the Key Bindings preferences, all MFractor commands are now grouped under an \"MFractor\" section. Issues Fixed: Fixed: MFractor's IntelliSense would not trigger when starting an attribute value with \" . Fixed: MFractor's IntelliSense would not trigger sometimes when starting a new attribute with a letter. You would need to manually start the session with Control+Space . Fixed: Image assets are no longer suggested inside XAML expressions. Fixed: XAML styles would incorrectly report style mismatches. v3.10.2 Released on 28th of January 2020 This release is a \"bump\" release to trigger Visual Studio Macs update mechanisms. Enhancements: When an MFractor feature is Professional only, show a much more obvious status message using the toolbar. v3.10.1 Released on 23rd of January 2020 Maintenance release to fix a bug in color analysis. Enhancements: We've trimmed down the size of the extensions by removing some unnecessary assets. Third party attribution is now on docs.mfractor.com. Issues Fixed: Fixed: Small bug in color Intellisense warnings. #184 . v3.10.0 Released on 22nd of January 2020 The v3.10.0 release focuses improving our on-boarding workflow, improving the UX and discoverability of code actions, adds tooltips for images and colors and includes better refactoring support for static resources. Features: Our new code issue tooltip window presents available fixes for a code issue in the tooltip. You can them click on the suggestion to apply the fix. Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Click on the color value to copy the hex value to the clipboard. Image tooltips in XAML and C#. Hover over an image name to preview the image. Click on the image preview to open it in the image manager. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the App.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. The new Generate Font Character Code Class creates a C# class with all font character names and icons available as string constants. Enhancements: We've cleaned up our Activation Dialog UI structure and direct you to the documentation site after you activate. We've addd a new Request Trial main menu option so you can quickly request a trial license. We've addd a new Recover Professional License menu option so that you can recover you MFractor license. We've addd a new View Release Notes menu option under the About menu so that you can view the release notes for the current release. New Import font asset completion in XAML to launch the font importer and inject the FontFamily XAML needed to reference that code. We've added help links to the following features: Generate custom renderers. Image Importer. Image manager. Image deletion tool. Image optimisation tool. Bindable property wizard. Attached property wizard. Generate Interface Implementation. Font Importer. We've added a help links section to our XAML analysis preferences panel. As we document each analyser, a link to view the docs for that analyser become available. The Find Custom Renderers code action is now accessible through the Alt+Return menu in C#. When you update MFractor, we now show a small thank you message and provide you with a link to the release notes for that version. When you first install MFractor, we trigger Visual Studio Mac to restart to complete the installation. Issues Fixed: We've multiple issues where MFractor Lite wouldn't properly record and inform you that you were on a restriction of 4 documents per day. Fixed: The Start Accessibility Inspector command would not appear or launch. Fixed: The Edit Shared Project Items command wasn't opening the .projitems . Fixed: Sometimes Row and Column location completions wouldn't appear while editing a child of a grid. Fixed: Numeric data-bindings no longer give type mismatch warnings.","title":"v3.10"},{"location":"release-notes/mac/v3/v3.10/#v3104","text":"Released on 11th of February 2020 This release adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. Enhancements: A new onboarding dialog welcomes you when you first install MFractor. A new Legal top level menu. Smaller distributable package size thanks to the removal of some no longer needed assemblies. Issues Fixed: Fixed: Add Image Tooltip support for C# code and ImageSource Properties. #189","title":"v3.10.4"},{"location":"release-notes/mac/v3/v3.10/#v3103","text":"Released on 3rd of February 2020 This release fixes many small XAML IntelliSense issues related to attribute value and attribute shorthand completions plus adds a grouping for MFractors commands. Enhancements: In the Key Bindings preferences, all MFractor commands are now grouped under an \"MFractor\" section. Issues Fixed: Fixed: MFractor's IntelliSense would not trigger when starting an attribute value with \" . Fixed: MFractor's IntelliSense would not trigger sometimes when starting a new attribute with a letter. You would need to manually start the session with Control+Space . Fixed: Image assets are no longer suggested inside XAML expressions. Fixed: XAML styles would incorrectly report style mismatches.","title":"v3.10.3"},{"location":"release-notes/mac/v3/v3.10/#v3102","text":"Released on 28th of January 2020 This release is a \"bump\" release to trigger Visual Studio Macs update mechanisms. Enhancements: When an MFractor feature is Professional only, show a much more obvious status message using the toolbar.","title":"v3.10.2"},{"location":"release-notes/mac/v3/v3.10/#v3101","text":"Released on 23rd of January 2020 Maintenance release to fix a bug in color analysis. Enhancements: We've trimmed down the size of the extensions by removing some unnecessary assets. Third party attribution is now on docs.mfractor.com. Issues Fixed: Fixed: Small bug in color Intellisense warnings. #184 .","title":"v3.10.1"},{"location":"release-notes/mac/v3/v3.10/#v3100","text":"Released on 22nd of January 2020 The v3.10.0 release focuses improving our on-boarding workflow, improving the UX and discoverability of code actions, adds tooltips for images and colors and includes better refactoring support for static resources. Features: Our new code issue tooltip window presents available fixes for a code issue in the tooltip. You can them click on the suggestion to apply the fix. Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Click on the color value to copy the hex value to the clipboard. Image tooltips in XAML and C#. Hover over an image name to preview the image. Click on the image preview to open it in the image manager. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the App.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. The new Generate Font Character Code Class creates a C# class with all font character names and icons available as string constants. Enhancements: We've cleaned up our Activation Dialog UI structure and direct you to the documentation site after you activate. We've addd a new Request Trial main menu option so you can quickly request a trial license. We've addd a new Recover Professional License menu option so that you can recover you MFractor license. We've addd a new View Release Notes menu option under the About menu so that you can view the release notes for the current release. New Import font asset completion in XAML to launch the font importer and inject the FontFamily XAML needed to reference that code. We've added help links to the following features: Generate custom renderers. Image Importer. Image manager. Image deletion tool. Image optimisation tool. Bindable property wizard. Attached property wizard. Generate Interface Implementation. Font Importer. We've added a help links section to our XAML analysis preferences panel. As we document each analyser, a link to view the docs for that analyser become available. The Find Custom Renderers code action is now accessible through the Alt+Return menu in C#. When you update MFractor, we now show a small thank you message and provide you with a link to the release notes for that version. When you first install MFractor, we trigger Visual Studio Mac to restart to complete the installation. Issues Fixed: We've multiple issues where MFractor Lite wouldn't properly record and inform you that you were on a restriction of 4 documents per day. Fixed: The Start Accessibility Inspector command would not appear or launch. Fixed: The Edit Shared Project Items command wasn't opening the .projitems . Fixed: Sometimes Row and Column location completions wouldn't appear while editing a child of a grid. Fixed: Numeric data-bindings no longer give type mismatch warnings.","title":"v3.10.0"},{"location":"release-notes/mac/v3/v3.9/","text":"Release notes for our 3.9 versions of MFractor for Visual Studio Mac v3.9.8 Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. v3.9.7 Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176 v3.9.6 Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements. v3.9.5 Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 . v3.9.4 Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation. v3.9.3 Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix -> Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.2 Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac. v3.9.1 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.0 Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9"},{"location":"release-notes/mac/v3/v3.9/#v398","text":"Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml.","title":"v3.9.8"},{"location":"release-notes/mac/v3/v3.9/#v397","text":"Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176","title":"v3.9.7"},{"location":"release-notes/mac/v3/v3.9/#v396","text":"Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements.","title":"v3.9.6"},{"location":"release-notes/mac/v3/v3.9/#v395","text":"Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 .","title":"v3.9.5"},{"location":"release-notes/mac/v3/v3.9/#v394","text":"Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation.","title":"v3.9.4"},{"location":"release-notes/mac/v3/v3.9/#v393","text":"Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix -> Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.3"},{"location":"release-notes/mac/v3/v3.9/#v392","text":"Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac.","title":"v3.9.2"},{"location":"release-notes/mac/v3/v3.9/#v391","text":"Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.1"},{"location":"release-notes/mac/v3/v3.9/#v390","text":"Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9.0"},{"location":"release-notes/mac/v4/v4.0/","text":"Release notes for our 4.0 versions of MFractor for Visual Studio Mac About installation and upgrade to latest version Currently there's a bug on the Visual Studio for Mac Extension Gallery where MFractor is stuck on an older version. We are working with Microsoft on a fix for this issue. To get the latest versions of MFractor please check the Installation and Setup page for instructions on manual installation and update. v4.0.17 Released on May 11th 2020 Service release to fix a crash caused by color adornments. Issues Fixed: Fixed: When duplicate color resources are available to a document, do not crash the editor. v4.0.16 Released on May 10th 2020 Service release to include automatic 30-day trials. v4.0.15 Released on May 7th 2020 Service release to align Mac version to Windows. v4.0.14 Released on May 4th 2020 Service release to align Mac version to Windows. v4.0.13 Released on April 20th 2020 Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. Features Font string preview tooltips. Embedded font tooltips. Go to definition support for fonts that opens the font viewer. Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished. v4.0.12 Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties. v4.0.11 Released on April 14th 2020 Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. Features The new font viewer pad allows you to visually explore the content of a font asset. Support for embedded font assets in font analysis, IntelliSense and tooltips. When setting the BindingContext for a control, new shorthand completion that provides available x:Name fields to create a {x:Reference fieldName} expression. v4.0.10 Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors. v4.0.9 Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times. v4.0.7 Released on 29th of March 2020 Service release to add the Create class from clipboard tool and Resizetizer image asset support. v4.0.6 Released on 24th of March 2020 Service release to support Visual Studio Mac 8.5 and adds Features Insert row/column code actions. Delete row/column code actions. Enhancements All of MFractors code actions are now grouped under a single MFractor Code Actions menu. This makes it easier to discover our code actions. New code fix to remove all redundant grid row and columns. v4.0.5 Released on 19th of March 2020 Service release to fix bugs in color and grid adornments. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: Grid adornments with double digits are no longer clipped. Fixed: Show color elaborations on black and white. #195 Fixed: Grid adornments should honor IDE theme (dark vs light). Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 . v4.0.4 Released on 17th of March 2020 Adds adornments for grid indices and color values. Enhancements: MFractor now adds an annotation before a Row/Column definition to show it's index. MFractor now adds a color annotation alongside color values to show the color inline. v4.0.3 Released on 10th of March 2020 Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . v4.0.2 Released on 2nd of March 2020 Adds x:DataType support to binding context resolution and font glyph tooltips and IntelliSense. Enhancements: When hovering over a font glyph code and MFractor can resolve the font family, a tooltip preview of that glyph will now be shown. When editing string values and the font applied has glyphs, MFractor now suggests the font glyphs in IntelliSense. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType. v4.0.1 Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. v4.0.0 Released on 20th of February 2020 MFractor 4.0.0 is a marketing release to announce the launch of MFractor for Visual Studio Windows. Features: Our New onboarding dialog to welcome you after installing.","title":"v4.0"},{"location":"release-notes/mac/v4/v4.0/#v4017","text":"Released on May 11th 2020 Service release to fix a crash caused by color adornments. Issues Fixed: Fixed: When duplicate color resources are available to a document, do not crash the editor.","title":"v4.0.17"},{"location":"release-notes/mac/v4/v4.0/#v4016","text":"Released on May 10th 2020 Service release to include automatic 30-day trials.","title":"v4.0.16"},{"location":"release-notes/mac/v4/v4.0/#v4015","text":"Released on May 7th 2020 Service release to align Mac version to Windows.","title":"v4.0.15"},{"location":"release-notes/mac/v4/v4.0/#v4014","text":"Released on May 4th 2020 Service release to align Mac version to Windows.","title":"v4.0.14"},{"location":"release-notes/mac/v4/v4.0/#v4013","text":"Released on April 20th 2020 Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. Features Font string preview tooltips. Embedded font tooltips. Go to definition support for fonts that opens the font viewer. Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished.","title":"v4.0.13"},{"location":"release-notes/mac/v4/v4.0/#v4012","text":"Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties.","title":"v4.0.12"},{"location":"release-notes/mac/v4/v4.0/#v4011","text":"Released on April 14th 2020 Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. Features The new font viewer pad allows you to visually explore the content of a font asset. Support for embedded font assets in font analysis, IntelliSense and tooltips. When setting the BindingContext for a control, new shorthand completion that provides available x:Name fields to create a {x:Reference fieldName} expression.","title":"v4.0.11"},{"location":"release-notes/mac/v4/v4.0/#v4010","text":"Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors.","title":"v4.0.10"},{"location":"release-notes/mac/v4/v4.0/#v409","text":"Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings.","title":"v4.0.9"},{"location":"release-notes/mac/v4/v4.0/#v408","text":"Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times.","title":"v4.0.8"},{"location":"release-notes/mac/v4/v4.0/#v407","text":"Released on 29th of March 2020 Service release to add the Create class from clipboard tool and Resizetizer image asset support.","title":"v4.0.7"},{"location":"release-notes/mac/v4/v4.0/#v406","text":"Released on 24th of March 2020 Service release to support Visual Studio Mac 8.5 and adds Features Insert row/column code actions. Delete row/column code actions. Enhancements All of MFractors code actions are now grouped under a single MFractor Code Actions menu. This makes it easier to discover our code actions. New code fix to remove all redundant grid row and columns.","title":"v4.0.6"},{"location":"release-notes/mac/v4/v4.0/#v405","text":"Released on 19th of March 2020 Service release to fix bugs in color and grid adornments. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: Grid adornments with double digits are no longer clipped. Fixed: Show color elaborations on black and white. #195 Fixed: Grid adornments should honor IDE theme (dark vs light). Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 .","title":"v4.0.5"},{"location":"release-notes/mac/v4/v4.0/#v404","text":"Released on 17th of March 2020 Adds adornments for grid indices and color values. Enhancements: MFractor now adds an annotation before a Row/Column definition to show it's index. MFractor now adds a color annotation alongside color values to show the color inline.","title":"v4.0.4"},{"location":"release-notes/mac/v4/v4.0/#v403","text":"Released on 10th of March 2020 Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= .","title":"v4.0.3"},{"location":"release-notes/mac/v4/v4.0/#v402","text":"Released on 2nd of March 2020 Adds x:DataType support to binding context resolution and font glyph tooltips and IntelliSense. Enhancements: When hovering over a font glyph code and MFractor can resolve the font family, a tooltip preview of that glyph will now be shown. When editing string values and the font applied has glyphs, MFractor now suggests the font glyphs in IntelliSense. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType.","title":"v4.0.2"},{"location":"release-notes/mac/v4/v4.0/#v401","text":"Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style.","title":"v4.0.1"},{"location":"release-notes/mac/v4/v4.0/#v400","text":"Released on 20th of February 2020 MFractor 4.0.0 is a marketing release to announce the launch of MFractor for Visual Studio Windows. Features: Our New onboarding dialog to welcome you after installing.","title":"v4.0.0"},{"location":"release-notes/mac/v4/v4.1/","text":"Release notes for our 4.0 versions of MFractor for Visual Studio Mac About installation and upgrade to latest version Currently there's a bug on the Visual Studio for Mac Extension Gallery where MFractor is stuck on an older version. We are working with Microsoft on a fix for this issue. To get the latest versions of MFractor please check the Installation and Setup page for instructions on manual installation and update. v4.1.3 Released on May 18th 2020 Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. Enhancements: Show license expiry notifications at 14, 7 and 1 days for both Professional and Trial licenses. Issues Fixed: Fixed: Fix integration issues for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Replace duplicate namespace references does nothing. #211 v4.1.2 Released on May 17th 2020 Service release to fix several small issues in the code actions Alt+Return menu. Features Code fix to migrate Icon to IconImageSource . Issues Fixed: Fixed: Further tidy up for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: The Remove all redundant style properties fix did not work. Fixed: Go To ViewModel is not honouring x:DataType. #209 v4.1.1 Released on May 16th 2020 Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. Features The Scaffolder is a file creation wizard that infers your intended file type based on the provided name and file extension plus the context that you are creating that new file in. Disable XAML analysers at the document level using the following syntax: <!-- [MFractor: Suppress(MF1000)] --> or <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] --> . #202 The Move Attribute To Parent can move a matching attribute from an element into it's parent (EG: Margin=\"10\" set on a label inside a stack layout will be removed from the label and then added to the StackLayout). You can now edit a color adornment and launch the color editor. #199 Issues Fixed: Fixed: MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Binding Context Initialise in XAML sets x:Key instead of x:Name. #207 Fixed: Get binding IntelliSense using x:DataType provided at the root level. #201 Fixed: 404 for code action Learn how MFractor detects your ViewModels and Binding. #205 Fixed: Grid indexes clipped on 15\" macbook. #197 Fixed: Using Value Converter Wizard to add converter to page created duplicate xmlns. #204 v4.1.0 Released on May 12th 2020 MFractor 4.1 for Visual Studio Mac is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. For a full summary of all features included in 4.1, please see the v4.0 release notes .","title":"v4.1"},{"location":"release-notes/mac/v4/v4.1/#v413","text":"Released on May 18th 2020 Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. Enhancements: Show license expiry notifications at 14, 7 and 1 days for both Professional and Trial licenses. Issues Fixed: Fixed: Fix integration issues for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Replace duplicate namespace references does nothing. #211","title":"v4.1.3"},{"location":"release-notes/mac/v4/v4.1/#v412","text":"Released on May 17th 2020 Service release to fix several small issues in the code actions Alt+Return menu. Features Code fix to migrate Icon to IconImageSource . Issues Fixed: Fixed: Further tidy up for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: The Remove all redundant style properties fix did not work. Fixed: Go To ViewModel is not honouring x:DataType. #209","title":"v4.1.2"},{"location":"release-notes/mac/v4/v4.1/#v411","text":"Released on May 16th 2020 Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. Features The Scaffolder is a file creation wizard that infers your intended file type based on the provided name and file extension plus the context that you are creating that new file in. Disable XAML analysers at the document level using the following syntax: <!-- [MFractor: Suppress(MF1000)] --> or <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] --> . #202 The Move Attribute To Parent can move a matching attribute from an element into it's parent (EG: Margin=\"10\" set on a label inside a stack layout will be removed from the label and then added to the StackLayout). You can now edit a color adornment and launch the color editor. #199 Issues Fixed: Fixed: MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Binding Context Initialise in XAML sets x:Key instead of x:Name. #207 Fixed: Get binding IntelliSense using x:DataType provided at the root level. #201 Fixed: 404 for code action Learn how MFractor detects your ViewModels and Binding. #205 Fixed: Grid indexes clipped on 15\" macbook. #197 Fixed: Using Value Converter Wizard to add converter to page created duplicate xmlns. #204","title":"v4.1.1"},{"location":"release-notes/mac/v4/v4.1/#v410","text":"Released on May 12th 2020 MFractor 4.1 for Visual Studio Mac is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. For a full summary of all features included in 4.1, please see the v4.0 release notes .","title":"v4.1.0"},{"location":"release-notes/mac/v4/v4.2/","text":"Release notes for our 4.2 versions of MFractor for Visual Studio Mac v4.2.12 Released on August 2nd 2020 Preview release for MFractor 4.3. Release notes pending. v4.2.11 Released on July 20th 2020 Service release to fix exported font bugs. Issues Fixed: Fixed: [Suggestion] Font embed failure. #275 Fixed: [Bug] Move color to local resource always wraps in a new ResourceDictionary #273 v4.2.10 Released on July 14th 2020 Service release to fix customer reported bugs and improve the XAML editor performance when MFractor is enabled. Issues Fixed: Fixed: The XAML analyser would sometimes analyse a file twice per file-edit. Fixed: We've improved the XAML analyser's efficiency by reducing the amount of analysis passes required per node and attribute. Fixed: Support Style in a different assembly. #246 Fixed: Code Action: Encapsulate element with layout container. #188 Fixed: Allow files to be included/excluded on the image deletion tool. #177 v4.2.9 Released on July 12th 2020 Service release to fix customer reported bugs. Issues Fixed: Fixed: Add Image Tooling support for iOS projects. #190 Fixed: Exclude from link can't add entry to linker.xml . #265 Fixed: MVVM Wizard is disabled unless a file is opened. #251 Fixed: Import Image Asset doesn't work in very large solutions. #257 v4.2.8 Released on July 7th 2020 Service release to improve performance of XAML analysis engine and reduce memory consumption. Issues Fixed: Fixed: MFractor Preferences crashing. #268 Fixed: Sometimes when clicking on MFractors code-fix links, the code fix wouldn't apply. Fixed: Sometimes MFractors code actions would be unaccessible through Alt+Return. Fixed: Reduced the amount of threads MFractor uses when analysing XAML files to improve IDE responsiveness. v4.2.7 Released on July 1st 2020 Service release to resolve several customer reported bugs and add tooltips for colors/images. Features: Image tooltips for C# string image references. Color tooltips for C# string color values (hex and named color formats). Issues Fixed: Fixed: Scaffold Page/Content page. #266 v4.2.6 Released on June 25th2020 Service release to resolve several customer reported bugs. Features: When a CollectionView uses the GroupHeaderTemplate and/or GroupFooterTemplate , however, it does not set IsGrouped to true, we have added a new code analyser to warn that the grouping will not display. Issues Fixed: Fixed: Pickers ItemDisplayBinding property uses the incorrect binding context for analysis and Intellisense. #262 Fixed: Regression in row and column tooltips, analysis and Intellisense when a row or column does not define its size. v4.2.5 Released on June 22nd 2020 Service release to fix users being unable to activate MFractor Lite. Issues Fixed: Fixed: Unable to activate MFractor Lite. Fixed: Regression in row and column span analysis. v4.2.4 Released on June 19th 2020 Service release to resolve several customer reported issues, add grid shorthand parsing support, add features for copying bundle ids to the clipboard and a command to add an export font declaration for new fonts. Features: Copy iOS projects bundle identifier from the Solution Explorer. Documentation . #250 Support for Xamarin.Forms 4.7 grid shorthand declarations. [#232])(https://github.com/mfractor/mfractor-feedback/issues/232) Create a tools menu command that can add an ExportFont declaration for a font file. #249 Issues Fixed: Navigate to ViewModel doesn't work if it's in a different project. #254 , #255 Deactivate License Text Bug not appearing on a new line. #252 Delete Image won't work on last version of MFractor. #253 , #228 v4.2.3 Released on June 9th 2020 Hotfix to address potential IDE crash when files were added and removed. v4.2.2 Released on June 8th 2020 Service release to add initial support for Blazor/Razor. Features: Web scaffolders. #222 Blazor Page scaffolder. Blazor component scaffolder. ASP.NET API Controller. #242 Blazor: Code Behind HotKey Navigation. #214 Issues Fixed: Fixed: Integrate a Help Url into the Scaffolder. #236 Fixed: Deactivate License Bug. #240 Fixed: URL incorrect for scaffolding .razor.cs. #244 Fixed: Scaffolder .razor.cs strange class names #243 Fixed: When using .razor.cs extension with scaffolder, it creates a .razor file but no code behind for pages. #241 Fixed: Scaffolder list incorrect if I use .razor.cs extension. #239 Fixed: Color Tooltips are behaving inconsistently for Setters. #230 v4.2.1 Released on May 29th 2020 Service release to improve the UX of the Scaffolder. Issues Fixed: Fixed: Enter key submit in Scaffolder. #223 Fixed: Scaffolder hot key. #225 v4.2.0 Released on May 27th 2020 MFractor 4.2 for Visual Studio Mac is a major release that adds support for Visual Studio 8.6, serial key license activation and fixes several bugs in the core product. Features MFractor now supports license activation via serial key. When you purchase an MFractor Professional license, you will now receive a serial key instead of a license file. MFractor now offers license recovery from within the product. Head to the top MFractor menu, choose Recover MFractor Professional License and then enter your email. If a license is available for that email, you will receive a license recovery email. Issues Fixed: Fixed: Visual Studio Mac 16.6 support. #216 Fixed: MFractor doesn't check for Android Vector Drawable files when validating images. #219 . Fixed: Create class from clipboard enhancements [#208])(https://github.com/mfractor/mfractor-feedback/issues/208) Fixed: VS Mac freezing/not responding (Core engine issues). [#221])(https://github.com/mfractor/mfractor-feedback/issues/221)","title":"v4.2"},{"location":"release-notes/mac/v4/v4.2/#v4212","text":"Released on August 2nd 2020 Preview release for MFractor 4.3. Release notes pending.","title":"v4.2.12"},{"location":"release-notes/mac/v4/v4.2/#v4211","text":"Released on July 20th 2020 Service release to fix exported font bugs. Issues Fixed: Fixed: [Suggestion] Font embed failure. #275 Fixed: [Bug] Move color to local resource always wraps in a new ResourceDictionary #273","title":"v4.2.11"},{"location":"release-notes/mac/v4/v4.2/#v4210","text":"Released on July 14th 2020 Service release to fix customer reported bugs and improve the XAML editor performance when MFractor is enabled. Issues Fixed: Fixed: The XAML analyser would sometimes analyse a file twice per file-edit. Fixed: We've improved the XAML analyser's efficiency by reducing the amount of analysis passes required per node and attribute. Fixed: Support Style in a different assembly. #246 Fixed: Code Action: Encapsulate element with layout container. #188 Fixed: Allow files to be included/excluded on the image deletion tool. #177","title":"v4.2.10"},{"location":"release-notes/mac/v4/v4.2/#v429","text":"Released on July 12th 2020 Service release to fix customer reported bugs. Issues Fixed: Fixed: Add Image Tooling support for iOS projects. #190 Fixed: Exclude from link can't add entry to linker.xml . #265 Fixed: MVVM Wizard is disabled unless a file is opened. #251 Fixed: Import Image Asset doesn't work in very large solutions. #257","title":"v4.2.9"},{"location":"release-notes/mac/v4/v4.2/#v428","text":"Released on July 7th 2020 Service release to improve performance of XAML analysis engine and reduce memory consumption. Issues Fixed: Fixed: MFractor Preferences crashing. #268 Fixed: Sometimes when clicking on MFractors code-fix links, the code fix wouldn't apply. Fixed: Sometimes MFractors code actions would be unaccessible through Alt+Return. Fixed: Reduced the amount of threads MFractor uses when analysing XAML files to improve IDE responsiveness.","title":"v4.2.8"},{"location":"release-notes/mac/v4/v4.2/#v427","text":"Released on July 1st 2020 Service release to resolve several customer reported bugs and add tooltips for colors/images. Features: Image tooltips for C# string image references. Color tooltips for C# string color values (hex and named color formats). Issues Fixed: Fixed: Scaffold Page/Content page. #266","title":"v4.2.7"},{"location":"release-notes/mac/v4/v4.2/#v426","text":"Released on June 25th2020 Service release to resolve several customer reported bugs. Features: When a CollectionView uses the GroupHeaderTemplate and/or GroupFooterTemplate , however, it does not set IsGrouped to true, we have added a new code analyser to warn that the grouping will not display. Issues Fixed: Fixed: Pickers ItemDisplayBinding property uses the incorrect binding context for analysis and Intellisense. #262 Fixed: Regression in row and column tooltips, analysis and Intellisense when a row or column does not define its size.","title":"v4.2.6"},{"location":"release-notes/mac/v4/v4.2/#v425","text":"Released on June 22nd 2020 Service release to fix users being unable to activate MFractor Lite. Issues Fixed: Fixed: Unable to activate MFractor Lite. Fixed: Regression in row and column span analysis.","title":"v4.2.5"},{"location":"release-notes/mac/v4/v4.2/#v424","text":"Released on June 19th 2020 Service release to resolve several customer reported issues, add grid shorthand parsing support, add features for copying bundle ids to the clipboard and a command to add an export font declaration for new fonts. Features: Copy iOS projects bundle identifier from the Solution Explorer. Documentation . #250 Support for Xamarin.Forms 4.7 grid shorthand declarations. [#232])(https://github.com/mfractor/mfractor-feedback/issues/232) Create a tools menu command that can add an ExportFont declaration for a font file. #249 Issues Fixed: Navigate to ViewModel doesn't work if it's in a different project. #254 , #255 Deactivate License Text Bug not appearing on a new line. #252 Delete Image won't work on last version of MFractor. #253 , #228","title":"v4.2.4"},{"location":"release-notes/mac/v4/v4.2/#v423","text":"Released on June 9th 2020 Hotfix to address potential IDE crash when files were added and removed.","title":"v4.2.3"},{"location":"release-notes/mac/v4/v4.2/#v422","text":"Released on June 8th 2020 Service release to add initial support for Blazor/Razor. Features: Web scaffolders. #222 Blazor Page scaffolder. Blazor component scaffolder. ASP.NET API Controller. #242 Blazor: Code Behind HotKey Navigation. #214 Issues Fixed: Fixed: Integrate a Help Url into the Scaffolder. #236 Fixed: Deactivate License Bug. #240 Fixed: URL incorrect for scaffolding .razor.cs. #244 Fixed: Scaffolder .razor.cs strange class names #243 Fixed: When using .razor.cs extension with scaffolder, it creates a .razor file but no code behind for pages. #241 Fixed: Scaffolder list incorrect if I use .razor.cs extension. #239 Fixed: Color Tooltips are behaving inconsistently for Setters. #230","title":"v4.2.2"},{"location":"release-notes/mac/v4/v4.2/#v421","text":"Released on May 29th 2020 Service release to improve the UX of the Scaffolder. Issues Fixed: Fixed: Enter key submit in Scaffolder. #223 Fixed: Scaffolder hot key. #225","title":"v4.2.1"},{"location":"release-notes/mac/v4/v4.2/#v420","text":"Released on May 27th 2020 MFractor 4.2 for Visual Studio Mac is a major release that adds support for Visual Studio 8.6, serial key license activation and fixes several bugs in the core product. Features MFractor now supports license activation via serial key. When you purchase an MFractor Professional license, you will now receive a serial key instead of a license file. MFractor now offers license recovery from within the product. Head to the top MFractor menu, choose Recover MFractor Professional License and then enter your email. If a license is available for that email, you will receive a license recovery email. Issues Fixed: Fixed: Visual Studio Mac 16.6 support. #216 Fixed: MFractor doesn't check for Android Vector Drawable files when validating images. #219 . Fixed: Create class from clipboard enhancements [#208])(https://github.com/mfractor/mfractor-feedback/issues/208) Fixed: VS Mac freezing/not responding (Core engine issues). [#221])(https://github.com/mfractor/mfractor-feedback/issues/221)","title":"v4.2.0"},{"location":"release-notes/mac/v4/v4.3/","text":"Release notes for our 4.3 versions of MFractor for Visual Studio Mac v4.3.0 Released on August 6th 2020 MFractor 4.3 is a major release to support Visual Mac 8.7 and includes several new features for tooltips plus lots of bug fixes and overall product improvements. Features Navigation Tooltip Links : When MFractor can perform a navigation action for the current element, the new Navigate To link will appear in the tooltip. Code Analysis Help Links : When a code inspection has a help file available, you can now click on the Help link in the tooltip window to learn more about it. SVG Tooltips: Hover over an SVG file reference or SVG path data and MFractor will now show you a preview of that SVG. (Mac Only) Localisation Tooltips for C# and XAML: When a property maps to a .resx localisation lookup, MFractor will display a summary of all localisations for that key. DateTime Format Preview Tooltips : Hover over a data time format string to see a preview of it as DateTime.Now. Issues Fixed: Fixed: Add support for the XmlnsDefinition attribute #98 Fixed: The Create new Style code action should trigger the Create New Style window instead of a blank one. #277 Fixed: Unable to find Carousel IndicatorView (false warning). #289 Fixed: The NavigateToFileSpansWorkUnitHandler is not implemented (breaks go to custom renderer). #245 Fixed: Visual Studio Windows - Manage Image Assets - not populating. #291 Fixed: Scaffolder on VS Windows Code Preview and Scaffold list broken. #284 Fixed: Enhancement localisation tool. #134 When over a localisation expression, show localisation values summary in a tooltip. Go to definition support for localisation expressions. Code action to move a string literal to a RESX file (new or existing). Ongoing performance and memory improvements: Removing (most) usages of Task.Run to prevent MFractor generating unnecessary threads. Pre-caching/pre-populating as much state as possible when performing XAML analysis. More use of Lazy<T> to defer or avoid the cost of expensive resolution operations. Code output previews for the Generate Customer Renderers and Exclude From Linking features. XAML Localisation: Removed dependency on deprecated ILocalise methodology and moved to .resx files methodology. See Xamarin.Forms String and Image Localization .","title":"v4.3"},{"location":"release-notes/mac/v4/v4.3/#v430","text":"Released on August 6th 2020 MFractor 4.3 is a major release to support Visual Mac 8.7 and includes several new features for tooltips plus lots of bug fixes and overall product improvements. Features Navigation Tooltip Links : When MFractor can perform a navigation action for the current element, the new Navigate To link will appear in the tooltip. Code Analysis Help Links : When a code inspection has a help file available, you can now click on the Help link in the tooltip window to learn more about it. SVG Tooltips: Hover over an SVG file reference or SVG path data and MFractor will now show you a preview of that SVG. (Mac Only) Localisation Tooltips for C# and XAML: When a property maps to a .resx localisation lookup, MFractor will display a summary of all localisations for that key. DateTime Format Preview Tooltips : Hover over a data time format string to see a preview of it as DateTime.Now. Issues Fixed: Fixed: Add support for the XmlnsDefinition attribute #98 Fixed: The Create new Style code action should trigger the Create New Style window instead of a blank one. #277 Fixed: Unable to find Carousel IndicatorView (false warning). #289 Fixed: The NavigateToFileSpansWorkUnitHandler is not implemented (breaks go to custom renderer). #245 Fixed: Visual Studio Windows - Manage Image Assets - not populating. #291 Fixed: Scaffolder on VS Windows Code Preview and Scaffold list broken. #284 Fixed: Enhancement localisation tool. #134 When over a localisation expression, show localisation values summary in a tooltip. Go to definition support for localisation expressions. Code action to move a string literal to a RESX file (new or existing). Ongoing performance and memory improvements: Removing (most) usages of Task.Run to prevent MFractor generating unnecessary threads. Pre-caching/pre-populating as much state as possible when performing XAML analysis. More use of Lazy<T> to defer or avoid the cost of expensive resolution operations. Code output previews for the Generate Customer Renderers and Exclude From Linking features. XAML Localisation: Removed dependency on deprecated ILocalise methodology and moved to .resx files methodology. See Xamarin.Forms String and Image Localization .","title":"v4.3.0"},{"location":"release-notes/windows/current/","text":"A summary of our current release of MFractor for Visual Studio Windows Releases (v4) Releases (v4.3) v4.3.0 - Released on August 6th 2020 - MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements. Releases (v4.2) v4.2.12 - Released on August 2nd 2020 - Preview release for MFractor 4.3. v4.2.11 - Released on July 20th 2020 - Service release to fix exported font bugs. v4.2.10 - Released on July 14th 2020 - Service release to fix customer reported bugs and improve the XAML editor performance. v4.2.9 - Released on July 12th 2020 - Service release to fix customer reported bugs. v4.2.8 - Released on July 7th 2020 - Service release to improve performance of XAML analysis engine and reduce memory consumption. v4.2.7 - Released on July 1st 2020 - Service release to resolve several customer reported bugs and add tooltips for colors/images. v4.2.6 - Released on June 25th 2020 - Service release to resolve several customer reported bugs. v4.2.5 - Released on June 22nd 2020 - Service release to fix users being unable to activate MFractor Lite. v4.2.4 - Released on June 19th 2020 - Service release to fix several customer reported issues, support for the new grid shorthand declaration format and more. v4.2.3 - Released on June 9th 2020 - Hotfix to address potential IDE crash when files were added and removed. v4.2.2 - Released on June 8th 2020 - Service release to add initial support for Blazor/Razor. v4.2.1 - Released on May 29th 2020 - Service release to improve the UX of the Scaffolder. v4.2.0 - Released on May 27th 2020 - MFractor 4.2 for Visual Studio Windows is a major release that adds support for Visual Studio 16.6, serial key license activation and fixes several bugs in the core product. Releases (v4.1) v4.1.3 - Released on May 18th 2020 - Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. v4.1.2 - Released on May 17th 2020 - Service release to fix several small issues in the MVVM resolver. v4.1.1 - Released on May 16th 2020 - Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level and color adornment editing support. v4.1.0 - Released on May 12th 2020 - MFractor 4.1 for Visual Studio Windows is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. Releases (v4.0) v4.0.17 - Released on May 10th 2020 - Service release to fix a crash caused by color adornments. v4.0.16 - Released on May 10th 2020 - Service release to include automatic 30-day trials. v4.0.15 - Released on May 7th 2020 - Service release to fix issues with image management on Windows. v4.0.14 - Released on May 4th 2020 - Service release to add adornments for XAML in Visual Studio Windows. v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Hotfix release to fix image manager list items not appearing. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.6 - Released on March 24th 2020 - Service release add insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. v4.0.4 - Released on March 17th 2020 - Fixes an issue where trial license requests were not going through. v4.0.3 - Released on March 10th 2020 - Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - v4.0 is our stable release of MFractor for Visual Studio Windows, reaching approximate feature parity with MFractor for Visual Studio Mac. Releases (v0) v0.6.0 - Released on February 12th 2020 : Preview 6 release of MFractor for Visual Studio Windows. v0.5.0 - Released on February 11th 2020 : Preview 5 release of MFractor for Visual Studio Windows. v0.4.0 - Released on February 4th 2020 : Preview 4 release of MFractor for Visual Studio Windows. v0.3.0 - Released on January 28th 2020 : Preview 3 release of MFractor for Visual Studio Windows. v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows. v0.1.0 - Released on November 25th 2019 : Preview 1 release of MFractor for Visual Studio Windows.","title":"Current Release"},{"location":"release-notes/windows/current/#releases-v4","text":"","title":"Releases (v4)"},{"location":"release-notes/windows/current/#releases-v43","text":"v4.3.0 - Released on August 6th 2020 - MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements.","title":"Releases (v4.3)"},{"location":"release-notes/windows/current/#releases-v42","text":"v4.2.12 - Released on August 2nd 2020 - Preview release for MFractor 4.3. v4.2.11 - Released on July 20th 2020 - Service release to fix exported font bugs. v4.2.10 - Released on July 14th 2020 - Service release to fix customer reported bugs and improve the XAML editor performance. v4.2.9 - Released on July 12th 2020 - Service release to fix customer reported bugs. v4.2.8 - Released on July 7th 2020 - Service release to improve performance of XAML analysis engine and reduce memory consumption. v4.2.7 - Released on July 1st 2020 - Service release to resolve several customer reported bugs and add tooltips for colors/images. v4.2.6 - Released on June 25th 2020 - Service release to resolve several customer reported bugs. v4.2.5 - Released on June 22nd 2020 - Service release to fix users being unable to activate MFractor Lite. v4.2.4 - Released on June 19th 2020 - Service release to fix several customer reported issues, support for the new grid shorthand declaration format and more. v4.2.3 - Released on June 9th 2020 - Hotfix to address potential IDE crash when files were added and removed. v4.2.2 - Released on June 8th 2020 - Service release to add initial support for Blazor/Razor. v4.2.1 - Released on May 29th 2020 - Service release to improve the UX of the Scaffolder. v4.2.0 - Released on May 27th 2020 - MFractor 4.2 for Visual Studio Windows is a major release that adds support for Visual Studio 16.6, serial key license activation and fixes several bugs in the core product.","title":"Releases (v4.2)"},{"location":"release-notes/windows/current/#releases-v41","text":"v4.1.3 - Released on May 18th 2020 - Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. v4.1.2 - Released on May 17th 2020 - Service release to fix several small issues in the MVVM resolver. v4.1.1 - Released on May 16th 2020 - Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level and color adornment editing support. v4.1.0 - Released on May 12th 2020 - MFractor 4.1 for Visual Studio Windows is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more.","title":"Releases (v4.1)"},{"location":"release-notes/windows/current/#releases-v40","text":"v4.0.17 - Released on May 10th 2020 - Service release to fix a crash caused by color adornments. v4.0.16 - Released on May 10th 2020 - Service release to include automatic 30-day trials. v4.0.15 - Released on May 7th 2020 - Service release to fix issues with image management on Windows. v4.0.14 - Released on May 4th 2020 - Service release to add adornments for XAML in Visual Studio Windows. v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Hotfix release to fix image manager list items not appearing. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.6 - Released on March 24th 2020 - Service release add insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. v4.0.4 - Released on March 17th 2020 - Fixes an issue where trial license requests were not going through. v4.0.3 - Released on March 10th 2020 - Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - v4.0 is our stable release of MFractor for Visual Studio Windows, reaching approximate feature parity with MFractor for Visual Studio Mac.","title":"Releases (v4.0)"},{"location":"release-notes/windows/current/#releases-v0","text":"v0.6.0 - Released on February 12th 2020 : Preview 6 release of MFractor for Visual Studio Windows. v0.5.0 - Released on February 11th 2020 : Preview 5 release of MFractor for Visual Studio Windows. v0.4.0 - Released on February 4th 2020 : Preview 4 release of MFractor for Visual Studio Windows. v0.3.0 - Released on January 28th 2020 : Preview 3 release of MFractor for Visual Studio Windows. v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows. v0.1.0 - Released on November 25th 2019 : Preview 1 release of MFractor for Visual Studio Windows.","title":"Releases (v0)"},{"location":"release-notes/windows/v0/v0.1/","text":"Release notes for our 0.1 versions of MFractor for Visual Studio Windows v0.1.0 Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1"},{"location":"release-notes/windows/v0/v0.1/#v010","text":"Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1.0"},{"location":"release-notes/windows/v0/v0.2/","text":"Release notes for our 0.2 versions of MFractor for Visual Studio Windows v0.2.0 Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accessible through Extensions -> MFractor -> Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2"},{"location":"release-notes/windows/v0/v0.2/#v020","text":"Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accessible through Extensions -> MFractor -> Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2.0"},{"location":"release-notes/windows/v0/v0.3/","text":"Release notes for our 0.3 versions of MFractor for Visual Studio Windows v0.3.0 Released on January 28th 2020 MFractor for Visual Studio Windows v0.3.0 is a major upgrade from v0.2, adding our IntelliSense engine, custom tooltips for XAML, additional menu items for requesting a trial and recovering an existing license. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 3 . Preview 3 : IntelliSense Integration. Custom tooltips for code issues, colors and image assets. Main menu items for: Request 30 day trial. Recover license. View release notes. Go to XAML symbol action. Find Custom Renderers action. Generate Font Character Code Class tool. Fixes numerous issues in our core engine. Please see Mac v3.10 and Mac v3.9 release notes for full details.","title":"v0.3"},{"location":"release-notes/windows/v0/v0.3/#v030","text":"Released on January 28th 2020 MFractor for Visual Studio Windows v0.3.0 is a major upgrade from v0.2, adding our IntelliSense engine, custom tooltips for XAML, additional menu items for requesting a trial and recovering an existing license. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 3 . Preview 3 : IntelliSense Integration. Custom tooltips for code issues, colors and image assets. Main menu items for: Request 30 day trial. Recover license. View release notes. Go to XAML symbol action. Find Custom Renderers action. Generate Font Character Code Class tool. Fixes numerous issues in our core engine. Please see Mac v3.10 and Mac v3.9 release notes for full details.","title":"v0.3.0"},{"location":"release-notes/windows/v0/v0.4/","text":"Release notes for our 0.4 versions of MFractor for Visual Studio Windows v0.4.0 Released on February 4th 2020 MFractor for Visual Studio Windows v0.4 is a major upgrade from v0.3, shifting significantly closer to a stable release. This release integrates our workspace events and data engines to activate all features related to static resources (analysis, code actions, tooltips and IntelliSense) and image assets (analysis, code actions, tooltips and IntelliSense). Officially, this product release is known as MFractor for Visual Studio Windows - Preview 4 . Preview 4 : The workspace events engine is now integrated, having flow on effects to enable several other core systems and features. The meta-data engine is now integrated and switches on many remaining features that required the solution meta-data database. Tooltips for static resources, image assets and dynamic resources. New IntelliSense suggestions. Static resources. Dynamic resources. Image assets. Analysis integration for static resources and missing images. The performance of the image manager is now significantly improved due to the meta-data engine being integrated. The image manager is now able to watch for images being added/removed and update itself to show these changes. Reduced VSIX size by removing unused assets. Issues Fixed: Fixed: The delete image asset tool no longer locks up the IDE.","title":"v0.4"},{"location":"release-notes/windows/v0/v0.4/#v040","text":"Released on February 4th 2020 MFractor for Visual Studio Windows v0.4 is a major upgrade from v0.3, shifting significantly closer to a stable release. This release integrates our workspace events and data engines to activate all features related to static resources (analysis, code actions, tooltips and IntelliSense) and image assets (analysis, code actions, tooltips and IntelliSense). Officially, this product release is known as MFractor for Visual Studio Windows - Preview 4 . Preview 4 : The workspace events engine is now integrated, having flow on effects to enable several other core systems and features. The meta-data engine is now integrated and switches on many remaining features that required the solution meta-data database. Tooltips for static resources, image assets and dynamic resources. New IntelliSense suggestions. Static resources. Dynamic resources. Image assets. Analysis integration for static resources and missing images. The performance of the image manager is now significantly improved due to the meta-data engine being integrated. The image manager is now able to watch for images being added/removed and update itself to show these changes. Reduced VSIX size by removing unused assets. Issues Fixed: Fixed: The delete image asset tool no longer locks up the IDE.","title":"v0.4.0"},{"location":"release-notes/windows/v0/v0.5/","text":"Release notes for our 0.5 versions of MFractor for Visual Studio Windows v0.5.0 Released on February 11th 2020 MFractor for Visual Studio Windows v0.5 is an incremental upgrade from v0.4, focusing on performance, stability and improving feature parity with MFractor for Visual Studio Mac This release enables data-binding IntelliSense using our powerful view model resolution engine, adds a new onboarding experience and fixes several bugs in our image tooltips. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 5 . Preview 5 : Adds support for view model property IntelliSense. Adds a new onboarding dialog. Add Manage Image Assets to the solution explorer menu. Issues Fixed: Fixed: Image tooltips in C# would not appear.","title":"v0.5"},{"location":"release-notes/windows/v0/v0.5/#v050","text":"Released on February 11th 2020 MFractor for Visual Studio Windows v0.5 is an incremental upgrade from v0.4, focusing on performance, stability and improving feature parity with MFractor for Visual Studio Mac This release enables data-binding IntelliSense using our powerful view model resolution engine, adds a new onboarding experience and fixes several bugs in our image tooltips. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 5 . Preview 5 : Adds support for view model property IntelliSense. Adds a new onboarding dialog. Add Manage Image Assets to the solution explorer menu. Issues Fixed: Fixed: Image tooltips in C# would not appear.","title":"v0.5.0"},{"location":"release-notes/windows/v0/v0.6/","text":"Release notes for our 0.6 versions of MFractor for Visual Studio Windows v0.6.0 Released on February 12th 2020 MFractor for Visual Studio Windows v0.5 fixes a bug in the request license workflow where license requests would not go through. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 6 .","title":"v0.6"},{"location":"release-notes/windows/v0/v0.6/#v060","text":"Released on February 12th 2020 MFractor for Visual Studio Windows v0.5 fixes a bug in the request license workflow where license requests would not go through. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 6 .","title":"v0.6.0"},{"location":"release-notes/windows/v4/v4.0/","text":"Release notes for our 4.0 versions of MFractor for Visual Studio Windows v4.0.17 Released on May 11th 2020 Service release to fix a crash caused by color adornments. Issues Fixed: Fixed: When duplicate color resources are available to a document, do not crash the editor. v4.0.16 Released on May 10th 2020 Service release to include automatic 30-day trials. v4.0.14 Released on May 7th 2020 Service release to fix issues with image management on Windows. Issues Fixed: Fixed: The image importer would fail to open when a UWP project is within the solution. Fixed: Scaled UWP images are now grouped in the image importer. v4.0.14 Released on May 4th 2020 Service release to add adornments for XAML in Visual Studio Windows. Features Grid index adornments. Color adornments. Escaped XAML character adornments. v4.0.13 Released on April 20th 2020 Service release to add new XAML analysers and improved performance for the XAML analyser. Features Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished. v4.0.12 Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work on Windows. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties. v4.0.11 Released on April 14th 2020 Hotfix release to fix image manager list items not appearing. Issues Fixed: Fixed: The images listed by the image manager would not appear correctly. v4.0.10 Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors. v4.0.9 Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times. v4.0.6 Released on 24th of March 2020 Service release to add insert/delete row and column actions. Features Insert row/column code actions. Delete row/column code actions. Enhancements New code fix to remove all redundant grid row and columns. v4.0.5 Released on 19th of March 2020 Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 . v4.0.4 Released on 17th of March 2020 Fixes an issue where trial license requests were not going through. v4.0.3 Released on 10th of March 2020 Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . Issues Fixed: Fixed: Hint window in dark mode for VS Win has low contrast. #193 Fixed: Image managers image no longer appeared. v4.0.2 Released on 2nd of March 2020 Adds x:DataType support to binding context resolution. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType. v4.0.1 Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. Fixed: Fixed issues where sometimes project files would not synchronise and features like manage images or MVVM navigation would stop working v4.0.0 Released on February 20th 2020 The v4.0 release of MFractor for Visual Studio is the stable release of MFractor, reaching approximate feature parity with MFractor for Visual Studio Mac. At a glance, MFractor for Visual Studio Windows offers: A powerful XAML feature suite makes it faster and easier to writing beautiful XAML. Write better XAML, faster with supercharged IntelliSense. MFractor suggests ViewModel properties, image assets, short cut completions for grids, setters and trigger plus much more. Over 80 XAML analysers find a huge range of bugs, improvements, code smells and maintainability issues. Even better, you can often fix an issue with a single click. Over 100 XAML code actions make it dead easy to refactor and cleanup your XAML. Custom tooltips give you deeper insight into your codebase. Preview image assets, colour and static resources! MFractors image management tool suite lets you import new Android and iOS assets in seconds, delete images across all projects and visually browse all assets in your solution. Wizards for importing fonts, generating view models, creating value converters, bindable properties, interface implementations and much more.","title":"v4.0"},{"location":"release-notes/windows/v4/v4.0/#v4017","text":"Released on May 11th 2020 Service release to fix a crash caused by color adornments. Issues Fixed: Fixed: When duplicate color resources are available to a document, do not crash the editor.","title":"v4.0.17"},{"location":"release-notes/windows/v4/v4.0/#v4016","text":"Released on May 10th 2020 Service release to include automatic 30-day trials.","title":"v4.0.16"},{"location":"release-notes/windows/v4/v4.0/#v4014","text":"Released on May 7th 2020 Service release to fix issues with image management on Windows. Issues Fixed: Fixed: The image importer would fail to open when a UWP project is within the solution. Fixed: Scaled UWP images are now grouped in the image importer.","title":"v4.0.14"},{"location":"release-notes/windows/v4/v4.0/#v4014_1","text":"Released on May 4th 2020 Service release to add adornments for XAML in Visual Studio Windows. Features Grid index adornments. Color adornments. Escaped XAML character adornments.","title":"v4.0.14"},{"location":"release-notes/windows/v4/v4.0/#v4013","text":"Released on April 20th 2020 Service release to add new XAML analysers and improved performance for the XAML analyser. Features Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished.","title":"v4.0.13"},{"location":"release-notes/windows/v4/v4.0/#v4012","text":"Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work on Windows. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties.","title":"v4.0.12"},{"location":"release-notes/windows/v4/v4.0/#v4011","text":"Released on April 14th 2020 Hotfix release to fix image manager list items not appearing. Issues Fixed: Fixed: The images listed by the image manager would not appear correctly.","title":"v4.0.11"},{"location":"release-notes/windows/v4/v4.0/#v4010","text":"Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors.","title":"v4.0.10"},{"location":"release-notes/windows/v4/v4.0/#v409","text":"Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings.","title":"v4.0.9"},{"location":"release-notes/windows/v4/v4.0/#v408","text":"Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times.","title":"v4.0.8"},{"location":"release-notes/windows/v4/v4.0/#v406","text":"Released on 24th of March 2020 Service release to add insert/delete row and column actions. Features Insert row/column code actions. Delete row/column code actions. Enhancements New code fix to remove all redundant grid row and columns.","title":"v4.0.6"},{"location":"release-notes/windows/v4/v4.0/#v405","text":"Released on 19th of March 2020 Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 .","title":"v4.0.5"},{"location":"release-notes/windows/v4/v4.0/#v404","text":"Released on 17th of March 2020 Fixes an issue where trial license requests were not going through.","title":"v4.0.4"},{"location":"release-notes/windows/v4/v4.0/#v403","text":"Released on 10th of March 2020 Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . Issues Fixed: Fixed: Hint window in dark mode for VS Win has low contrast. #193 Fixed: Image managers image no longer appeared.","title":"v4.0.3"},{"location":"release-notes/windows/v4/v4.0/#v402","text":"Released on 2nd of March 2020 Adds x:DataType support to binding context resolution. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType.","title":"v4.0.2"},{"location":"release-notes/windows/v4/v4.0/#v401","text":"Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. Fixed: Fixed issues where sometimes project files would not synchronise and features like manage images or MVVM navigation would stop working","title":"v4.0.1"},{"location":"release-notes/windows/v4/v4.0/#v400","text":"Released on February 20th 2020 The v4.0 release of MFractor for Visual Studio is the stable release of MFractor, reaching approximate feature parity with MFractor for Visual Studio Mac. At a glance, MFractor for Visual Studio Windows offers: A powerful XAML feature suite makes it faster and easier to writing beautiful XAML. Write better XAML, faster with supercharged IntelliSense. MFractor suggests ViewModel properties, image assets, short cut completions for grids, setters and trigger plus much more. Over 80 XAML analysers find a huge range of bugs, improvements, code smells and maintainability issues. Even better, you can often fix an issue with a single click. Over 100 XAML code actions make it dead easy to refactor and cleanup your XAML. Custom tooltips give you deeper insight into your codebase. Preview image assets, colour and static resources! MFractors image management tool suite lets you import new Android and iOS assets in seconds, delete images across all projects and visually browse all assets in your solution. Wizards for importing fonts, generating view models, creating value converters, bindable properties, interface implementations and much more.","title":"v4.0.0"},{"location":"release-notes/windows/v4/v4.1/","text":"Release notes for our 4.1 versions of MFractor for Visual Studio Windows v4.1.3 Released on May 18th 2020 Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. Enhancements: Show license expiry notifications at 14, 7 and 1 days for both Professional and Trial licenses. Issues Fixed: Fixed: Fix integration issues for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Replace duplicate namespace references does nothing. #211 v4.1.2 Released on May 17th 2020 Service release to fix several small issues in the code actions Alt+Return menu. Features Code fix that migrates Icon to IconImageSource. Issues Fixed: Fixed: The remove all redundant properties style fix did not work. Fixed: Go To ViewModel is not honouring x:DataType. #209 v4.1.1 Released on May 16th 2020 Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. Features The Scaffolder is a file creation wizard that infers your intended file type based on the provided name and file extension plus the context that you are creating that new file in. Disable XAML analysers at the document level using the following syntax: <!-- [MFractor: Suppress(MF1000)] --> or <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] --> . #202 The Move Attribute To Parent can move a matching attribute from an element into it's parent (EG: Margin=\"10\" set on a label inside a stack layout will be removed from the label and then added to the StackLayout). You can now edit a color adornment and launch the color editor. #199 Issues Fixed: Fixed: Binding Context Initialise in XAML sets x:Key instead of x:Name. #207 Fixed: Get binding IntelliSense using x:DataType provided at the root level. #201 Fixed: 404 for code action Learn how MFractor detects your ViewModels and Binding. #205 Fixed: Grid indexes clipped on 15\" macbook. #197 Fixed: Using Value Converter Wizard to add converter to page created duplicate xmlns. #204 v4.1.0 Released on May 12th 2020 MFractor 4.1 for Visual Studio Windows is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. For a full summary of all features included in 4.1, please see the v4.0 release notes .","title":"v4.1"},{"location":"release-notes/windows/v4/v4.1/#v413","text":"Released on May 18th 2020 Service release to activate license expiry notification and fix integration issues in the code actions Alt+Return menu. Enhancements: Show license expiry notifications at 14, 7 and 1 days for both Professional and Trial licenses. Issues Fixed: Fixed: Fix integration issues for MFractors XAML code actions are not accessible through the \"Option+Return\" menu. #145 Fixed: Replace duplicate namespace references does nothing. #211","title":"v4.1.3"},{"location":"release-notes/windows/v4/v4.1/#v412","text":"Released on May 17th 2020 Service release to fix several small issues in the code actions Alt+Return menu. Features Code fix that migrates Icon to IconImageSource. Issues Fixed: Fixed: The remove all redundant properties style fix did not work. Fixed: Go To ViewModel is not honouring x:DataType. #209","title":"v4.1.2"},{"location":"release-notes/windows/v4/v4.1/#v411","text":"Released on May 16th 2020 Service release to fix multiple user reported bugs, adds the ability to disable analysers at a document level, color adornment editing support and moves the scaffolder out of preview. Features The Scaffolder is a file creation wizard that infers your intended file type based on the provided name and file extension plus the context that you are creating that new file in. Disable XAML analysers at the document level using the following syntax: <!-- [MFractor: Suppress(MF1000)] --> or <!-- [MFractor: Suppress(com.mfractor.analysis.xaml.binding_expression_resolves)] --> . #202 The Move Attribute To Parent can move a matching attribute from an element into it's parent (EG: Margin=\"10\" set on a label inside a stack layout will be removed from the label and then added to the StackLayout). You can now edit a color adornment and launch the color editor. #199 Issues Fixed: Fixed: Binding Context Initialise in XAML sets x:Key instead of x:Name. #207 Fixed: Get binding IntelliSense using x:DataType provided at the root level. #201 Fixed: 404 for code action Learn how MFractor detects your ViewModels and Binding. #205 Fixed: Grid indexes clipped on 15\" macbook. #197 Fixed: Using Value Converter Wizard to add converter to page created duplicate xmlns. #204","title":"v4.1.1"},{"location":"release-notes/windows/v4/v4.1/#v410","text":"Released on May 12th 2020 MFractor 4.1 for Visual Studio Windows is a major release that adds automatic 30-day trials, adornments, font tooling, additional XAML analysers and much more. For a full summary of all features included in 4.1, please see the v4.0 release notes .","title":"v4.1.0"},{"location":"release-notes/windows/v4/v4.2/","text":"Release notes for our 4.2 versions of MFractor for Visual Studio Windows v4.2.12 Released on August 2nd 2020 Preview release for MFractor 4.3. Release notes pending. v4.2.11 Released on July 20th 2020 Service release to fix exported font bugs. Issues Fixed: Fixed: [Suggestion] Font embed failure. #275 Fixed: [Bug] Move color to local resource always wraps in a new ResourceDictionary #273 v4.2.10 Released on July 14th 2020 Service release to fix customer reported bugs and improve the XAML editor performance when MFractor is enabled. Issues Fixed: Fixed: The XAML analyser would sometimes analyse a file twice per file-edit. Fixed: We've improved the XAML analyser's efficiency by reducing the amount of analysis passes required per node and attribute. Fixed: Support Style in a different assembly. #246 Fixed: Code Action: Encapsulate element with layout container. #188 Fixed: Allow files to be included/excluded on the image deletion tool. #177 v4.2.9 Released on July 12th 2020 Service release to fix customer reported bugs. Issues Fixed: Fixed: Add Image Tooling support for iOS projects. #190 Fixed: Exclude from link can't add entry to linker.xml . #265 Fixed: MVVM Wizard is disabled unless a file is opened. #251 Fixed: Import Image Asset doesn't work in very large solutions. #257 v4.2.8 Released on July 7th 2020 Service release to improve performance of XAML analysis engine and reduce memory consumption. Issues Fixed: Fixed: Reduced the amount of threads MFractor uses when analysing XAML files to improve IDE responsiveness. Fixed: Add 'Open Android Manifest' to Windows version. #267 v4.2.7 Released on July 1st 2020 Service release to resolve several customer reported bugs and add tooltips for colors/images. Features: Image tooltips for C# string image references. Color tooltips for C# string color values (hex and named color formats). Issues Fixed: Fixed: When a XAML Control is Extracted on Windows the Code-behind is not nested. #229 Fixed: Color Tooltips are too large on Windows. #231 Fixed: Windows: License dialog displays the serial key entry incorrectly. #263 Fixed: Scaffold Page/Content page. #266 v4.2.6 Released on June 25th 2020 Service release to resolve several customer reported bugs. Features: When a CollectionView uses the GroupHeaderTemplate and/or GroupFooterTemplate , however, it does not set IsGrouped to true, we have added a new code analyser to warn that the grouping will not display. Issues Fixed: Fixed: Pickers ItemDisplayBinding property uses the incorrect binding context for analysis and Intellisense. #262 Fixed: Regression in row and column tooltips, analysis and Intellisense when a row or column does not define its size. Fixed: Welcome screen clipping issues. #210 v4.2.5 Released on June 22nd 2020 Service release to fix users being unable to activate MFractor Lite. Issues Fixed: Fixed: Unable to activate MFractor Lite. Fixed: Regression in row and column span analysis. v4.2.4 Released on June 19th 2020 Service release to resolve several customer reported issues, add grid shorthand parsing support, add features for copying bundle ids to the clipboard and a command to add an export font declaration for new fonts. Features: Copy iOS projects bundle identifier from the Solution Explorer. Documentation . #250 Support for Xamarin.Forms 4.7 grid shorthand declarations. [#232])(https://github.com/mfractor/mfractor-feedback/issues/232) Create a tools menu command that can add an ExportFont declaration for a font file. #249 Issues Fixed: Navigate to ViewModel doesn't work if it's in a different project. #254 , #255 Deactivate License Text Bug not appearing on a new line. #252 Delete Image won't work on last version of MFractor. #253 , #228 v4.2.3 Released on June 9th 2020 Version alignment release with MFractor for Visual Studio Mac. v4.2.2 Released on June 8th 2020 Service release to add initial support for Blazor/Razor. Features: Web scaffolders. #222 Blazor Page scaffolder. Blazor component scaffolder. ASP.NET API Controller. #242 Blazor: Code Behind HotKey Navigation. #214 Issues Fixed: Fixed: Integrate a Help Url into the Scaffolder. #236 Fixed: Integrate the Scaffolder into Visual Studio for Windows. #235 Fixed: Deactivate License Bug. #240 Fixed: URL incorrect for scaffolding .razor.cs. #244 Fixed: Scaffolder .razor.cs strange class names #243 Fixed: When using .razor.cs extension with scaffolder, it creates a .razor file but no code behind for pages. #241 Fixed: Scaffolder list incorrect if i use .razor.cs extension. #239 Fixed: Color Tooltips are behaving inconsistently for Setters. #230 v4.2.1 Released on May 29th 2020 Service release to improve the UX of the Scaffolder. Issues Fixed: Fixed: Enter key submit in Scaffolder. #223 Fixed: Scaffolder hot key. #225 v4.2.0 Released on May 27th 2020 MFractor 4.2 for Visual Studio Windows is a major release that adds support for Visual Studio 16.6, serial key license activation and fixes several bugs in the core product. Features MFractor now supports license activation via serial key. When you purchase an MFractor Professional license, you will now receive a serial key instead of a license file. MFractor now offers license recovery from within the product. Head to the top MFractor menu, choose Recover MFractor Professional License and then enter your email. If a license is available for that email, you will receive a license recovery email. Issues Fixed: Fixed: Visual Studio Windows 16.6 support. #217 Fixed: MFractor doesn't check for Android Vector Drawable files when validating images. #219 . Fixed: Create class from clipboard enhancements [#208])(https://github.com/mfractor/mfractor-feedback/issues/208) Fixed: VS Mac freezing/not responding (Core engine issues). [#221])(https://github.com/mfractor/mfractor-feedback/issues/221)","title":"v4.2"},{"location":"release-notes/windows/v4/v4.2/#v4212","text":"Released on August 2nd 2020 Preview release for MFractor 4.3. Release notes pending.","title":"v4.2.12"},{"location":"release-notes/windows/v4/v4.2/#v4211","text":"Released on July 20th 2020 Service release to fix exported font bugs. Issues Fixed: Fixed: [Suggestion] Font embed failure. #275 Fixed: [Bug] Move color to local resource always wraps in a new ResourceDictionary #273","title":"v4.2.11"},{"location":"release-notes/windows/v4/v4.2/#v4210","text":"Released on July 14th 2020 Service release to fix customer reported bugs and improve the XAML editor performance when MFractor is enabled. Issues Fixed: Fixed: The XAML analyser would sometimes analyse a file twice per file-edit. Fixed: We've improved the XAML analyser's efficiency by reducing the amount of analysis passes required per node and attribute. Fixed: Support Style in a different assembly. #246 Fixed: Code Action: Encapsulate element with layout container. #188 Fixed: Allow files to be included/excluded on the image deletion tool. #177","title":"v4.2.10"},{"location":"release-notes/windows/v4/v4.2/#v429","text":"Released on July 12th 2020 Service release to fix customer reported bugs. Issues Fixed: Fixed: Add Image Tooling support for iOS projects. #190 Fixed: Exclude from link can't add entry to linker.xml . #265 Fixed: MVVM Wizard is disabled unless a file is opened. #251 Fixed: Import Image Asset doesn't work in very large solutions. #257","title":"v4.2.9"},{"location":"release-notes/windows/v4/v4.2/#v428","text":"Released on July 7th 2020 Service release to improve performance of XAML analysis engine and reduce memory consumption. Issues Fixed: Fixed: Reduced the amount of threads MFractor uses when analysing XAML files to improve IDE responsiveness. Fixed: Add 'Open Android Manifest' to Windows version. #267","title":"v4.2.8"},{"location":"release-notes/windows/v4/v4.2/#v427","text":"Released on July 1st 2020 Service release to resolve several customer reported bugs and add tooltips for colors/images. Features: Image tooltips for C# string image references. Color tooltips for C# string color values (hex and named color formats). Issues Fixed: Fixed: When a XAML Control is Extracted on Windows the Code-behind is not nested. #229 Fixed: Color Tooltips are too large on Windows. #231 Fixed: Windows: License dialog displays the serial key entry incorrectly. #263 Fixed: Scaffold Page/Content page. #266","title":"v4.2.7"},{"location":"release-notes/windows/v4/v4.2/#v426","text":"Released on June 25th 2020 Service release to resolve several customer reported bugs. Features: When a CollectionView uses the GroupHeaderTemplate and/or GroupFooterTemplate , however, it does not set IsGrouped to true, we have added a new code analyser to warn that the grouping will not display. Issues Fixed: Fixed: Pickers ItemDisplayBinding property uses the incorrect binding context for analysis and Intellisense. #262 Fixed: Regression in row and column tooltips, analysis and Intellisense when a row or column does not define its size. Fixed: Welcome screen clipping issues. #210","title":"v4.2.6"},{"location":"release-notes/windows/v4/v4.2/#v425","text":"Released on June 22nd 2020 Service release to fix users being unable to activate MFractor Lite. Issues Fixed: Fixed: Unable to activate MFractor Lite. Fixed: Regression in row and column span analysis.","title":"v4.2.5"},{"location":"release-notes/windows/v4/v4.2/#v424","text":"Released on June 19th 2020 Service release to resolve several customer reported issues, add grid shorthand parsing support, add features for copying bundle ids to the clipboard and a command to add an export font declaration for new fonts. Features: Copy iOS projects bundle identifier from the Solution Explorer. Documentation . #250 Support for Xamarin.Forms 4.7 grid shorthand declarations. [#232])(https://github.com/mfractor/mfractor-feedback/issues/232) Create a tools menu command that can add an ExportFont declaration for a font file. #249 Issues Fixed: Navigate to ViewModel doesn't work if it's in a different project. #254 , #255 Deactivate License Text Bug not appearing on a new line. #252 Delete Image won't work on last version of MFractor. #253 , #228","title":"v4.2.4"},{"location":"release-notes/windows/v4/v4.2/#v423","text":"Released on June 9th 2020 Version alignment release with MFractor for Visual Studio Mac.","title":"v4.2.3"},{"location":"release-notes/windows/v4/v4.2/#v422","text":"Released on June 8th 2020 Service release to add initial support for Blazor/Razor. Features: Web scaffolders. #222 Blazor Page scaffolder. Blazor component scaffolder. ASP.NET API Controller. #242 Blazor: Code Behind HotKey Navigation. #214 Issues Fixed: Fixed: Integrate a Help Url into the Scaffolder. #236 Fixed: Integrate the Scaffolder into Visual Studio for Windows. #235 Fixed: Deactivate License Bug. #240 Fixed: URL incorrect for scaffolding .razor.cs. #244 Fixed: Scaffolder .razor.cs strange class names #243 Fixed: When using .razor.cs extension with scaffolder, it creates a .razor file but no code behind for pages. #241 Fixed: Scaffolder list incorrect if i use .razor.cs extension. #239 Fixed: Color Tooltips are behaving inconsistently for Setters. #230","title":"v4.2.2"},{"location":"release-notes/windows/v4/v4.2/#v421","text":"Released on May 29th 2020 Service release to improve the UX of the Scaffolder. Issues Fixed: Fixed: Enter key submit in Scaffolder. #223 Fixed: Scaffolder hot key. #225","title":"v4.2.1"},{"location":"release-notes/windows/v4/v4.2/#v420","text":"Released on May 27th 2020 MFractor 4.2 for Visual Studio Windows is a major release that adds support for Visual Studio 16.6, serial key license activation and fixes several bugs in the core product. Features MFractor now supports license activation via serial key. When you purchase an MFractor Professional license, you will now receive a serial key instead of a license file. MFractor now offers license recovery from within the product. Head to the top MFractor menu, choose Recover MFractor Professional License and then enter your email. If a license is available for that email, you will receive a license recovery email. Issues Fixed: Fixed: Visual Studio Windows 16.6 support. #217 Fixed: MFractor doesn't check for Android Vector Drawable files when validating images. #219 . Fixed: Create class from clipboard enhancements [#208])(https://github.com/mfractor/mfractor-feedback/issues/208) Fixed: VS Mac freezing/not responding (Core engine issues). [#221])(https://github.com/mfractor/mfractor-feedback/issues/221)","title":"v4.2.0"},{"location":"release-notes/windows/v4/v4.3/","text":"Release notes for our 4.3 versions of MFractor for Visual Studio Windoiws v4.3.0 Released on August 6th 2020 MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements. Features Navigation Tooltip Links : When MFractor can perform a navigation action for the current element, the new Navigate To link will appear in the tooltip. Code Analysis Help Links : When a code inspection has a help file available, you can now click on the Help link in the tooltip window to learn more about it. SVG Tooltips: Hover over an SVG file reference or SVG path data and MFractor will now show you a preview of that SVG. (Mac Only) Localisation Tooltips for C# and XAML: When a property maps to a .resx localisation lookup, MFractor will display a summary of all localisations for that key. DateTime Format Preview Tooltips : Hover over a data time format string to see a preview of it as DateTime.Now. Issues Fixed: Fixed: Add support for the XmlnsDefinition attribute #98 Fixed: The Create new Style code action should trigger the Create New Style window instead of a blank one. #277 Fixed: Unable to find Carousel IndicatorView (false warning). #289 Fixed: The NavigateToFileSpansWorkUnitHandler is not implemented (breaks go to custom renderer). #245 Fixed: Visual Studio Windows - Manage Image Assets - not populating. #291 Fixed: Scaffolder on VS Windows Code Preview and Scaffold list broken. #284 Fixed: Enhancement localisation tool. #134 When over a localisation expression, show localisation values summary in a tooltip. Go to definition support for localisation expressions. Code action to move a string literal to a RESX file (new or existing). Ongoing performance and memory improvements: Removing (most) usages of Task.Run to prevent MFractor generating unnecessary threads. Pre-caching/pre-populating as much state as possible when performing XAML analysis. More use of Lazy<T> to defer or avoid the cost of expensive resolution operations. Code output previews for the Generate Customer Renderers and Exclude From Linking features. XAML Localisation: Removed dependency on deprecated ILocalise methodology and moved to .resx files methodology. See Xamarin.Forms String and Image Localization .","title":"v4.3"},{"location":"release-notes/windows/v4/v4.3/#v430","text":"Released on August 6th 2020 MFractor 4.3 is a major release that adds includes several new features for tooltips plus lots of bug fixes and overall product improvements. Features Navigation Tooltip Links : When MFractor can perform a navigation action for the current element, the new Navigate To link will appear in the tooltip. Code Analysis Help Links : When a code inspection has a help file available, you can now click on the Help link in the tooltip window to learn more about it. SVG Tooltips: Hover over an SVG file reference or SVG path data and MFractor will now show you a preview of that SVG. (Mac Only) Localisation Tooltips for C# and XAML: When a property maps to a .resx localisation lookup, MFractor will display a summary of all localisations for that key. DateTime Format Preview Tooltips : Hover over a data time format string to see a preview of it as DateTime.Now. Issues Fixed: Fixed: Add support for the XmlnsDefinition attribute #98 Fixed: The Create new Style code action should trigger the Create New Style window instead of a blank one. #277 Fixed: Unable to find Carousel IndicatorView (false warning). #289 Fixed: The NavigateToFileSpansWorkUnitHandler is not implemented (breaks go to custom renderer). #245 Fixed: Visual Studio Windows - Manage Image Assets - not populating. #291 Fixed: Scaffolder on VS Windows Code Preview and Scaffold list broken. #284 Fixed: Enhancement localisation tool. #134 When over a localisation expression, show localisation values summary in a tooltip. Go to definition support for localisation expressions. Code action to move a string literal to a RESX file (new or existing). Ongoing performance and memory improvements: Removing (most) usages of Task.Run to prevent MFractor generating unnecessary threads. Pre-caching/pre-populating as much state as possible when performing XAML analysis. More use of Lazy<T> to defer or avoid the cost of expensive resolution operations. Code output previews for the Generate Customer Renderers and Exclude From Linking features. XAML Localisation: Removed dependency on deprecated ILocalise methodology and moved to .resx files methodology. See Xamarin.Forms String and Image Localization .","title":"v4.3.0"},{"location":"utilities/clean-and-compress/","text":"Quickly create a zip archive for solution or projects Introduction The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac. Archiving Solutions To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop. Archiving Projects To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop. Example","title":"Clean And Compress"},{"location":"utilities/clean-and-compress/#introduction","text":"The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/clean-and-compress/#archiving-solutions","text":"To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop.","title":"Archiving Solutions"},{"location":"utilities/clean-and-compress/#archiving-projects","text":"To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop.","title":"Archiving Projects"},{"location":"utilities/clean-and-compress/#example","text":"","title":"Example"},{"location":"utilities/copy-resource-id-to-clipboard/","text":"Copy the identifier an embedded resource to the clipboard Introduction When we use embedded resources in our .NET projects, we Example","title":"Copy resource id to clipboard"},{"location":"utilities/copy-resource-id-to-clipboard/#introduction","text":"When we use embedded resources in our .NET projects, we","title":"Introduction"},{"location":"utilities/copy-resource-id-to-clipboard/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/","text":"Remove the working and output folders for a solution or project Introduction The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac. Using Delete Output Folders To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system. Example Configuring Delete Output Folders The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Delete Output Folders"},{"location":"utilities/delete-output-folders/#introduction","text":"The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/delete-output-folders/#using-delete-output-folders","text":"To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system.","title":"Using Delete Output Folders"},{"location":"utilities/delete-output-folders/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/#configuring-delete-output-folders","text":"The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Configuring Delete Output Folders"},{"location":"utilities/edit-shared-project-items/","text":"Edit the msbuild for a shared project Introduction One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to. Editing Shared Project Items Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Edit Shared Project Items"},{"location":"utilities/edit-shared-project-items/#introduction","text":"One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to.","title":"Introduction"},{"location":"utilities/edit-shared-project-items/#editing-shared-project-items","text":"Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Editing Shared Project Items"},{"location":"utilities/resync-mfractor-resources/","text":"Synchronizes important metadata used by MFractor features. Introduction Mfractor keeps an internal database of metadata about the solution that you're working on that is used to speed up several features. It is created and synchronized automatically and for the most part it should be invisible to end-user. But there are times that this database may be out of sync, impacting on the usage of some features. The Resync MFractor Solution Resources is a utility tool for MFractor internal maintenance that forces this synchronization procedures to run. It can be accessed by the Tools menu on the MFractor top menu: Resync command on macOS Resync command on Windows You don't need to use this option instead asked by MFractor support personal. You can also try to run it if you find some feature misbehaving, its safe a procedure and won't cause any harm to your project source files or your development environment.","title":"Resync Solution Resources"},{"location":"utilities/resync-mfractor-resources/#introduction","text":"Mfractor keeps an internal database of metadata about the solution that you're working on that is used to speed up several features. It is created and synchronized automatically and for the most part it should be invisible to end-user. But there are times that this database may be out of sync, impacting on the usage of some features. The Resync MFractor Solution Resources is a utility tool for MFractor internal maintenance that forces this synchronization procedures to run. It can be accessed by the Tools menu on the MFractor top menu: Resync command on macOS Resync command on Windows You don't need to use this option instead asked by MFractor support personal. You can also try to run it if you find some feature misbehaving, its safe a procedure and won't cause any harm to your project source files or your development environment.","title":"Introduction"},{"location":"xamarin-forms/automatic-type-inference/","text":"Use Type Inference to automatically select the desired type from a given component name. Automatic Type Inference Automatic Type Inference allows you to enter the desired name of a component and MFractor will guess the desired type. This dramatically simplifies and speeds up the process of creating new bindable properties, value converters or any component where the name often represents its given type. Once you adjust to type inference, you can simply enter the name of a new component and MFractor automatically sets up the type information based on known conventions. This makes it fast and intuitive to create new components and not need to worry about provide the type information. Rules Here is a full list of the rules the type inference engine uses when deducing types: Bool : Name starts with: is , can , has , should allow , show , include , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , title , message , name , character . Int : Name ends with: number , id , int , integer , count , size , width , height , spacing , length . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name starts with: enum . Xamarin.Forms.ImageSource : Input value ends with: .png , .gif , .jpg , .jpeg . Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , handler , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour . List : When the input name ends with s (IE: Is pluralised) and the name can be matched to a known type in the project, returns List<Name> .","title":"Automatic Type Inference"},{"location":"xamarin-forms/automatic-type-inference/#automatic-type-inference","text":"Automatic Type Inference allows you to enter the desired name of a component and MFractor will guess the desired type. This dramatically simplifies and speeds up the process of creating new bindable properties, value converters or any component where the name often represents its given type. Once you adjust to type inference, you can simply enter the name of a new component and MFractor automatically sets up the type information based on known conventions. This makes it fast and intuitive to create new components and not need to worry about provide the type information.","title":"Automatic Type Inference"},{"location":"xamarin-forms/automatic-type-inference/#rules","text":"Here is a full list of the rules the type inference engine uses when deducing types: Bool : Name starts with: is , can , has , should allow , show , include , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , title , message , name , character . Int : Name ends with: number , id , int , integer , count , size , width , height , spacing , length . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name starts with: enum . Xamarin.Forms.ImageSource : Input value ends with: .png , .gif , .jpg , .jpeg . Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , handler , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour . List : When the input name ends with s (IE: Is pluralised) and the name can be matched to a known type in the project, returns List<Name> .","title":"Rules"},{"location":"xamarin-forms/overview/","text":"Introduction MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite. Xamarin.Forms Features XAML Editor XAML IntelliSense . 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation. MVVM Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard. Search Static resource global search. Dynamic resource global search. AutomationID global search. Localisation Generating localisation infrastructure. Localising XAML files. Custom Renderers Finding custom renderers. Creating custom renderers. Custom Controls Creating bindable properties . Extracting XAML controls . Styles Extracting XAML styles. Style analysis. Value Converters Value converter wizard. Value converter analysis.","title":"Overview"},{"location":"xamarin-forms/overview/#introduction","text":"MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite.","title":"Introduction"},{"location":"xamarin-forms/overview/#xamarinforms-features","text":"","title":"Xamarin.Forms Features"},{"location":"xamarin-forms/overview/#xaml-editor","text":"XAML IntelliSense . 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation.","title":"XAML Editor"},{"location":"xamarin-forms/overview/#mvvm","text":"Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard.","title":"MVVM"},{"location":"xamarin-forms/overview/#search","text":"Static resource global search. Dynamic resource global search. AutomationID global search.","title":"Search"},{"location":"xamarin-forms/overview/#localisation","text":"Generating localisation infrastructure. Localising XAML files.","title":"Localisation"},{"location":"xamarin-forms/overview/#custom-renderers","text":"Finding custom renderers. Creating custom renderers.","title":"Custom Renderers"},{"location":"xamarin-forms/overview/#custom-controls","text":"Creating bindable properties . Extracting XAML controls .","title":"Custom Controls"},{"location":"xamarin-forms/overview/#styles","text":"Extracting XAML styles. Style analysis.","title":"Styles"},{"location":"xamarin-forms/overview/#value-converters","text":"Value converter wizard. Value converter analysis.","title":"Value Converters"},{"location":"xamarin-forms/xaml-intellisense/","text":"Introduction IntelliSense Features Data-Binding Grids Grids take a lot of boilerplate code, instead use the intellisense feature to write the code for you: This produces the following code to get you started: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid> Alongside the Grid there are the Row and Column definitions: <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"\" /> There are also Shorthand Declaration Refactorings to swap to the new simplified format. See the blog post for more details. Static Resources Dynamic Resources Navigation Intellisense Completions Global Search Capabilities Tooltips Images See Image Tooltips for more information. Colors You can scroll through a handy list of TextColor s provided by MFractor: DataTriggers Setter's StackLayout's There are a number a intellisense additions for StackLayout, these include: Name x:Name=\"\" Orientation Orientation=\"Horizontal\" Orientation=\"Vertical\"","title":"XAML IntelliSense"},{"location":"xamarin-forms/xaml-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/xaml-intellisense/#intellisense-features","text":"","title":"IntelliSense Features"},{"location":"xamarin-forms/xaml-intellisense/#data-binding","text":"","title":"Data-Binding"},{"location":"xamarin-forms/xaml-intellisense/#grids","text":"Grids take a lot of boilerplate code, instead use the intellisense feature to write the code for you: This produces the following code to get you started: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid> Alongside the Grid there are the Row and Column definitions: <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"\" /> There are also Shorthand Declaration Refactorings to swap to the new simplified format. See the blog post for more details.","title":"Grids"},{"location":"xamarin-forms/xaml-intellisense/#static-resources","text":"","title":"Static Resources"},{"location":"xamarin-forms/xaml-intellisense/#dynamic-resources","text":"Navigation Intellisense Completions Global Search Capabilities Tooltips","title":"Dynamic Resources"},{"location":"xamarin-forms/xaml-intellisense/#images","text":"See Image Tooltips for more information.","title":"Images"},{"location":"xamarin-forms/xaml-intellisense/#colors","text":"You can scroll through a handy list of TextColor s provided by MFractor:","title":"Colors"},{"location":"xamarin-forms/xaml-intellisense/#datatriggers","text":"","title":"DataTriggers"},{"location":"xamarin-forms/xaml-intellisense/#setters","text":"","title":"Setter's"},{"location":"xamarin-forms/xaml-intellisense/#stacklayouts","text":"There are a number a intellisense additions for StackLayout, these include: Name x:Name=\"\" Orientation Orientation=\"Horizontal\" Orientation=\"Vertical\"","title":"StackLayout's"},{"location":"xamarin-forms/analysis/code-behind-fields/","text":"Code inspections to verify declarations and usages of x:Name defined fields Introduction In XAML, we can use the x:Name directive to declare a code-behind field for the XAML element is applied to. Consider the following code: <ContentPage> <Label x:Name=\"myLabel\" Text=\"Hello World\"/> </ContentPage> The Label element will have a code behind field named myLabel generated by the XAML design tools. We can then use this field ( myLabel ) in our code behind class or reference it within the current XAML document via the x:Reference expression. There are various issues that can arise from using the x:Name directive and MFractor inspects for many known issues and provides code-fixes to resolve them. x:Name Has Invalid Characters As an x:Name directive declares a new code-behind field, it's value must follow C#'s identifier name restrictions . If we do not follow these restrictions, our code will not compile. If we enter an invalid name, MFractor will detect this and add a code error to inform you the x:Name value will cause a compilation error: Duplicate Code Behind Field Declarations MFractor will inspect all x:Name directives and validate that they are unique within the document. As the x:Name directive creates a new code-behind field, duplicate x:Name values will also create duplicate fields with the same name, causing a C# compiler error. Empty Code Behind Field Declaration MFractor will inspect all x:Name directives and validate that they have a value; excluding a value from the x:Name attribute will generate a compiler error: Verify Referenced Code Behind Field Exists We can use the x:Reference expression to retrieve the instance of a code-behind field declared via the x:Name directive. This is commonly usedto set BindingContext of an element to another control in the visual tree, enabling us to data-bind to a property on that control. For example: <Switch x:Name=\"switch\" /> <Label BindingContext=\"{x:Reference switch}\" IsVisible=\"{Binding IsToggled}\" Text=\"Hello World!\"/> In the above example, we are control the visibility of the Label through the IsToggled property on the Switch . MFractor will inspect usages of the x:Reference expression and verify that the referenced element is defined in the current document using x:Name : If the referenced code behind field name closely matches a known x:Name value, MFractor will suggest a code fix to autocorrect the typo to this name.","title":"Code Behind Fields"},{"location":"xamarin-forms/analysis/code-behind-fields/#introduction","text":"In XAML, we can use the x:Name directive to declare a code-behind field for the XAML element is applied to. Consider the following code: <ContentPage> <Label x:Name=\"myLabel\" Text=\"Hello World\"/> </ContentPage> The Label element will have a code behind field named myLabel generated by the XAML design tools. We can then use this field ( myLabel ) in our code behind class or reference it within the current XAML document via the x:Reference expression. There are various issues that can arise from using the x:Name directive and MFractor inspects for many known issues and provides code-fixes to resolve them.","title":"Introduction"},{"location":"xamarin-forms/analysis/code-behind-fields/#xname-has-invalid-characters","text":"As an x:Name directive declares a new code-behind field, it's value must follow C#'s identifier name restrictions . If we do not follow these restrictions, our code will not compile. If we enter an invalid name, MFractor will detect this and add a code error to inform you the x:Name value will cause a compilation error:","title":"x:Name Has Invalid Characters"},{"location":"xamarin-forms/analysis/code-behind-fields/#duplicate-code-behind-field-declarations","text":"MFractor will inspect all x:Name directives and validate that they are unique within the document. As the x:Name directive creates a new code-behind field, duplicate x:Name values will also create duplicate fields with the same name, causing a C# compiler error.","title":"Duplicate Code Behind Field Declarations"},{"location":"xamarin-forms/analysis/code-behind-fields/#empty-code-behind-field-declaration","text":"MFractor will inspect all x:Name directives and validate that they have a value; excluding a value from the x:Name attribute will generate a compiler error:","title":"Empty Code Behind Field Declaration"},{"location":"xamarin-forms/analysis/code-behind-fields/#verify-referenced-code-behind-field-exists","text":"We can use the x:Reference expression to retrieve the instance of a code-behind field declared via the x:Name directive. This is commonly usedto set BindingContext of an element to another control in the visual tree, enabling us to data-bind to a property on that control. For example: <Switch x:Name=\"switch\" /> <Label BindingContext=\"{x:Reference switch}\" IsVisible=\"{Binding IsToggled}\" Text=\"Hello World!\"/> In the above example, we are control the visibility of the Label through the IsToggled property on the Switch . MFractor will inspect usages of the x:Reference expression and verify that the referenced element is defined in the current document using x:Name : If the referenced code behind field name closely matches a known x:Name value, MFractor will suggest a code fix to autocorrect the typo to this name.","title":"Verify Referenced Code Behind Field Exists"},{"location":"xamarin-forms/analysis/collection-view/","text":"Code analysers for verifying the usage CollectionView's in XAML Introduction CollectionView Requires IsGrouped ViewCell Used Within CollectionView ItemTemplate","title":"Collection view"},{"location":"xamarin-forms/analysis/collection-view/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/analysis/collection-view/#collectionview-requires-isgrouped","text":"","title":"CollectionView Requires IsGrouped"},{"location":"xamarin-forms/analysis/collection-view/#viewcell-used-within-collectionview-itemtemplate","text":"","title":"ViewCell Used Within CollectionView ItemTemplate"},{"location":"xamarin-forms/analysis/invalid-newline-characters/","text":"Code inspections to spot C# style newlines used in XAML Introduction When initialising properties in XAML, we can use inline string values for properties such as labels. Sometimes we will need to create a line-break in these strings and we often enter the C# \\n character to do so. In XAML, however, we need to escape newline characters with the &#10; character sequence. As the escape sequence is difficult to remember, it is common to accidentally use C# newlines and cause rendering issues. Invalid Newline Detection MFractor will inspect string literal in your XAML and check for C# style newlines. If you have used a C# newline, \\n , MFractor will provide a warning that they should be escaped: Correcting Invalid Newlines When MFractor detects C# style newlines, you can also use the Escape newline characters code fix to change all occurances of \\n to &#10; :","title":"C# Newline Characters"},{"location":"xamarin-forms/analysis/invalid-newline-characters/#introduction","text":"When initialising properties in XAML, we can use inline string values for properties such as labels. Sometimes we will need to create a line-break in these strings and we often enter the C# \\n character to do so. In XAML, however, we need to escape newline characters with the &#10; character sequence. As the escape sequence is difficult to remember, it is common to accidentally use C# newlines and cause rendering issues.","title":"Introduction"},{"location":"xamarin-forms/analysis/invalid-newline-characters/#invalid-newline-detection","text":"MFractor will inspect string literal in your XAML and check for C# style newlines. If you have used a C# newline, \\n , MFractor will provide a warning that they should be escaped:","title":"Invalid Newline Detection"},{"location":"xamarin-forms/analysis/invalid-newline-characters/#correcting-invalid-newlines","text":"When MFractor detects C# style newlines, you can also use the Escape newline characters code fix to change all occurances of \\n to &#10; :","title":"Correcting Invalid Newlines"},{"location":"xamarin-forms/analysis/overview/","text":"Detect errors, improvements and maintainability suggestions for XAML files with powerful code analyzers. Introduction MFractor provides a set of powerful Code Analysis tools for XAML files. This aids you in detecting errors, identifying improvements and best practices for your code and keep your project maintanable. There are general purpose code analysis and others for specific features of Xamarin.Forms: Thickness Analysis","title":"Overview"},{"location":"xamarin-forms/analysis/overview/#introduction","text":"MFractor provides a set of powerful Code Analysis tools for XAML files. This aids you in detecting errors, identifying improvements and best practices for your code and keep your project maintanable. There are general purpose code analysis and others for specific features of Xamarin.Forms: Thickness Analysis","title":"Introduction"},{"location":"xamarin-forms/analysis/thickness-analysis/","text":"Aids in managing thickness declarations for paddings and margins. Introduction When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors. Thickness Analysis to the rescue! How The Analysis Works This analyzer inspects the active document scanning properties of the type Thickness and check if a declaration is repetitive among other XAML of the current project. If MFractor find the same thickness declaration 2 or more times, a warning is issued to let the user know of this duplication: From this warning users may have 2 actions:","title":"Thickness analysis"},{"location":"xamarin-forms/analysis/thickness-analysis/#introduction","text":"When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors. Thickness Analysis to the rescue!","title":"Introduction"},{"location":"xamarin-forms/analysis/thickness-analysis/#how-the-analysis-works","text":"This analyzer inspects the active document scanning properties of the type Thickness and check if a declaration is repetitive among other XAML of the current project. If MFractor find the same thickness declaration 2 or more times, a warning is issued to let the user know of this duplication: From this warning users may have 2 actions:","title":"How The Analysis Works"},{"location":"xamarin-forms/automation-ids/analysis/","text":"","title":"Analysis"},{"location":"xamarin-forms/automation-ids/search/","text":"","title":"Search"},{"location":"xamarin-forms/binding-context-resolution/automatic-viewmodel-detection/","text":"MFractor uses automatic ViewModel resolution to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention. Let's consider the following files: LoginPage.xaml - The XAML view. LoginPage.xaml.cs - The code behind for the XAML view. LoginViewModel - The a C# class that is the view model for the LoginPage view. Because these pages share the prefix Login and each has a distinct file extension or suffix, MFractor assumes the following relationships: The .xaml extension denotes that LoginPage.xaml is a xaml view. The .xaml.cs extension and the LoginPage component denotes that LoginPage.xaml.cs is the code behind implementation LoginPage view. The ViewModel suffix implies that LoginViewModel is a view model. When ViewModel is removed from LoginViewModel and Page is removed from LoginPage, the Login component implies that the LoginViewModel is related to the LoginPage XAML view and it's code behind file. MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that LoginViewModel will probably be the BindingContext for LoginPage. The Page <-> ViewModel naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM. The following suffixes are supported for XAML views: Page: EG LoginPage.xaml <-> LoginViewModel View: EG LoginView.xaml <-> LoginViewModel The following suffixes are supported for View Models. ViewModel: LoginPage.xaml <-> LoginViewModel PageModel: LoginView.xaml <-> LoginPageModel PageViewModel: LoginView.xaml <-> LoginPageViewModel Model: LoginView.xaml <-> LoginModel VM: LoginView.xaml <-> LoginVM PageVM: LoginView.xaml <-> LoginPageVM","title":"Automatic ViewModel Detection"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/","text":"Binding Context Evaluation In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: <Entry BindingContext=\"{x:Static local:MyStaticClass.MyStaticProperty}\"/> This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml <ContentPage xmlns:local=\"clr-namespace:MyApp;assembly=MyApp\" BindingContext=\"{x:Static local:ViewModelLocator.LoginViewModel}\"/> When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: <Switch x:Name=\"mySwitch\" /> <Label BindingContext=\"{x:Reference mySwitch}\" IsVisible=\"{Binding IsToggled}\"/> When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"BindingContext Evaluation"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/#binding-context-evaluation","text":"In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: <Entry BindingContext=\"{x:Static local:MyStaticClass.MyStaticProperty}\"/> This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml <ContentPage xmlns:local=\"clr-namespace:MyApp;assembly=MyApp\" BindingContext=\"{x:Static local:ViewModelLocator.LoginViewModel}\"/> When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: <Switch x:Name=\"mySwitch\" /> <Label BindingContext=\"{x:Reference mySwitch}\" IsVisible=\"{Binding IsToggled}\"/> When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"Binding Context Evaluation"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/","text":"Cross Project Binding Context Resolution If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id=\"com.mfractor.configuration.forms.mvvm_resolution\"> <property name=\"ViewModelsProjectName\" value=\"TODO: Insert the name of your view models project as it appears in the solution explorer\"/> </configure> </mfractor> In the project that contains your view models, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id=\"com.mfractor.configuration.forms.mvvm_resolution\"> <property name=\"ViewsProjectName\" value=\"TODO: Insert the name of your views project as it appears in the solution explorer\"/> </configure> </mfractor>","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/#cross-project-binding-context-resolution","text":"If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id=\"com.mfractor.configuration.forms.mvvm_resolution\"> <property name=\"ViewModelsProjectName\" value=\"TODO: Insert the name of your view models project as it appears in the solution explorer\"/> </configure> </mfractor> In the project that contains your view models, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id=\"com.mfractor.configuration.forms.mvvm_resolution\"> <property name=\"ViewsProjectName\" value=\"TODO: Insert the name of your views project as it appears in the solution explorer\"/> </configure> </mfractor>","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/","text":"Data Template Binding Context Resolution Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: <ListView ItemsSource=\"{Binding Contacts}\"> <ListView.ItemTemplate> <DataTemplate> <TextCell Text=\"{Binding DisplayName}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"DataTemplate Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/#data-template-binding-context-resolution","text":"Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: <ListView ItemsSource=\"{Binding Contacts}\"> <ListView.ItemTemplate> <DataTemplate> <TextCell Text=\"{Binding DisplayName}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"Data Template Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/","text":"Using The DesignTimeBindingContextAttribute It's possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To do so, begin by adding the following code file to your project: DesignTimeBindingContextAttribute.cs using System; namespace MyApp.Attributes { /// <summary> /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class DesignTimeBindingContextAttribute : Attribute { /// <summary> /// Specifies the design time binding context using a fully qualified type name. /// /// For example: MyApp.ViewModels.LoginViewModel. /// </summary> /// <param name=\"typeName\">The fully qualified type name for the design time binding context.</param> public DesignTimeBindingContextAttribute(string typeName) { } /// <summary> /// Specifies the design time binding context using typeof(). /// /// For example: typeof(LoginViewModel) /// </summary> /// <param name=\"type\">The <see cref=\"System.Type\"/> for the design time binding context, using typeof().</param> public DesignTimeBindingContextAttribute(Type type) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/#using-the-designtimebindingcontextattribute","text":"It's possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To do so, begin by adding the following code file to your project: DesignTimeBindingContextAttribute.cs using System; namespace MyApp.Attributes { /// <summary> /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class DesignTimeBindingContextAttribute : Attribute { /// <summary> /// Specifies the design time binding context using a fully qualified type name. /// /// For example: MyApp.ViewModels.LoginViewModel. /// </summary> /// <param name=\"typeName\">The fully qualified type name for the design time binding context.</param> public DesignTimeBindingContextAttribute(string typeName) { } /// <summary> /// Specifies the design time binding context using typeof(). /// /// For example: typeof(LoginViewModel) /// </summary> /// <param name=\"type\">The <see cref=\"System.Type\"/> for the design time binding context, using typeof().</param> public DesignTimeBindingContextAttribute(Type type) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/overview/","text":"Binding Context Resolution MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article. Resolution Methods MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/overview/#binding-context-resolution","text":"MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article.","title":"Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/overview/#resolution-methods","text":"MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Resolution Methods"},{"location":"xamarin-forms/colors/adornments/","text":"Visually preview color values inline in the XAML editor Introduction One of the challenges of working with colors in Xamarin.Forms Color Adornments Performance Impacts By default, color adornments are not enabled for the XAML editor. Due to rendering constraints, color adornments can have an adverse impact on IntelliSense performance. To enable color adornments, open MFractors Preferences and then go to Settings -> Feature Flags and toggle Color Adornments . Adornments Overview Hex Color Adornments When MFractor detects a hexadecimal color declaration, it will evaluate that color and inject a small preview of that color: Named Color Adornments When MFractor detects a color attribute that assigns a named color constant (such as Red, SlateBlue, Green etc), it will evaluate the named color and inject a small preview of that color: Static Resource Color Adornments When MFractor detects a static resource expression that returns a color resource, it will evaluate the static resource and inject a small preview of the declared color: Accessing The Color Editor To make it easier to edit a color declaration, MFractor includes a built-in color editor that you can use to visually create a new color. When a color adornment is present in XAML code, click on the color preview square to launch the editor.","title":"Adornments"},{"location":"xamarin-forms/colors/adornments/#introduction","text":"One of the challenges of working with colors in Xamarin.Forms Color Adornments Performance Impacts By default, color adornments are not enabled for the XAML editor. Due to rendering constraints, color adornments can have an adverse impact on IntelliSense performance. To enable color adornments, open MFractors Preferences and then go to Settings -> Feature Flags and toggle Color Adornments .","title":"Introduction"},{"location":"xamarin-forms/colors/adornments/#adornments-overview","text":"","title":"Adornments Overview"},{"location":"xamarin-forms/colors/adornments/#hex-color-adornments","text":"When MFractor detects a hexadecimal color declaration, it will evaluate that color and inject a small preview of that color:","title":"Hex Color Adornments"},{"location":"xamarin-forms/colors/adornments/#named-color-adornments","text":"When MFractor detects a color attribute that assigns a named color constant (such as Red, SlateBlue, Green etc), it will evaluate the named color and inject a small preview of that color:","title":"Named Color Adornments"},{"location":"xamarin-forms/colors/adornments/#static-resource-color-adornments","text":"When MFractor detects a static resource expression that returns a color resource, it will evaluate the static resource and inject a small preview of the declared color:","title":"Static Resource Color Adornments"},{"location":"xamarin-forms/colors/adornments/#accessing-the-color-editor","text":"To make it easier to edit a color declaration, MFractor includes a built-in color editor that you can use to visually create a new color. When a color adornment is present in XAML code, click on the color preview square to launch the editor.","title":"Accessing The Color Editor"},{"location":"xamarin-forms/colors/code-actions/","text":"Quick tools for refactoring colors and organizing them in the project. Introduction MFractor provides several code actions that allow you to change and refactor color declarations in your XAML documents and are available contextually on any property of the Color type. Add transparency channel to color Xamarin.Forms color system supports defining the opacity level of a color through the alpha channel. This is done by adding a hexadecimal component to the start of a hex color value. This action can be applied to color properties with hex literals, either the 3 or 6 digits variants ( #FFF or #FFFFFF ): By applying this action your MFractor will prefix it with 00 for the alpha channel. Convert named color to hex This action can be applied to named colors (such as White , Black , Red , etc.) to convert its declaration to its hex representation. By applying this action will result as the following examples: Named Color Hex Value White #FFFFFF Black #000000 Red #FF0000 Blue #00FF00 Green #0000FF Tip Named colors are defined on the Color struct of the Xamarin.Forms library. Check-out the docs to get a full list of named colors and its values. Edit color using color editor This action will present the MFractor Color Picker dialog that allows you to change the color using the channel sliders, while previewing in real-time. It can be applied to either named or hex literal color declarations: Once you have choosen the desired color just click choose and its value will be updated in code. You can also paste a hex value to the Color to preview it, and use the sliders to do any fine tunning.","title":"Color Code Actions"},{"location":"xamarin-forms/colors/code-actions/#introduction","text":"MFractor provides several code actions that allow you to change and refactor color declarations in your XAML documents and are available contextually on any property of the Color type.","title":"Introduction"},{"location":"xamarin-forms/colors/code-actions/#add-transparency-channel-to-color","text":"Xamarin.Forms color system supports defining the opacity level of a color through the alpha channel. This is done by adding a hexadecimal component to the start of a hex color value. This action can be applied to color properties with hex literals, either the 3 or 6 digits variants ( #FFF or #FFFFFF ): By applying this action your MFractor will prefix it with 00 for the alpha channel.","title":"Add transparency channel to color"},{"location":"xamarin-forms/colors/code-actions/#convert-named-color-to-hex","text":"This action can be applied to named colors (such as White , Black , Red , etc.) to convert its declaration to its hex representation. By applying this action will result as the following examples: Named Color Hex Value White #FFFFFF Black #000000 Red #FF0000 Blue #00FF00 Green #0000FF Tip Named colors are defined on the Color struct of the Xamarin.Forms library. Check-out the docs to get a full list of named colors and its values.","title":"Convert named color to hex"},{"location":"xamarin-forms/colors/code-actions/#edit-color-using-color-editor","text":"This action will present the MFractor Color Picker dialog that allows you to change the color using the channel sliders, while previewing in real-time. It can be applied to either named or hex literal color declarations: Once you have choosen the desired color just click choose and its value will be updated in code. You can also paste a hex value to the Color to preview it, and use the sliders to do any fine tunning.","title":"Edit color using color editor"},{"location":"xamarin-forms/colors/color-analysis/","text":"Inspect XAML color properties to validate color format and suggest refactorings for better organizing your color assets. Introduction MFractor includes several code analysers to aid on managing the colors in your Xamarin.Forms projects. Those analysers are applied to active XAML documents on the editor and will check any property of the Xamarin.Forms.Color Struct , including any custom or third-party component types. Color analysers helps you with the following types of issues and enhancements: Check for mispelled hex color formats. Check for mispelled color values. Identify colors declared as static resources. Identifying mispelled hex color formats Xamarin.Forms Color Type allows passing a hexadecimal color value in several different formats: #RRGGBB : A color with 32 bit (00-FF) Red, Green and Blue channels. #AARRGGBB : A color with 32 bit (00-FF) Alpha, Red, Green and Blue channels. #RGB : A color with 16 bit (0-F) Red, Green and Blue channels. #ARGB : A color with 16 bit (0-F) Alpha, Red, Green and Blue channels. The color code analysis will check for values begining with an # to verify if they fall on one of above supported formats. If a mispelling format is identified an warning will be shown to the editor. The warning tooltip allows you to invoke the Color Picker tool to pick a valid value for your property: The color picker is a very useful tool for quickly setting a valid color value. You can iterate to it by dragging the Red , Blue , Green and Alpha channels sliders or by directly typing an integer value to its respective boxes. The picker will try to identify an existing named color (one of the static read-only fields declared in the Xamarin.Forms.Color struct ) for the RGB value set, or you can also type one of those suggestions to imediately get the channels filled. By setting a color in the picker and clicking choose, MFractor will set the new value to the property. If the value represents one of the named colors this value will be used instead of the hex value. Example : type brown on the Color field and the picker channels will be automatically set to red 165, Green 42, Blue 42 and Alpha 255 that represents Color.Brown field value of #FFA52A2A . Fixing Mispelled Named Colors Visual Studio provides completion for the named colors on properties of the Color type, even though, typos may happen. This code analysis checks for non-hex values typed on the color properties and suggests fixes to similar named colors. Suppose you have a color property with value of Blu . This is an invalid color value because it doesn't represent a valid named color, nor a hex value and neither a resource reference. This will be thrown as an error at compile time, but with the MFractor code analysis you can identify this issue as you edit your file and get suggestions to quickly fix the issue: By hovering over the typo, the code analysis tooltip will show suggestions of names that closely match the mispelled one. Just click the link to have an instant fix. Applying Named Color to Equivalent hex value Hex values are a useful way of representing and sharing color value, but you can't easily figure a color value just by looking at it (unless you're a very experienced designer). For this reason, its useful to have named colors when they apply, so we can quickly identify what the color value is. This code analysis will check Color properties that has hex values declared to verify if they match one of the named colors available. Suppose you have an element that declares a color with the value #F5F5DC which matches to the Color.Beige named color. A warning will be shown to the color declaration to suggest replacing with the named version: Applying an Existing Color Resource Its a common pattern to set theme Color values at the Resources of the App.xaml file of a Xamarin.Forms project. MFractor can identify if an explicity hex value set to a color property matches an existing resource at any level it could be declared. Suppose you a have a Color entry for the primary color of your app theme, like below: <ResourceDictionary> <Color x:Key= \"primaryColor\" > #7BCCE5 </Color> </ResourceDictionary> At another part of the code, you add an item that will apply this color value, but you didn't remember about the Color resource you've declared before, and you simply copy the hex value over from your style guide: <BoxView Color= \"#7BCCE5\" /> If you hover over the squiggles of the code analysis warning, you'll find information about the existing static resource that matches the hex value you've just typed. You can click on the link for applying the change reference the resource. The color value will be replaced with the reference to the static resource: <BoxView Color= \"{StaticResource primaryColor}\" />","title":"Color Analysis"},{"location":"xamarin-forms/colors/color-analysis/#introduction","text":"MFractor includes several code analysers to aid on managing the colors in your Xamarin.Forms projects. Those analysers are applied to active XAML documents on the editor and will check any property of the Xamarin.Forms.Color Struct , including any custom or third-party component types. Color analysers helps you with the following types of issues and enhancements: Check for mispelled hex color formats. Check for mispelled color values. Identify colors declared as static resources.","title":"Introduction"},{"location":"xamarin-forms/colors/color-analysis/#identifying-mispelled-hex-color-formats","text":"Xamarin.Forms Color Type allows passing a hexadecimal color value in several different formats: #RRGGBB : A color with 32 bit (00-FF) Red, Green and Blue channels. #AARRGGBB : A color with 32 bit (00-FF) Alpha, Red, Green and Blue channels. #RGB : A color with 16 bit (0-F) Red, Green and Blue channels. #ARGB : A color with 16 bit (0-F) Alpha, Red, Green and Blue channels. The color code analysis will check for values begining with an # to verify if they fall on one of above supported formats. If a mispelling format is identified an warning will be shown to the editor. The warning tooltip allows you to invoke the Color Picker tool to pick a valid value for your property: The color picker is a very useful tool for quickly setting a valid color value. You can iterate to it by dragging the Red , Blue , Green and Alpha channels sliders or by directly typing an integer value to its respective boxes. The picker will try to identify an existing named color (one of the static read-only fields declared in the Xamarin.Forms.Color struct ) for the RGB value set, or you can also type one of those suggestions to imediately get the channels filled. By setting a color in the picker and clicking choose, MFractor will set the new value to the property. If the value represents one of the named colors this value will be used instead of the hex value. Example : type brown on the Color field and the picker channels will be automatically set to red 165, Green 42, Blue 42 and Alpha 255 that represents Color.Brown field value of #FFA52A2A .","title":"Identifying mispelled hex color formats"},{"location":"xamarin-forms/colors/color-analysis/#fixing-mispelled-named-colors","text":"Visual Studio provides completion for the named colors on properties of the Color type, even though, typos may happen. This code analysis checks for non-hex values typed on the color properties and suggests fixes to similar named colors. Suppose you have a color property with value of Blu . This is an invalid color value because it doesn't represent a valid named color, nor a hex value and neither a resource reference. This will be thrown as an error at compile time, but with the MFractor code analysis you can identify this issue as you edit your file and get suggestions to quickly fix the issue: By hovering over the typo, the code analysis tooltip will show suggestions of names that closely match the mispelled one. Just click the link to have an instant fix.","title":"Fixing Mispelled Named Colors"},{"location":"xamarin-forms/colors/color-analysis/#applying-named-color-to-equivalent-hex-value","text":"Hex values are a useful way of representing and sharing color value, but you can't easily figure a color value just by looking at it (unless you're a very experienced designer). For this reason, its useful to have named colors when they apply, so we can quickly identify what the color value is. This code analysis will check Color properties that has hex values declared to verify if they match one of the named colors available. Suppose you have an element that declares a color with the value #F5F5DC which matches to the Color.Beige named color. A warning will be shown to the color declaration to suggest replacing with the named version:","title":"Applying Named Color to Equivalent hex value"},{"location":"xamarin-forms/colors/color-analysis/#applying-an-existing-color-resource","text":"Its a common pattern to set theme Color values at the Resources of the App.xaml file of a Xamarin.Forms project. MFractor can identify if an explicity hex value set to a color property matches an existing resource at any level it could be declared. Suppose you a have a Color entry for the primary color of your app theme, like below: <ResourceDictionary> <Color x:Key= \"primaryColor\" > #7BCCE5 </Color> </ResourceDictionary> At another part of the code, you add an item that will apply this color value, but you didn't remember about the Color resource you've declared before, and you simply copy the hex value over from your style guide: <BoxView Color= \"#7BCCE5\" /> If you hover over the squiggles of the code analysis warning, you'll find information about the existing static resource that matches the hex value you've just typed. You can click on the link for applying the change reference the resource. The color value will be replaced with the reference to the static resource: <BoxView Color= \"{StaticResource primaryColor}\" />","title":"Applying an Existing Color Resource"},{"location":"xamarin-forms/colors/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/","text":"Generate the C# code to declare a new attached property declaration Introduction In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached(\"HasShadow\", typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example <Label local:MyClass.HasShadow=\"true\"/> One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Attached Property Wizard To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see the Automatic Type Inference documentation for a full breakdown of this feature.","title":"Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#introduction","text":"In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached(\"HasShadow\", typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example <Label local:MyClass.HasShadow=\"true\"/> One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#using-the-attached-property-wizard","text":"To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#automatic-type-inference","text":"The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see the Automatic Type Inference documentation for a full breakdown of this feature.","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/","text":"Generate the C# code to declare a new bindable property for a custom control Introduction When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get => (bool)GetValue(HasShadowProperty); set => SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Bindable Property Wizard To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret.","title":"Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#introduction","text":"When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get => (bool)GetValue(HasShadowProperty); set => SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#using-the-bindable-property-wizard","text":"To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/","text":"Move a XAML layout usage into its own reusable custom control Introduction When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control. Using The Extract Control Refactoring To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Extracting Custom Controls"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#introduction","text":"When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#using-the-extract-control-refactoring","text":"To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Using The Extract Control Refactoring"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/","text":"Quickly find custom renderers for Xamarin.Forms visual elements Introduction MFractor allows you to quickly find and list custom renders declared for Xamarin.Forms view components and navigate to its source code. Using the Code Action Info Check the Code Actions docs for details about how to invoke the Code Actions in Visual Studio for either C# or XAML code. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Building on the example of the previous topic, Generate Custom Handlers , where we've created a Custom Renderer for the EnhancedButton class, that derives from the Button class, we can open it's source code and right click over the symbol name. The option Find Custom Renderers will appear below the Find Refereces : This option can also be accessed from the quick fix menu, by invoking the Option + Enter keyboard shortcut or clicking on the screwdriver icon on the left of the current line: And it's also available in XAML files by right clicking on any element: MFractor will search in the projects that refereces the curret if there are renderers declared for this type and will present a list in the Search Results pad of Visual Studio: If no Renderers are found for the element you'll receive a message on the status bar: By using this feature you can quickly identify all the custom renderers declared for the component, and quickly navigate to its source code. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Find Custom Renderers"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/#introduction","text":"MFractor allows you to quickly find and list custom renders declared for Xamarin.Forms view components and navigate to its source code.","title":"Introduction"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/#using-the-code-action","text":"Info Check the Code Actions docs for details about how to invoke the Code Actions in Visual Studio for either C# or XAML code. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Building on the example of the previous topic, Generate Custom Handlers , where we've created a Custom Renderer for the EnhancedButton class, that derives from the Button class, we can open it's source code and right click over the symbol name. The option Find Custom Renderers will appear below the Find Refereces : This option can also be accessed from the quick fix menu, by invoking the Option + Enter keyboard shortcut or clicking on the screwdriver icon on the left of the current line: And it's also available in XAML files by right clicking on any element: MFractor will search in the projects that refereces the curret if there are renderers declared for this type and will present a list in the Search Results pad of Visual Studio: If no Renderers are found for the element you'll receive a message on the status bar: By using this feature you can quickly identify all the custom renderers declared for the component, and quickly navigate to its source code. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Using the Code Action"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/","text":"Quickly generate custom renderers for Xamarin.Forms visual elements Introduction MFractor allows you to quickly create the stubs for implementing a custom renderer for a Xamarin.Forms element using a Code Action that can be applied to your custom View Components. When invoked it will create the renderer class stubs in each of the selected projects including the proper export attributes. Using the Code Action Info Check the C# Code Actions docs for details about how to invoke the Code Actions. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Suppose you want to create an enhanced button component that implements a platform specific feature of Android or iOS native button components. You can start by creating a new class that derives from Button , such as: using System ; using Xamarin.Forms ; namespace MFractor.Samples.Views { public class EnhancedButton : Button { public EnhancedButton () { } } } Place the cursor over the class name declaration and use the shortcuts to invoke the list of available Code Actions. The Generat custom renderers for EnhancedButton should be available to this list: Invoking it will present the Generate Custom Renderers dialog: MFractor will identify the projects that has dependencies on the Xamarin.Forms project where the component is declared and add to this to allow selecting the ones to which you want to create the renderers. In the example above, there are an Android and an iOS project. When you confirm the selection the following files will be created: Android Code Template Defaults to Renderers/EnhancedButtonRenderer.cs . using System.ComponentModel ; using Android.Content ; using MFractor.Samples.Droid.Renderers ; using MFractor.Samples.Views ; using Xamarin.Forms.Platform.Android ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.Droid.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; public EnhancedButtonRenderer ( Context context ) : base ( context ) { } protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } iOS Code Template Defaults to: Renderers/EnhancedButtonRenderer.cs using System.ComponentModel ; using MFractor.Samples.iOS.Renderers ; using MFractor.Samples.Views ; using UIKit ; using Xamarin.Forms.Platform.iOS ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.iOS.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } This is the complete stubs for writing a renderer, including the ExportRenderer declaration. All you need to is implement the OnElementChanged and OnElementPropertyChanged custom logic and use your new component on your forms pages. Notice that MFractor will automatically resolve to the base class Renderer, so you don't need to bother about finding what is the correct native renderer to derive. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Generate Custom Renderers"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#introduction","text":"MFractor allows you to quickly create the stubs for implementing a custom renderer for a Xamarin.Forms element using a Code Action that can be applied to your custom View Components. When invoked it will create the renderer class stubs in each of the selected projects including the proper export attributes.","title":"Introduction"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#using-the-code-action","text":"Info Check the C# Code Actions docs for details about how to invoke the Code Actions. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Suppose you want to create an enhanced button component that implements a platform specific feature of Android or iOS native button components. You can start by creating a new class that derives from Button , such as: using System ; using Xamarin.Forms ; namespace MFractor.Samples.Views { public class EnhancedButton : Button { public EnhancedButton () { } } } Place the cursor over the class name declaration and use the shortcuts to invoke the list of available Code Actions. The Generat custom renderers for EnhancedButton should be available to this list: Invoking it will present the Generate Custom Renderers dialog: MFractor will identify the projects that has dependencies on the Xamarin.Forms project where the component is declared and add to this to allow selecting the ones to which you want to create the renderers. In the example above, there are an Android and an iOS project. When you confirm the selection the following files will be created:","title":"Using the Code Action"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#android-code-template","text":"Defaults to Renderers/EnhancedButtonRenderer.cs . using System.ComponentModel ; using Android.Content ; using MFractor.Samples.Droid.Renderers ; using MFractor.Samples.Views ; using Xamarin.Forms.Platform.Android ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.Droid.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; public EnhancedButtonRenderer ( Context context ) : base ( context ) { } protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } }","title":"Android Code Template"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#ios-code-template","text":"Defaults to: Renderers/EnhancedButtonRenderer.cs using System.ComponentModel ; using MFractor.Samples.iOS.Renderers ; using MFractor.Samples.Views ; using UIKit ; using Xamarin.Forms.Platform.iOS ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.iOS.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } This is the complete stubs for writing a renderer, including the ExportRenderer declaration. All you need to is implement the OnElementChanged and OnElementPropertyChanged custom logic and use your new component on your forms pages. Notice that MFractor will automatically resolve to the base class Renderer, so you don't need to bother about finding what is the correct native renderer to derive. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"iOS Code Template"},{"location":"xamarin-forms/data-triggers/analysis/","text":"Verifying the usage of triggers Introduction This documentation article outlines the XAML analysers provided by MFractor.","title":"Analysis"},{"location":"xamarin-forms/data-triggers/analysis/#introduction","text":"This documentation article outlines the XAML analysers provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/data-triggers/intellisense/","text":"Verify the Introduction This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Intellisense"},{"location":"xamarin-forms/data-triggers/intellisense/#introduction","text":"This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/data-triggers/overview/","text":"Use data triggers to change the appearance of your XAML in response to events or state changes Introduction","title":"Overview"},{"location":"xamarin-forms/data-triggers/overview/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/data-triggers/overview/#_1","text":"","title":""},{"location":"xamarin-forms/dynamic-resources/intellisense/","text":"Code completion for the dynamic resources available in an application","title":"Intellisense"},{"location":"xamarin-forms/dynamic-resources/navigation/","text":"Navigate to the source code location of a dynamic resource Introduction Resolving By ExportFontAttribute","title":"Navigation"},{"location":"xamarin-forms/dynamic-resources/navigation/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/navigation/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/dynamic-resources/search/","text":"Use global search to locate a specific dynamic resource Introduction Resolving By ExportFontAttribute","title":"Search"},{"location":"xamarin-forms/dynamic-resources/search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/search/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/dynamic-resources/tooltips/","text":"Preview the result of a dynamic resource expression through tooltips Introduction Resolving By ExportFontAttribute","title":"Tooltips"},{"location":"xamarin-forms/dynamic-resources/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/tooltips/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/fonts/analysis/","text":"Code inspections that spot common issues when working with custom fonts Overview MFractor includes several analysers to assist with working with custom fonts in XAML. Unknown Embedded Font When referencing embedded fonts in XAML using the FontFamily attribute, it is possible to reference a font asset that is not defined. To assist, MFractor inspects FontFamily occurances and verifies that the font declaration is defined in the current assembly: If able, MFractor will also suggest auto-corrections to change the unknown named font size to a closely matching named value. Unknown Font Glyph When using the icon fonts in XAML and using a unicode character to lookup a particular icon, it is possible to reference a glyph that does not exist in that font asset. To assist, MFractor detects unicode characters defined in XAML and, when a custom font is reference, inspect the font asset to see if the font glyph exists in the font asset: Named Font Value Analysis When using the FontSize property in XAML, you may use the NamedSize enum values to choose a specific known font size. MFractor will inspect the named value provided to a FontSize property and verify that it maps to a known value: If able, MFractor will also suggest auto-corrections to change the invalid named font size to a closely matching named value.","title":"Analysis"},{"location":"xamarin-forms/fonts/analysis/#overview","text":"MFractor includes several analysers to assist with working with custom fonts in XAML.","title":"Overview"},{"location":"xamarin-forms/fonts/analysis/#unknown-embedded-font","text":"When referencing embedded fonts in XAML using the FontFamily attribute, it is possible to reference a font asset that is not defined. To assist, MFractor inspects FontFamily occurances and verifies that the font declaration is defined in the current assembly: If able, MFractor will also suggest auto-corrections to change the unknown named font size to a closely matching named value.","title":"Unknown Embedded Font"},{"location":"xamarin-forms/fonts/analysis/#unknown-font-glyph","text":"When using the icon fonts in XAML and using a unicode character to lookup a particular icon, it is possible to reference a glyph that does not exist in that font asset. To assist, MFractor detects unicode characters defined in XAML and, when a custom font is reference, inspect the font asset to see if the font glyph exists in the font asset:","title":"Unknown Font Glyph"},{"location":"xamarin-forms/fonts/analysis/#named-font-value-analysis","text":"When using the FontSize property in XAML, you may use the NamedSize enum values to choose a specific known font size. MFractor will inspect the named value provided to a FontSize property and verify that it maps to a known value: If able, MFractor will also suggest auto-corrections to change the invalid named font size to a closely matching named value.","title":"Named Font Value Analysis"},{"location":"xamarin-forms/fonts/code-completion/","text":"Completion for font assets in a Xamarin.Forms project and for glyphs within a font asset Introduction When working with font icons in Xamarin.Forms, it's difficult to discover the icons that are available within a font asset. To assist with working with font icons in XAML, MFractor provides code completion and previews the fonts declared through an ExportFontAttribute and for all named glyphs within a font asset. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Embedded Fonts Completion When your project has declared embedded font resources using the ExportFontAttribute , these font assets will be suggested in IntelliSense when editing the FontFamily attribute. Font Glyph Code Completion To access font glyph tooltips, ensure that the element applies a valid font asset to its FontFamily property. To access the list of available glyphs in a font asset, start typing in any property for that element that is a string . MFractor will suggest all font icons available in the referenced font by name and display a preview of that icon. To apply a completion, type the name of an icon or select it in the completion window, and press enter. MFractor will then insert the escaped unicode character reference: Desktop Fonts vs Web Fonts MFractor can only provide glyph code completion when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If no glyphs are suggested, please ensure that your font asset is a web font. Import Font Completion MFractor also provides the ability to use the Font Importer directly from IntelliSense. This allows you to add a font from a FontFamily attribute. To activate the completion, start typing in a FontFamily attribute and choose Import a font into mobile projects :","title":"Code Completion"},{"location":"xamarin-forms/fonts/code-completion/#introduction","text":"When working with font icons in Xamarin.Forms, it's difficult to discover the icons that are available within a font asset. To assist with working with font icons in XAML, MFractor provides code completion and previews the fonts declared through an ExportFontAttribute and for all named glyphs within a font asset. Please see the FontFamily resolution article to understand how MFractor resolves your font assets","title":"Introduction"},{"location":"xamarin-forms/fonts/code-completion/#embedded-fonts-completion","text":"When your project has declared embedded font resources using the ExportFontAttribute , these font assets will be suggested in IntelliSense when editing the FontFamily attribute.","title":"Embedded Fonts Completion"},{"location":"xamarin-forms/fonts/code-completion/#font-glyph-code-completion","text":"To access font glyph tooltips, ensure that the element applies a valid font asset to its FontFamily property. To access the list of available glyphs in a font asset, start typing in any property for that element that is a string . MFractor will suggest all font icons available in the referenced font by name and display a preview of that icon. To apply a completion, type the name of an icon or select it in the completion window, and press enter. MFractor will then insert the escaped unicode character reference: Desktop Fonts vs Web Fonts MFractor can only provide glyph code completion when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If no glyphs are suggested, please ensure that your font asset is a web font.","title":"Font Glyph Code Completion"},{"location":"xamarin-forms/fonts/code-completion/#import-font-completion","text":"MFractor also provides the ability to use the Font Importer directly from IntelliSense. This allows you to add a font from a FontFamily attribute. To activate the completion, start typing in a FontFamily attribute and choose Import a font into mobile projects :","title":"Import Font Completion"},{"location":"xamarin-forms/fonts/font-family-resolution/","text":"An overview of how MFractor resolves fonts for IntelliSense and tooltips Introduction When working with custom fonts in XAML, MFractor can suggest the available glyphs in a font asset and also preview that glyph via a tooltip. This article outlines how MFractor will resolve your font asset. To accomplish this, MFractor will resolve the font asset referenced by a particular element. This is accomplished via three methods: Resolving the FontFamily through fonts defined by the ExportFontAttribute . Resolving the FontFamily static resource. Resolving the FontFamily via the elements style. Resolving By ExportFontAttribute One of the major features added in Xamarin.Forms 4.5 was EmbeddedFonts ; the ability to include a font asset as an EmbeddedResource in your code project and then use the ExportFontAttribute to expose it to Xamarin.Forms. Example: [assembly: ExportFont(\"FontAwesome.ttf\")] In XAML, we can now reference this font by name (with or without the file extension): <Label FontFamily=\"FontAwesome\"/> <Label FontFamily=\"FontAwesome.ttf\"/> When MFractor encounters a FontFamily that is not a static resource expression, it will inspect the assembly for ExportFontAttribute 's and match the defined font family with either the ExportFontAttribute.FontFileName or ExportFontAttribute.Alias value. Resolving By Static Resource When using custom fonts in XAML, a common method to reference a font is with a static resource expression that returns a string OnPlatform that returns the font for each platform. Consider the following font reference: <OnPlatform x:TypeArguments=\"x:String\" x:Key=\"FontAwesome5ProRegular\"> <On Platform=\"iOS\" Value=\"FontAwesome5Pro-Regular\"/> <On Platform=\"Android\" Value=\"FontAwesomeRegular.ttf#Regular\"/> <On Platform=\"UWP\" Value=\"/Assets/Fonts/FontAwesomeRegular.ttf#Font Awesome 5 Pro\"/> </OnPlatform> <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\"/> In this OnPlatform , we reference the font asset by its postscript name, FontAwesome5Pro-Regular , on iOS . on Android via the asset name and font style FontAwesomeRegular.ttf#Regular and on UWP by its assets path plus the typographic family name. When MFractor encounters a FontFamily that references an OnPlatform that returns a string, it evaluates the expression to discover the iOS/Android font asset and then attempts to load that font asset. Resolving By Style MFractor can also resolve the font family declared by a style. Consider the following style declaration: <OnPlatform x:TypeArguments=\"x:String\" x:Key=\"FontAwesome5ProRegular\"> <On Platform=\"iOS\" Value=\"FontAwesome5Pro-Regular\"/> <On Platform=\"Android\" Value=\"FontAwesomeRegular.ttf#Regular\"/> </OnPlatform> <Style x:Key=\"labelStyle\" TargetType=\"Label\" FontFamily=\"{StaticResource FontAwesome5ProRegular}\" <Label Style=\"{StaticResource labelStyle}\"/> As the Label does not use the FontFamily property, MFractor then tries to locate the Style property. If successful, MFractor evaluates that style expression, locates the FontFamily declared by the style and then evaluates the content of setter as per Resolving By Static Resource .","title":"FontFamily Resolution"},{"location":"xamarin-forms/fonts/font-family-resolution/#introduction","text":"When working with custom fonts in XAML, MFractor can suggest the available glyphs in a font asset and also preview that glyph via a tooltip. This article outlines how MFractor will resolve your font asset. To accomplish this, MFractor will resolve the font asset referenced by a particular element. This is accomplished via three methods: Resolving the FontFamily through fonts defined by the ExportFontAttribute . Resolving the FontFamily static resource. Resolving the FontFamily via the elements style.","title":"Introduction"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-exportfontattribute","text":"One of the major features added in Xamarin.Forms 4.5 was EmbeddedFonts ; the ability to include a font asset as an EmbeddedResource in your code project and then use the ExportFontAttribute to expose it to Xamarin.Forms. Example: [assembly: ExportFont(\"FontAwesome.ttf\")] In XAML, we can now reference this font by name (with or without the file extension): <Label FontFamily=\"FontAwesome\"/> <Label FontFamily=\"FontAwesome.ttf\"/> When MFractor encounters a FontFamily that is not a static resource expression, it will inspect the assembly for ExportFontAttribute 's and match the defined font family with either the ExportFontAttribute.FontFileName or ExportFontAttribute.Alias value.","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-static-resource","text":"When using custom fonts in XAML, a common method to reference a font is with a static resource expression that returns a string OnPlatform that returns the font for each platform. Consider the following font reference: <OnPlatform x:TypeArguments=\"x:String\" x:Key=\"FontAwesome5ProRegular\"> <On Platform=\"iOS\" Value=\"FontAwesome5Pro-Regular\"/> <On Platform=\"Android\" Value=\"FontAwesomeRegular.ttf#Regular\"/> <On Platform=\"UWP\" Value=\"/Assets/Fonts/FontAwesomeRegular.ttf#Font Awesome 5 Pro\"/> </OnPlatform> <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\"/> In this OnPlatform , we reference the font asset by its postscript name, FontAwesome5Pro-Regular , on iOS . on Android via the asset name and font style FontAwesomeRegular.ttf#Regular and on UWP by its assets path plus the typographic family name. When MFractor encounters a FontFamily that references an OnPlatform that returns a string, it evaluates the expression to discover the iOS/Android font asset and then attempts to load that font asset.","title":"Resolving By Static Resource"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-style","text":"MFractor can also resolve the font family declared by a style. Consider the following style declaration: <OnPlatform x:TypeArguments=\"x:String\" x:Key=\"FontAwesome5ProRegular\"> <On Platform=\"iOS\" Value=\"FontAwesome5Pro-Regular\"/> <On Platform=\"Android\" Value=\"FontAwesomeRegular.ttf#Regular\"/> </OnPlatform> <Style x:Key=\"labelStyle\" TargetType=\"Label\" FontFamily=\"{StaticResource FontAwesome5ProRegular}\" <Label Style=\"{StaticResource labelStyle}\"/> As the Label does not use the FontFamily property, MFractor then tries to locate the Style property. If successful, MFractor evaluates that style expression, locates the FontFamily declared by the style and then evaluates the content of setter as per Resolving By Static Resource .","title":"Resolving By Style"},{"location":"xamarin-forms/fonts/tooltips/","text":"Glyph Tooltip When working with font icons in Xamarin.Forms, one of the challenges is understanding what a particular glyph code references. Consider the following XAML code: <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\" Text=\"&#xf00c;\" This Label uses the &#xf00c; icon from the FontAwesome5ProRegular font asset. From a maintainability perspective, it's very difficult for a developer to understand what the icon code &#xf00c; refers to. To make it easier to understand what a particular references, MFractor include glyph tooltips. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Desktop Fonts vs Web Fonts MFractor can only provide glyph previews when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If glyph tooltips do not appear, please ensure that your font asset is a web font. Font Glyph Code Tooltips To access font glyph tooltips, hover over a font glyph code in XAML: x:Static Constant tooltips If you are using a font named constants class to reference font icons, MFractor can also preview these as tooltips. To access, hover over an x:Static expression that references a font character code: Font Typography Tools When working with fonts in Xamarin.Forms, it's useful to be able to visually preview the typography of a font for a particular block of text. To assist with this, MFractor includes font typography tooltips that can render a text block in the font specified for that element. To access font typography tooltips, hover your cursor over a string literal in XAML where the elements FontFamily is set: Embedded Font Tooltips MFractor includes tooltips summarise the font information for an embedded font. These tooltips include some useful information such as the font name, style, family and postscript name. MFractor will render an font summary tooltip when you hover over a FontFamily value that references an embedded font asset: NamedSize Font Tooltips MFractor includes helper tooltips for the NamedSize enum for the FontSize attribute. When you hover over a NamedSize value, MFractor will render a summary of the platform-specific font sizes that the name maps to: Please refer to the NamedSize documentation for more information.","title":"Tooltips"},{"location":"xamarin-forms/fonts/tooltips/#glyph-tooltip","text":"When working with font icons in Xamarin.Forms, one of the challenges is understanding what a particular glyph code references. Consider the following XAML code: <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\" Text=\"&#xf00c;\" This Label uses the &#xf00c; icon from the FontAwesome5ProRegular font asset. From a maintainability perspective, it's very difficult for a developer to understand what the icon code &#xf00c; refers to. To make it easier to understand what a particular references, MFractor include glyph tooltips. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Desktop Fonts vs Web Fonts MFractor can only provide glyph previews when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If glyph tooltips do not appear, please ensure that your font asset is a web font.","title":"Glyph Tooltip"},{"location":"xamarin-forms/fonts/tooltips/#font-glyph-code-tooltips","text":"To access font glyph tooltips, hover over a font glyph code in XAML:","title":"Font Glyph Code Tooltips"},{"location":"xamarin-forms/fonts/tooltips/#xstatic-constant-tooltips","text":"If you are using a font named constants class to reference font icons, MFractor can also preview these as tooltips. To access, hover over an x:Static expression that references a font character code:","title":"x:Static Constant tooltips"},{"location":"xamarin-forms/fonts/tooltips/#font-typography-tools","text":"When working with fonts in Xamarin.Forms, it's useful to be able to visually preview the typography of a font for a particular block of text. To assist with this, MFractor includes font typography tooltips that can render a text block in the font specified for that element. To access font typography tooltips, hover your cursor over a string literal in XAML where the elements FontFamily is set:","title":"Font Typography Tools"},{"location":"xamarin-forms/fonts/tooltips/#embedded-font-tooltips","text":"MFractor includes tooltips summarise the font information for an embedded font. These tooltips include some useful information such as the font name, style, family and postscript name. MFractor will render an font summary tooltip when you hover over a FontFamily value that references an embedded font asset:","title":"Embedded Font Tooltips"},{"location":"xamarin-forms/fonts/tooltips/#namedsize-font-tooltips","text":"MFractor includes helper tooltips for the NamedSize enum for the FontSize attribute. When you hover over a NamedSize value, MFractor will render a summary of the platform-specific font sizes that the name maps to: Please refer to the NamedSize documentation for more information.","title":"NamedSize Font Tooltips"},{"location":"xamarin-forms/grids/adornments/","text":"Easily see the row/column index of a grid alongside its declaration Introduction Grids are a powerful layout provided by Xamarin.Forms that enables developers to build complex, overlapping layouts. When we work with Grids in XAML, we use row and column definitions to define our the grid should layout our elements. These rows/columns are then referenced by index like so: Grid.Row=\"0\" This introduces a problem; we now need to know the index of each row and column in order to place our elements in the right position. This means we either need to count the rows/column and/or maintain a comment for each row/column that indicates it index. To address this problem, MFractor injects the index of the row/column alongside its declaration. This allows use to instantly see the index for a given row or column. Row And Column Adornments Grid row and column adornments are automatically added to the start of row or column defintion. RowDefinitions ColumnDefinitions Click To Copy Grid Row/Column To quickly get the XAML code to reference a given row or column, simply click on the adornment and MFractor will place the code into your clipboard. Disabling Grid Adornments If you notice adverse performance impacts when editing XAML files, please try disabling grid adornments. To do so, open MFractors preferences menu and under Settings -> Feature Flags , disable the Grid Adornments option. After changing this setting, please close and reopen any XAML files for the change to take affect.","title":"Adornments"},{"location":"xamarin-forms/grids/adornments/#introduction","text":"Grids are a powerful layout provided by Xamarin.Forms that enables developers to build complex, overlapping layouts. When we work with Grids in XAML, we use row and column definitions to define our the grid should layout our elements. These rows/columns are then referenced by index like so: Grid.Row=\"0\" This introduces a problem; we now need to know the index of each row and column in order to place our elements in the right position. This means we either need to count the rows/column and/or maintain a comment for each row/column that indicates it index. To address this problem, MFractor injects the index of the row/column alongside its declaration. This allows use to instantly see the index for a given row or column.","title":"Introduction"},{"location":"xamarin-forms/grids/adornments/#row-and-column-adornments","text":"Grid row and column adornments are automatically added to the start of row or column defintion. RowDefinitions ColumnDefinitions","title":"Row And Column Adornments"},{"location":"xamarin-forms/grids/adornments/#click-to-copy-grid-rowcolumn","text":"To quickly get the XAML code to reference a given row or column, simply click on the adornment and MFractor will place the code into your clipboard.","title":"Click To Copy Grid Row/Column"},{"location":"xamarin-forms/grids/adornments/#disabling-grid-adornments","text":"If you notice adverse performance impacts when editing XAML files, please try disabling grid adornments. To do so, open MFractors preferences menu and under Settings -> Feature Flags , disable the Grid Adornments option. After changing this setting, please close and reopen any XAML files for the change to take affect.","title":"Disabling Grid Adornments"},{"location":"xamarin-forms/grids/analysis/","text":"Inspects XAML Grid child elements to identify if positioning or span is out of boundarys. Introduction Grids are one of the most versatile and used layouts provided by Xamarin.Forms. Despite being easy to use, it sometimes hard to keep track of its child elements. MFractor introduces a few Grid Code Analysis to aid on composing your layouts. Row and Column Analysis These analysers are applied to the Grid.Row and Grid.Column attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element position to check if it's within it's defined bounds. Row Outside Grid Boundary If a Grid.Row definition is beyond the Rows Definitions of the parent Grid, MFractor will show a warning for the faulty location: Column Outside Grid Boundary If a Grid.Column definition is beyond the Columns Definitions of the parent Grid, MFractor will show a warning for the faulty location: Row and Column Span Analysis These analysers are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element that declares spans to check if they doesn't go beyond the defined bounds. Row Span Outside Grid Boundary If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size: Column Span Outside Grid Boundary If a Grid.ColumnSpan definition goes beyond the column Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size: Row and Column Span Is Zero Analysis These analysers are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects that the provided span is not zero; using zero as a span value is invalid and may lead to a runtime crash. Row Span Is Zero If a Grid.RowSpan is zero, MFractor will show a warning for the faulty span size: Column Span Is Zero If a Grid.ColumnSpan is zero, MFractor will show a warning for the faulty span size: Redundant Row And Column Analysis These analysers inspect when the Grid.Row , Grid.RowSpan , Grid.Column or Grid.ColumnSpan properties are applied an element that is not within a grid. They warn you that the Grid property is redundant and can be removed. To fix these issues, you can click on Remove redundant grid properties code fix to remove the unused properties. If the parent of the XAML element is within a grid, you can click on the Move reduntant grid properties to parent code fix to push the grid properties up to the parent element.","title":"Grid Analysis"},{"location":"xamarin-forms/grids/analysis/#introduction","text":"Grids are one of the most versatile and used layouts provided by Xamarin.Forms. Despite being easy to use, it sometimes hard to keep track of its child elements. MFractor introduces a few Grid Code Analysis to aid on composing your layouts.","title":"Introduction"},{"location":"xamarin-forms/grids/analysis/#row-and-column-analysis","text":"These analysers are applied to the Grid.Row and Grid.Column attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element position to check if it's within it's defined bounds.","title":"Row and Column Analysis"},{"location":"xamarin-forms/grids/analysis/#row-outside-grid-boundary","text":"If a Grid.Row definition is beyond the Rows Definitions of the parent Grid, MFractor will show a warning for the faulty location:","title":"Row Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#column-outside-grid-boundary","text":"If a Grid.Column definition is beyond the Columns Definitions of the parent Grid, MFractor will show a warning for the faulty location:","title":"Column Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#row-and-column-span-analysis","text":"These analysers are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element that declares spans to check if they doesn't go beyond the defined bounds.","title":"Row and Column Span Analysis"},{"location":"xamarin-forms/grids/analysis/#row-span-outside-grid-boundary","text":"If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size:","title":"Row Span Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#column-span-outside-grid-boundary","text":"If a Grid.ColumnSpan definition goes beyond the column Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size:","title":"Column Span Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#row-and-column-span-is-zero-analysis","text":"These analysers are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects that the provided span is not zero; using zero as a span value is invalid and may lead to a runtime crash.","title":"Row and Column Span Is Zero Analysis"},{"location":"xamarin-forms/grids/analysis/#row-span-is-zero","text":"If a Grid.RowSpan is zero, MFractor will show a warning for the faulty span size:","title":"Row Span Is Zero"},{"location":"xamarin-forms/grids/analysis/#column-span-is-zero","text":"If a Grid.ColumnSpan is zero, MFractor will show a warning for the faulty span size:","title":"Column Span Is Zero"},{"location":"xamarin-forms/grids/analysis/#redundant-row-and-column-analysis","text":"These analysers inspect when the Grid.Row , Grid.RowSpan , Grid.Column or Grid.ColumnSpan properties are applied an element that is not within a grid. They warn you that the Grid property is redundant and can be removed. To fix these issues, you can click on Remove redundant grid properties code fix to remove the unused properties. If the parent of the XAML element is within a grid, you can click on the Move reduntant grid properties to parent code fix to push the grid properties up to the parent element.","title":"Redundant Row And Column Analysis"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/","text":"Quickly convert a StackLayout to a Grid for refactoring and expanding your layout. Introduction StackLayout is one of the basic layouts provided by Xamarin.Forms and is a common starting point when composing a new view, being fast and easy to use. But it's common to transform a StackLayout into a Grid when the layout starts to become complex, or you need to rethink it to have new column or row. MFractor makes easy to convert an existing StackLayout into a Grid with the adequate rows and columns definitions and its elements in place. Using the Converter The Convert StackLayout to Grid tool is presented as a XAML Code Action. The option becomes available to the Refactor menu on the Context Menu of a StackLayout element. Consider a layout for reporting progress to the user. It's composed of an ActivityIndicator , a Label and Button stacked vertically: <StackLayout> <ActivityIndicator IsRunning= \"True\" /> <Label HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button HorizontalOptions= \"Center\" Text= \"Cancel\" /> </StackLayout> We may want to transform it into a Grid , so we can add a second column to add new button button to right of the current one. Right-click on the StackLayout element and on the context menu you should find the option Convert StackLayout to Grid on the Refactor menu: In Visual Studio for Windows this code action will appear in the quick fix menu, the little screwdriver icon that appears to the left of the current line being edited. If you place the cursor under a StackLayout declaration and click on the icon or use the Ctrl + . keyboard shortcut, the option will appear o the menu: Note The current verison of MFractor for Visual Studio Mac doe not support quick fix actions in XAML, however, this feature should be available in a future version. By applying this code action, your StackLayout declaration will be transformed into an equivalent Grid declaration, just like below: <Grid HorizontalOptions= \"Center\" VerticalOptions= \"Center\" Padding= \"12\" > <Grid.RowDefinitions> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> </Grid.RowDefinitions> <ActivityIndicator Grid.Row= \"0\" IsRunning= \"True\" /> <Label Grid.Row= \"1\" HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button Grid.Row= \"2\" HorizontalOptions= \"Center\" Text= \"Cancel\" /> </Grid> The conversion to Grid will keep all the properties previously applied to the StackLayout on the trasformed grid declaration. Depending on the Orientation property, the ColumnsDefinitions or RowDefinitions will be created to match the number of elements in the stack. For Vertical (the default) stacks row definitions will be created and for Horizontal column definitions will be created. The conversion will also add the correspondent Grid.Column or Grid.Row properties on the child elements. The conversion will also verify the VerticalOptions (for vertical stacks) or HorizontalOptions (for horizontal stacks) Exapnsion option of each child element to determine the column width or row height of its corresponding position: For elements that Expand , the row or column defitinion will apply the * size For elements that doesn't declare the Expand, the row or column defiition will apply the Auto size Note There's no reverse operation of StackLayout to Grid conversion. If you need to revert the operation you should use the Undo command of the editor. We recommend that you keep a history of your source code so you can track back after the conversion if you need.","title":"Convert StackLayout to Grid"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/#introduction","text":"StackLayout is one of the basic layouts provided by Xamarin.Forms and is a common starting point when composing a new view, being fast and easy to use. But it's common to transform a StackLayout into a Grid when the layout starts to become complex, or you need to rethink it to have new column or row. MFractor makes easy to convert an existing StackLayout into a Grid with the adequate rows and columns definitions and its elements in place.","title":"Introduction"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/#using-the-converter","text":"The Convert StackLayout to Grid tool is presented as a XAML Code Action. The option becomes available to the Refactor menu on the Context Menu of a StackLayout element. Consider a layout for reporting progress to the user. It's composed of an ActivityIndicator , a Label and Button stacked vertically: <StackLayout> <ActivityIndicator IsRunning= \"True\" /> <Label HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button HorizontalOptions= \"Center\" Text= \"Cancel\" /> </StackLayout> We may want to transform it into a Grid , so we can add a second column to add new button button to right of the current one. Right-click on the StackLayout element and on the context menu you should find the option Convert StackLayout to Grid on the Refactor menu: In Visual Studio for Windows this code action will appear in the quick fix menu, the little screwdriver icon that appears to the left of the current line being edited. If you place the cursor under a StackLayout declaration and click on the icon or use the Ctrl + . keyboard shortcut, the option will appear o the menu: Note The current verison of MFractor for Visual Studio Mac doe not support quick fix actions in XAML, however, this feature should be available in a future version. By applying this code action, your StackLayout declaration will be transformed into an equivalent Grid declaration, just like below: <Grid HorizontalOptions= \"Center\" VerticalOptions= \"Center\" Padding= \"12\" > <Grid.RowDefinitions> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> </Grid.RowDefinitions> <ActivityIndicator Grid.Row= \"0\" IsRunning= \"True\" /> <Label Grid.Row= \"1\" HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button Grid.Row= \"2\" HorizontalOptions= \"Center\" Text= \"Cancel\" /> </Grid> The conversion to Grid will keep all the properties previously applied to the StackLayout on the trasformed grid declaration. Depending on the Orientation property, the ColumnsDefinitions or RowDefinitions will be created to match the number of elements in the stack. For Vertical (the default) stacks row definitions will be created and for Horizontal column definitions will be created. The conversion will also add the correspondent Grid.Column or Grid.Row properties on the child elements. The conversion will also verify the VerticalOptions (for vertical stacks) or HorizontalOptions (for horizontal stacks) Exapnsion option of each child element to determine the column width or row height of its corresponding position: For elements that Expand , the row or column defitinion will apply the * size For elements that doesn't declare the Expand, the row or column defiition will apply the Auto size Note There's no reverse operation of StackLayout to Grid conversion. If you need to revert the operation you should use the Undo command of the editor. We recommend that you keep a history of your source code so you can track back after the conversion if you need.","title":"Using the Converter"},{"location":"xamarin-forms/grids/delete-row-columns/","text":"Delete a row or column and update all indices and spans Introduction When working with Grids, it is a common workflow to delete a row or column and then update the row/column indices and spans. MFractor contains these options, right-click on a column and select 'MFractor Code Actions' Delete Row The same is available for columns Delete Column Mac Windows Links See the announcement in the Blog ( GitHub ).","title":"Delete Grid Row/Column"},{"location":"xamarin-forms/grids/delete-row-columns/#introduction","text":"When working with Grids, it is a common workflow to delete a row or column and then update the row/column indices and spans. MFractor contains these options, right-click on a column and select 'MFractor Code Actions' Delete Row The same is available for columns Delete Column","title":"Introduction"},{"location":"xamarin-forms/grids/delete-row-columns/#mac","text":"","title":"Mac"},{"location":"xamarin-forms/grids/delete-row-columns/#windows","text":"","title":"Windows"},{"location":"xamarin-forms/grids/delete-row-columns/#links","text":"See the announcement in the Blog ( GitHub ).","title":"Links"},{"location":"xamarin-forms/grids/insert-row-columns/","text":"Insert a new row or column and update all indices and spans Introduction When working with Grids, it is a common workflow to add a new row or column and then update the row/column indices and spans. MFractor contains these options, right-click on a row and select 'MFractor Code Actions' Insert Row Before Insert Row After The same is available for columns Insert Column Before Insert Column After Mac Windows Links See the announcement in the Blog ( GitHub ).","title":"Insert Grid Row/Column"},{"location":"xamarin-forms/grids/insert-row-columns/#introduction","text":"When working with Grids, it is a common workflow to add a new row or column and then update the row/column indices and spans. MFractor contains these options, right-click on a row and select 'MFractor Code Actions' Insert Row Before Insert Row After The same is available for columns Insert Column Before Insert Column After","title":"Introduction"},{"location":"xamarin-forms/grids/insert-row-columns/#mac","text":"","title":"Mac"},{"location":"xamarin-forms/grids/insert-row-columns/#windows","text":"","title":"Windows"},{"location":"xamarin-forms/grids/insert-row-columns/#links","text":"See the announcement in the Blog ( GitHub ).","title":"Links"},{"location":"xamarin-forms/grids/intellisense/","text":"Quickly declare grids with its boilerplate code and manage its rows and columns declarations and child positioning Introduction MFractor introduces several intellisense commands to aid on writing Xamarin.Forms layouts using the Grid component. Those commands allows you to: Declare a new Grid element including its boilerplate code Declare Row or Column definitions for auto and star widht/height Declare the Row or Column or the Span of child elements of a grid Using the Grid Intellisense Features The Grid intellisense appears on the appropriate contexts when editing XAML files. On the next sections we will build a login form in an XAML Page using the Grid layout. This layout will have 3 rows and two columns, where the first column will have the labels and the second column the entries, and the third row will span among the columns to add the login button. The result will look as below: Grid Boilerplate Code Completion To start our login form we will declare a new Grid inside a Frame element in a ContentPage . The frame itself will be inside a root grid element. This allows to produce a login form that looks like a floating card on the screen. Start with the following XAML code for the page: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.GridSamplesPage\" > <Grid> <Frame> </Frame> </Grid> </ContentPage> Place the cursor inside the blank line on the Frame element (row number 7) and type an opening angle bracket ( < ) to declare a new XML element. The Intellisense suggestions will appear: When the Intellisense suggestions is open you can start typing to filter what you need. Hit the G and r keys, and the suggestion for Grid (Boilerplate) should appear at the end of the list: The intellisense tooltip provides a little preview of what will be generated to you. Select the option with either the cursor keys or the mouse and type Enter or Tab to apply the suggestion. The editor will add the declaration of a Grid with the boilerplate for declaring its Rows and Column definitions like the snippet below: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid> Grid Row and Column Shorthand Completions Next we need to declare the Columns and Rows definitions of our grid. This tells the Xamarin.Forms Grid engine how it will apply the available space to it's children elements. Row and Column definitions declares their width or height based on one of the 3 unit types: Auto , Proportional (also know as star, declared with the * char) or Absolute . Tip For more information about the Grid Rows and Columns declaration see the Official Xamarin.Forms docs for the Grid . With the MFractor Intellisense completions for Grid you can quickly declare rows and columns definitions. First lets declare our Column Definitions. There will be two Columns, the first will by automatically sized and the second will be proportional. Start a new line on the Grid.ColumDefinitions element and typpe an opening angle bracket to start a new element declaration. Intellisense appears and you should immediatly see the * and Auto options available to the list: Both are completions provided by MFractor. For the first column, select the Auto option and type Enter or Tab to apply the completion. MFractor will add a new ColumDefinition entry like below: <ColumnDefinition Width= \"Auto\" /> Repeat the steps to add a new proportional column definition by selecting the * option in the list. It will add the following definition: <ColumnDefinition Width= \"*\" /> Note You can still type to filter the options even when they already appear on the list. This would save some keystrokes or having to move the mouse to the wanted element. Next repeat the same process to add 3 new Row Definitions, all of the proportional height. The end result of your grid definition should be as follows: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width= \"Auto\" /> <ColumnDefinition Width= \"*\" /> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> </Grid.RowDefinitions> </Grid> Grid Row and Column Location Completions The last step for our login form is to declare its containing elements. We will declare two Label elements, two Entry elements and a Button element. We'll be using the MFractor intellisense grid location suggestion to easily define where our elements should be put in the available rows and columns of the grid. First, let's declare the labels. Inside the Grid we declared before add a new Label declaration. When you hit space to start adding attributes to the element, intellisense will list suggested properties of the label. Type G then r to filter the list and you should see the suggestions for the available columns and rows of the Grid: Those are the suggestions provided by the MFractor Grid Intellisense location feature. Notice that when you select a suggestion and wait a second a tooltip appears showing details about the width or height of the column or row in question. Important The grid location intellisense completion only appears for Grid elements that declares rows or columns definitions. A plain Grid element will not suggest any completion, because MFractor is unable to infer how may rows and columns the grid may contain. If you don't find those suggestions check the rows and columns definitions. For this first label we want to add it to the first row and the first column of the grid, so use the completions to quickly add the attached properties to the label. Its final declaration should be like below: <Label Grid.Column= \"0\" Grid.Row= \"0\" VerticalOptions= \"Center\" Text= \"Username\" /> Repeat the steps to create a new label, but change the Grid.Row property to 1 and the Text property to Password . Next add the declarations for the Entry elements, the code rest of the code for this part of the form is as follows: <Label Grid.Column= \"0\" Grid.Row= \"1\" VerticalOptions= \"Center\" Text= \"Password\" /> <Entry Grid.Column= \"1\" Grid.Row= \"0\" Placeholder= \"Your username\" /> <Entry Grid.Column= \"1\" Grid.Row= \"1\" IsPassword= \"True\" Placeholder= \"Your password\" /> Use the IntelliSense completions to easily fill the row and column information of each element. Grid Row and Column Span Completions The last part is to add the login button. It will take the entire third row of the grid, so we should add a column span to allow it use the entire width of the grid. First you should add the declaration of the button adding its row and column locations. As in the preview iterations, hit a new line to add a new attribute for the column span and start typing G and r , the suggestions for either column and row span should appear wiht intellisense: The final button declaration should be as follow: <Button Grid.Column= \"0\" Grid.Row= \"2\" Grid.ColumnSpan= \"2\" Text= \"Login\" /> Note For the span completions to appear you should declare both the Grid.Row and Grid.Column for that element, so MFractor can calculate the available span options for each direction. Summary On this tutorial document we've checked how to use the MFractor Grid Intellisense features to quickly produce a new Grid layout for a login forms in Xamarin.Forms. The complete source code for this tutorial is available at GitHub on our samples repository. Check the official Grid documentation on the Xamarin.Forms docs for further information about how to use the Grid layout component.","title":"Grid Intellisense Commands"},{"location":"xamarin-forms/grids/intellisense/#introduction","text":"MFractor introduces several intellisense commands to aid on writing Xamarin.Forms layouts using the Grid component. Those commands allows you to: Declare a new Grid element including its boilerplate code Declare Row or Column definitions for auto and star widht/height Declare the Row or Column or the Span of child elements of a grid","title":"Introduction"},{"location":"xamarin-forms/grids/intellisense/#using-the-grid-intellisense-features","text":"The Grid intellisense appears on the appropriate contexts when editing XAML files. On the next sections we will build a login form in an XAML Page using the Grid layout. This layout will have 3 rows and two columns, where the first column will have the labels and the second column the entries, and the third row will span among the columns to add the login button. The result will look as below:","title":"Using the Grid Intellisense Features"},{"location":"xamarin-forms/grids/intellisense/#grid-boilerplate-code-completion","text":"To start our login form we will declare a new Grid inside a Frame element in a ContentPage . The frame itself will be inside a root grid element. This allows to produce a login form that looks like a floating card on the screen. Start with the following XAML code for the page: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.GridSamplesPage\" > <Grid> <Frame> </Frame> </Grid> </ContentPage> Place the cursor inside the blank line on the Frame element (row number 7) and type an opening angle bracket ( < ) to declare a new XML element. The Intellisense suggestions will appear: When the Intellisense suggestions is open you can start typing to filter what you need. Hit the G and r keys, and the suggestion for Grid (Boilerplate) should appear at the end of the list: The intellisense tooltip provides a little preview of what will be generated to you. Select the option with either the cursor keys or the mouse and type Enter or Tab to apply the suggestion. The editor will add the declaration of a Grid with the boilerplate for declaring its Rows and Column definitions like the snippet below: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid>","title":"Grid Boilerplate Code Completion"},{"location":"xamarin-forms/grids/intellisense/#grid-row-and-column-shorthand-completions","text":"Next we need to declare the Columns and Rows definitions of our grid. This tells the Xamarin.Forms Grid engine how it will apply the available space to it's children elements. Row and Column definitions declares their width or height based on one of the 3 unit types: Auto , Proportional (also know as star, declared with the * char) or Absolute . Tip For more information about the Grid Rows and Columns declaration see the Official Xamarin.Forms docs for the Grid . With the MFractor Intellisense completions for Grid you can quickly declare rows and columns definitions. First lets declare our Column Definitions. There will be two Columns, the first will by automatically sized and the second will be proportional. Start a new line on the Grid.ColumDefinitions element and typpe an opening angle bracket to start a new element declaration. Intellisense appears and you should immediatly see the * and Auto options available to the list: Both are completions provided by MFractor. For the first column, select the Auto option and type Enter or Tab to apply the completion. MFractor will add a new ColumDefinition entry like below: <ColumnDefinition Width= \"Auto\" /> Repeat the steps to add a new proportional column definition by selecting the * option in the list. It will add the following definition: <ColumnDefinition Width= \"*\" /> Note You can still type to filter the options even when they already appear on the list. This would save some keystrokes or having to move the mouse to the wanted element. Next repeat the same process to add 3 new Row Definitions, all of the proportional height. The end result of your grid definition should be as follows: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width= \"Auto\" /> <ColumnDefinition Width= \"*\" /> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> </Grid.RowDefinitions> </Grid>","title":"Grid Row and Column Shorthand Completions"},{"location":"xamarin-forms/grids/intellisense/#grid-row-and-column-location-completions","text":"The last step for our login form is to declare its containing elements. We will declare two Label elements, two Entry elements and a Button element. We'll be using the MFractor intellisense grid location suggestion to easily define where our elements should be put in the available rows and columns of the grid. First, let's declare the labels. Inside the Grid we declared before add a new Label declaration. When you hit space to start adding attributes to the element, intellisense will list suggested properties of the label. Type G then r to filter the list and you should see the suggestions for the available columns and rows of the Grid: Those are the suggestions provided by the MFractor Grid Intellisense location feature. Notice that when you select a suggestion and wait a second a tooltip appears showing details about the width or height of the column or row in question. Important The grid location intellisense completion only appears for Grid elements that declares rows or columns definitions. A plain Grid element will not suggest any completion, because MFractor is unable to infer how may rows and columns the grid may contain. If you don't find those suggestions check the rows and columns definitions. For this first label we want to add it to the first row and the first column of the grid, so use the completions to quickly add the attached properties to the label. Its final declaration should be like below: <Label Grid.Column= \"0\" Grid.Row= \"0\" VerticalOptions= \"Center\" Text= \"Username\" /> Repeat the steps to create a new label, but change the Grid.Row property to 1 and the Text property to Password . Next add the declarations for the Entry elements, the code rest of the code for this part of the form is as follows: <Label Grid.Column= \"0\" Grid.Row= \"1\" VerticalOptions= \"Center\" Text= \"Password\" /> <Entry Grid.Column= \"1\" Grid.Row= \"0\" Placeholder= \"Your username\" /> <Entry Grid.Column= \"1\" Grid.Row= \"1\" IsPassword= \"True\" Placeholder= \"Your password\" /> Use the IntelliSense completions to easily fill the row and column information of each element.","title":"Grid Row and Column Location Completions"},{"location":"xamarin-forms/grids/intellisense/#grid-row-and-column-span-completions","text":"The last part is to add the login button. It will take the entire third row of the grid, so we should add a column span to allow it use the entire width of the grid. First you should add the declaration of the button adding its row and column locations. As in the preview iterations, hit a new line to add a new attribute for the column span and start typing G and r , the suggestions for either column and row span should appear wiht intellisense: The final button declaration should be as follow: <Button Grid.Column= \"0\" Grid.Row= \"2\" Grid.ColumnSpan= \"2\" Text= \"Login\" /> Note For the span completions to appear you should declare both the Grid.Row and Grid.Column for that element, so MFractor can calculate the available span options for each direction.","title":"Grid Row and Column Span Completions"},{"location":"xamarin-forms/grids/intellisense/#summary","text":"On this tutorial document we've checked how to use the MFractor Grid Intellisense features to quickly produce a new Grid layout for a login forms in Xamarin.Forms. The complete source code for this tutorial is available at GitHub on our samples repository. Check the official Grid documentation on the Xamarin.Forms docs for further information about how to use the Grid layout component.","title":"Summary"},{"location":"xamarin-forms/grids/shorthand-declaration-refactorings/","text":"Convert row and column definitions between shorthand and longhand formatted declarations Introduction Introduced in Xamarin.Forms v4.7, developers are able to declare grid row and columns as a comma-separated list of values within an attribute . This significantly reduces the amount of code required to declare new rows or columns, making the codebase cleaner and easier to maintain. For example, consider the example below: <Grid VerticalOptions=\"FillAndExpand\"> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"*\"/> <ColumnDefinition Width=\"2*\"/> <ColumnDefinition Width=\"Auto\"/> <ColumnDefinition Width=\"300\"/> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height=\"1*\"/> <RowDefinition Height=\"Auto\"/> <RowDefinition Height=\"25\"/> <RowDefinition Height=\"14\"/> <RowDefinition Height=\"20\"/> </Grid.RowDefinitions> </Grid> With the new shorthand-style declarations, it would become this. <Grid VerticalOptions=\"FillAndExpand\" RowDefinitions=\"1*, Auto, 25, 14, 20\" ColumnDefinitions=\"*, 2*, Auto, 300\"> </Grid> To help you work with the new methodology, MFractor includes refactorings to convert your grid rows and columns between these two formats: Important Shorthand style row and column definitions are only available in Xamarin.Forms 4.7 and above. The refactorings described in this article will not appear in lower versions of Xamarin.Forms. Convert To Attribute Format When the grids rows or columns are declared using as Xml nodes, press Alt+Return on the Grid.RowDefinitions or Grid.ColumnDefinitions and choose Convert to attribute format . This will change the declaration to attribute format. Convert To Node Format When the grids rows or columns are declared using using the attribute format, press Alt+Return on the Grid.RowDefinitions or Grid.ColumnDefinitions and choose Convert to node format . This will change the declaration to node format.","title":"Shorthand Declaration Refactorings"},{"location":"xamarin-forms/grids/shorthand-declaration-refactorings/#introduction","text":"Introduced in Xamarin.Forms v4.7, developers are able to declare grid row and columns as a comma-separated list of values within an attribute . This significantly reduces the amount of code required to declare new rows or columns, making the codebase cleaner and easier to maintain. For example, consider the example below: <Grid VerticalOptions=\"FillAndExpand\"> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"*\"/> <ColumnDefinition Width=\"2*\"/> <ColumnDefinition Width=\"Auto\"/> <ColumnDefinition Width=\"300\"/> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height=\"1*\"/> <RowDefinition Height=\"Auto\"/> <RowDefinition Height=\"25\"/> <RowDefinition Height=\"14\"/> <RowDefinition Height=\"20\"/> </Grid.RowDefinitions> </Grid> With the new shorthand-style declarations, it would become this. <Grid VerticalOptions=\"FillAndExpand\" RowDefinitions=\"1*, Auto, 25, 14, 20\" ColumnDefinitions=\"*, 2*, Auto, 300\"> </Grid> To help you work with the new methodology, MFractor includes refactorings to convert your grid rows and columns between these two formats: Important Shorthand style row and column definitions are only available in Xamarin.Forms 4.7 and above. The refactorings described in this article will not appear in lower versions of Xamarin.Forms.","title":"Introduction"},{"location":"xamarin-forms/grids/shorthand-declaration-refactorings/#convert-to-attribute-format","text":"When the grids rows or columns are declared using as Xml nodes, press Alt+Return on the Grid.RowDefinitions or Grid.ColumnDefinitions and choose Convert to attribute format . This will change the declaration to attribute format.","title":"Convert To Attribute Format"},{"location":"xamarin-forms/grids/shorthand-declaration-refactorings/#convert-to-node-format","text":"When the grids rows or columns are declared using using the attribute format, press Alt+Return on the Grid.RowDefinitions or Grid.ColumnDefinitions and choose Convert to node format . This will change the declaration to node format.","title":"Convert To Node Format"},{"location":"xamarin-forms/grids/tooltips/","text":"Previewing the referenced grid row or columns Introduction When working with Grids in XAML, we often need to understand the layout behaviour of a row or column. While we can refer to the row or column definition, MFractor provides tooltips that display the width or height behaviour for a given row or column. Grid.Row Tooltips To view the row information of an element, hover your mouse over the Grid.Row attribute on the element. MFractor will provide a short preview of the layout behaviour of that row. Grid.RowSpan Tooltips To view the details of each row within a row span, hover your cursor over the Grid.RowSpan attribute. MFractor will provide a short preview for each row that the row span covers. Grid.Column Tooltips To view the column information of an element, hover your mouse over the Grid.Column attribute on the element. MFractor will provide a short preview of the layout behaviour of that column. Grid.ColumnSpan Tooltips To view the details of each column within a column span, hover your cursor over the Grid.ColumnSpan attribute. MFractor will provide a short preview for each column that the column span covers.","title":"Tooltips"},{"location":"xamarin-forms/grids/tooltips/#introduction","text":"When working with Grids in XAML, we often need to understand the layout behaviour of a row or column. While we can refer to the row or column definition, MFractor provides tooltips that display the width or height behaviour for a given row or column.","title":"Introduction"},{"location":"xamarin-forms/grids/tooltips/#gridrow-tooltips","text":"To view the row information of an element, hover your mouse over the Grid.Row attribute on the element. MFractor will provide a short preview of the layout behaviour of that row.","title":"Grid.Row Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridrowspan-tooltips","text":"To view the details of each row within a row span, hover your cursor over the Grid.RowSpan attribute. MFractor will provide a short preview for each row that the row span covers.","title":"Grid.RowSpan Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridcolumn-tooltips","text":"To view the column information of an element, hover your mouse over the Grid.Column attribute on the element. MFractor will provide a short preview of the layout behaviour of that column.","title":"Grid.Column Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridcolumnspan-tooltips","text":"To view the details of each column within a column span, hover your cursor over the Grid.ColumnSpan attribute. MFractor will provide a short preview for each column that the column span covers.","title":"Grid.ColumnSpan Tooltips"},{"location":"xamarin-forms/images/analysis/","text":"Code inspections to verify image asset usages Introduction In Xamarin.Forms, the ImageSource class is used represent an image asset to connect an image included in our platform projects into the user interface. For example: <Image Source=\"app_logo\"/> In the above example, we are referencing an image asset named app_logo to display in our UI. As each platform project (iOS, Android, UWP) uses a specific method of including image assets, it is easy to mis-type an image reference and have it not appear at runtime. Missing Image Detection MFractor will automatically inspect XAML properties that are an ImageSource and verify that the referenced image asset exists in each platform project: Correcting An Image Reference When MFractor can locate another image asset that is closely named to the missing image reference, it suggests a code-fix to apply the found image asset name instead. Importing A Missing Image MFractor will also offer a code-fix to launch the Image Importer to import a new image asset and fix the missing image reference.","title":"Analysis"},{"location":"xamarin-forms/images/analysis/#introduction","text":"In Xamarin.Forms, the ImageSource class is used represent an image asset to connect an image included in our platform projects into the user interface. For example: <Image Source=\"app_logo\"/> In the above example, we are referencing an image asset named app_logo to display in our UI. As each platform project (iOS, Android, UWP) uses a specific method of including image assets, it is easy to mis-type an image reference and have it not appear at runtime.","title":"Introduction"},{"location":"xamarin-forms/images/analysis/#missing-image-detection","text":"MFractor will automatically inspect XAML properties that are an ImageSource and verify that the referenced image asset exists in each platform project:","title":"Missing Image Detection"},{"location":"xamarin-forms/images/analysis/#correcting-an-image-reference","text":"When MFractor can locate another image asset that is closely named to the missing image reference, it suggests a code-fix to apply the found image asset name instead.","title":"Correcting An Image Reference"},{"location":"xamarin-forms/images/analysis/#importing-a-missing-image","text":"MFractor will also offer a code-fix to launch the Image Importer to import a new image asset and fix the missing image reference.","title":"Importing A Missing Image"},{"location":"xamarin-forms/images/code-completion/","text":"IntelliSense completions to assist with working with image assets in XAML Introduction When working with the Image control in Xamarin.Forms, we use the Source property to connect an image included in our platform projects into the user interface. For example: <Image Source=\"app_logo\"/> One of the difficulties however is that we need to know ahead of time the image assets available for us to use. Out of the box, Visual Studio does not provide code completions for the available image assets. Image Asset IntelliSense MFractor includes image asset IntelliSense that surfaces all image assets declared within the linked iOS, Android and UWP projects in IntelliSense. To trigger image asset IntelliSense, start typing inside any XAML property that is of type ImageSource : MFractor will suggest all available image assets and provides a preview of each image asset to help you visually locate the correct image. Import Image Asset IntelliSense MFractor also includes an IntelliSense shortcut to import a new image asset directly from the code completion Window. This action will launch the Image Importer and inject the name of the selected image asset into the XAML attribute after completion. To open the image importer from IntelliSense, start typing inside any XAML property that is of type ImageSource :","title":"Code Completion"},{"location":"xamarin-forms/images/code-completion/#introduction","text":"When working with the Image control in Xamarin.Forms, we use the Source property to connect an image included in our platform projects into the user interface. For example: <Image Source=\"app_logo\"/> One of the difficulties however is that we need to know ahead of time the image assets available for us to use. Out of the box, Visual Studio does not provide code completions for the available image assets.","title":"Introduction"},{"location":"xamarin-forms/images/code-completion/#image-asset-intellisense","text":"MFractor includes image asset IntelliSense that surfaces all image assets declared within the linked iOS, Android and UWP projects in IntelliSense. To trigger image asset IntelliSense, start typing inside any XAML property that is of type ImageSource : MFractor will suggest all available image assets and provides a preview of each image asset to help you visually locate the correct image.","title":"Image Asset IntelliSense"},{"location":"xamarin-forms/images/code-completion/#import-image-asset-intellisense","text":"MFractor also includes an IntelliSense shortcut to import a new image asset directly from the code completion Window. This action will launch the Image Importer and inject the name of the selected image asset into the XAML attribute after completion. To open the image importer from IntelliSense, start typing inside any XAML property that is of type ImageSource :","title":"Import Image Asset IntelliSense"},{"location":"xamarin-forms/images/replace-with-icon-image-source/","text":"Migrate usages of the deprecated Icon property to IconImageSource Introduction In Xamarin.Forms 4.0, the Icon property was deprecated in favour of the IconImageSource property. This change enabled developers to use the newly introduced FontImageSource to use font glyphs for icons throughout your application. Deprecate Icon When MFractor encounters a usage of the Icon property that has been marked as obsolete, it will suggest that you change Icon to IconImageSource : Replace With IconImageSource To resolve this code warning, you can click on the Replace with IconImageSource suggestion in the tooltip to apply the code fix.","title":"Replace With IconImageSource"},{"location":"xamarin-forms/images/replace-with-icon-image-source/#introduction","text":"In Xamarin.Forms 4.0, the Icon property was deprecated in favour of the IconImageSource property. This change enabled developers to use the newly introduced FontImageSource to use font glyphs for icons throughout your application.","title":"Introduction"},{"location":"xamarin-forms/images/replace-with-icon-image-source/#deprecate-icon","text":"When MFractor encounters a usage of the Icon property that has been marked as obsolete, it will suggest that you change Icon to IconImageSource :","title":"Deprecate Icon"},{"location":"xamarin-forms/images/replace-with-icon-image-source/#replace-with-iconimagesource","text":"To resolve this code warning, you can click on the Replace with IconImageSource suggestion in the tooltip to apply the code fix.","title":"Replace With IconImageSource"},{"location":"xamarin-forms/localization/localization-wizard/","text":"Prepare your project for localization adding the required files and resources. Introduction Xamarin.Forms have powerful tools for localizing your apps based on the .NET platform. The Localization Wizard is a tool to prepare your project for localizing its resources.","title":"Localization wizard"},{"location":"xamarin-forms/localization/localization-wizard/#introduction","text":"Xamarin.Forms have powerful tools for localizing your apps based on the .NET platform. The Localization Wizard is a tool to prepare your project for localizing its resources.","title":"Introduction"},{"location":"xamarin-forms/static-resources/analysis/","text":"Inspections that verify static resource declarations and expressions Introduction This documentation article outlines the XAML analysers and code fixes that are available for static resource expressions and declarations. Missing Static Resource When referencing a resource using a StaticResource expression, MFractor will validate that the given resource key is available in the current Using A Nearly Named Resource When MFractor detects that key provided to a StaticResource expression is unresolved, however, it closely matches another the name of another available resource name, MFractor suggests that resource and provides a code-fix to Static Resource Return Type Mismatch When a static resource expression returns a type that does not match the expected type of the targeted attribute, it will warn of a type mismatch between the expected type of that attribute and the expressions return type. If the property type has a TypeConverterAttribute applied to it (EG: to enable converting a string value into a LayoutOptions), MFractor will not analyse the type flow. Ambiguous Static Resource When two or more resources are defined using the same name but in different scopes, the final result of a StaticResource expression is ambiguous. For example, if a page defines a resource named primaryColor and the App.xaml also defined a resource named primaryColor , we now have two resources with the same name available to the page. It is ambiguous which one we are referencing when we use the expression {StaticResource primaryColor} . The Ambiguous Static Resource analyser detects when an expressions resource key resolves to more than one available resource and provides a warning that the referenced resource is ambiguous. No Key Provided For Static Resource When declaring a new resource inside a ResourceDictionary , we include an x:Key attribute to define the key that is used to lookup the resource with a StaticResource expression. Unless the element is a style, all resources must include a resource key. To fix this issue, hover over the code issue and in the tooltip, click on the Generate a key for this resource fix. Resource Key Conflict When declaring a new resource for a page or control, it is common to accidentally use the same key multiple times (either in the same page or ) This analyser inspects the x:Key attribute of each resource definition and verifies that it is unique within the current scope. OnPlatform Return Type Mismatch When a static resource expression returns an OnPlatform element, MFractor will verify that the type specified by the x:TypeArguments is compatible with the expected type of the attribute.","title":"Analysis"},{"location":"xamarin-forms/static-resources/analysis/#introduction","text":"This documentation article outlines the XAML analysers and code fixes that are available for static resource expressions and declarations.","title":"Introduction"},{"location":"xamarin-forms/static-resources/analysis/#missing-static-resource","text":"When referencing a resource using a StaticResource expression, MFractor will validate that the given resource key is available in the current","title":"Missing Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#using-a-nearly-named-resource","text":"When MFractor detects that key provided to a StaticResource expression is unresolved, however, it closely matches another the name of another available resource name, MFractor suggests that resource and provides a code-fix to","title":"Using A Nearly Named Resource"},{"location":"xamarin-forms/static-resources/analysis/#static-resource-return-type-mismatch","text":"When a static resource expression returns a type that does not match the expected type of the targeted attribute, it will warn of a type mismatch between the expected type of that attribute and the expressions return type. If the property type has a TypeConverterAttribute applied to it (EG: to enable converting a string value into a LayoutOptions), MFractor will not analyse the type flow.","title":"Static Resource Return Type Mismatch"},{"location":"xamarin-forms/static-resources/analysis/#ambiguous-static-resource","text":"When two or more resources are defined using the same name but in different scopes, the final result of a StaticResource expression is ambiguous. For example, if a page defines a resource named primaryColor and the App.xaml also defined a resource named primaryColor , we now have two resources with the same name available to the page. It is ambiguous which one we are referencing when we use the expression {StaticResource primaryColor} . The Ambiguous Static Resource analyser detects when an expressions resource key resolves to more than one available resource and provides a warning that the referenced resource is ambiguous.","title":"Ambiguous Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#no-key-provided-for-static-resource","text":"When declaring a new resource inside a ResourceDictionary , we include an x:Key attribute to define the key that is used to lookup the resource with a StaticResource expression. Unless the element is a style, all resources must include a resource key. To fix this issue, hover over the code issue and in the tooltip, click on the Generate a key for this resource fix.","title":"No Key Provided For Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#resource-key-conflict","text":"When declaring a new resource for a page or control, it is common to accidentally use the same key multiple times (either in the same page or ) This analyser inspects the x:Key attribute of each resource definition and verifies that it is unique within the current scope.","title":"Resource Key Conflict"},{"location":"xamarin-forms/static-resources/analysis/#onplatform-return-type-mismatch","text":"When a static resource expression returns an OnPlatform element, MFractor will verify that the type specified by the x:TypeArguments is compatible with the expected type of the attribute.","title":"OnPlatform Return Type Mismatch"},{"location":"xamarin-forms/static-resources/refactoring/","text":"Move and refactor your applications XAML resources Introduction This documentation article outlines the XAML resource refactorings provided by MFractor. Extracting Values Into Resources The Extract value into local resource refactoring enables you to extract an attributes value into a local or global resource, replacing the Extracting the value into a local resource Extracting the value into the App.xaml Moving Resources Up To The App.xaml The Move Resource To App.xaml refactoring allows you to move a local resource to your App.xaml so that it can be used globally. Tip After a resource is moved into the App.xaml, any resource analysers that target that resource kind will take affect across your entire project. For example, you can move a local color resource into your app.xaml and MFractor will then start to globally match any duplicate inline color values to that color. This allows you to keep your code clean and tidy. Generating Resource Code Behind Lookup The Generating Resource Code Behind Lookup refactoring creates a C# statement in the XAML code-behind that retrieves the resource via a property. This code action enables you to expose XAML resources to your code behind class.","title":"Refactoring"},{"location":"xamarin-forms/static-resources/refactoring/#introduction","text":"This documentation article outlines the XAML resource refactorings provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/static-resources/refactoring/#extracting-values-into-resources","text":"The Extract value into local resource refactoring enables you to extract an attributes value into a local or global resource, replacing the Extracting the value into a local resource Extracting the value into the App.xaml","title":"Extracting Values Into Resources"},{"location":"xamarin-forms/static-resources/refactoring/#moving-resources-up-to-the-appxaml","text":"The Move Resource To App.xaml refactoring allows you to move a local resource to your App.xaml so that it can be used globally. Tip After a resource is moved into the App.xaml, any resource analysers that target that resource kind will take affect across your entire project. For example, you can move a local color resource into your app.xaml and MFractor will then start to globally match any duplicate inline color values to that color. This allows you to keep your code clean and tidy.","title":"Moving Resources Up To The App.xaml"},{"location":"xamarin-forms/static-resources/refactoring/#generating-resource-code-behind-lookup","text":"The Generating Resource Code Behind Lookup refactoring creates a C# statement in the XAML code-behind that retrieves the resource via a property. This code action enables you to expose XAML resources to your code behind class.","title":"Generating Resource Code Behind Lookup"},{"location":"xamarin-forms/static-resources/search/","text":"Search your solution for static resources Introduction Dynamic Resource Overview Declaraing Dynamic Resources Using Dynamic Resources Using Dynamic Resource Search","title":"Search"},{"location":"xamarin-forms/static-resources/search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/static-resources/search/#dynamic-resource-overview","text":"","title":"Dynamic Resource Overview"},{"location":"xamarin-forms/static-resources/search/#declaraing-dynamic-resources","text":"","title":"Declaraing Dynamic Resources"},{"location":"xamarin-forms/static-resources/search/#using-dynamic-resources","text":"","title":"Using Dynamic Resources"},{"location":"xamarin-forms/static-resources/search/#using-dynamic-resource-search","text":"","title":"Using Dynamic Resource Search"},{"location":"xamarin-forms/static-resources/tooltips/","text":"Preview the result of a static resource expression Introduction Previewing General Resources When you hover over a static resource expression, MFractor will render an XML preview of that static resource. Static resource tooltips will work for all resource expressions that can be resolved. Previewing Colors When you hover over a static resource expression that returns a Color , MFractor will render a preview of the color: Color resource tooltips are useful as they allow you to visually preview what a color Previewing Styles If you hover over a static resource expression that returns a Style , MFractor will render an XML preview of that style: Style tooltips will include the following information: Each Setter included in the style. The x:Key of that style. If the style has a parent, this inheritance is also included.","title":"Tooltips"},{"location":"xamarin-forms/static-resources/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-general-resources","text":"When you hover over a static resource expression, MFractor will render an XML preview of that static resource. Static resource tooltips will work for all resource expressions that can be resolved.","title":"Previewing General Resources"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-colors","text":"When you hover over a static resource expression that returns a Color , MFractor will render a preview of the color: Color resource tooltips are useful as they allow you to visually preview what a color","title":"Previewing Colors"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-styles","text":"If you hover over a static resource expression that returns a Style , MFractor will render an XML preview of that style: Style tooltips will include the following information: Each Setter included in the style. The x:Key of that style. If the style has a parent, this inheritance is also included.","title":"Previewing Styles"},{"location":"xamarin-forms/thicknesses/analysis/","text":"Code inspections to spot various common issues in thickness usage Introduction When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors, but it comes harder being an even more abstract kind of asset. Thickness Analysis to the rescue! Avaliable Tools MFractor provides a few handful code analysis to aid in managing thicknesses declarations: Thickness Consolidation : watches for duplicate declaration of thicknesses values and suggest consolidation. Validate and Simplify : validates thickness declaration suggesting simplifications where appliable and informing of mismatches.","title":"Thickness Analysis"},{"location":"xamarin-forms/thicknesses/analysis/#introduction","text":"When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors, but it comes harder being an even more abstract kind of asset. Thickness Analysis to the rescue!","title":"Introduction"},{"location":"xamarin-forms/thicknesses/analysis/#avaliable-tools","text":"MFractor provides a few handful code analysis to aid in managing thicknesses declarations: Thickness Consolidation : watches for duplicate declaration of thicknesses values and suggest consolidation. Validate and Simplify : validates thickness declaration suggesting simplifications where appliable and informing of mismatches.","title":"Avaliable Tools"},{"location":"xamarin-forms/thicknesses/consolidation/","text":"Manage your thicknesses declarations as a project asset. Introduction When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors. Thickness consolidation tools allows us to easily apply and manage those standards. Duplicate Thickness Declaration Analysis This analyzer inspects the active document scanning properties of the type Thickness and check if a declaration is repetitive among other XAML of the current project. If MFractor find the same thickness declaration 2 or more times, a warning is issued to let the user know of this duplication: From the tooltip you can invoke tools for consolidation. View all usages This action will bring the Search Results Pad/Toolbar Window showing the list of files and the places where this thickness declaration is being used: Consolidate into a Static Resource Having knowledge of the places where you've already used this thickness declaration you can now consolidate them as a Static Resource and handle it as a project asset. By invoking this action you'll ask for a name to identify this thickness declaration: An entry will be added to the App.xaml static resources dictionary and then every instance of the thickness will be replaced by a Static Resource declaration. Tip MFractor bases this analysis on the Thickness data type and not on separate properties that may be of this type. This means that margin and padding properties that has the same thickness declaration are considered duplicate declarations. Even though MFractor doesn't make this distinction on property types, you may wish to have separte Static Resources to represent margin and padding values. This may be useful in case your requirements for this different kinds of properties changes. Thickness Replacement Analysis When you have thickness declared as static resources in your project, the analysis will identify if the declaration matches any existing one and will suggest to apply it: You can even replace all the instances of the same thickness declaration, which is very handy when we are not used to Static Resources declaration.","title":"Consolidate"},{"location":"xamarin-forms/thicknesses/consolidation/#introduction","text":"When developing user interfaces with Xamarin.Forms margin and padding are constantly applied to elements to provide the desired spacing. Turns out that this spacing definitions are very standard among views on a carefully crafted design. So we keep declaring those constants tens of times which is tedious and error prone. It's useful to have those spacings declared in a single place and referenced by a descriptive name, like we usually do with colors. Thickness consolidation tools allows us to easily apply and manage those standards.","title":"Introduction"},{"location":"xamarin-forms/thicknesses/consolidation/#duplicate-thickness-declaration-analysis","text":"This analyzer inspects the active document scanning properties of the type Thickness and check if a declaration is repetitive among other XAML of the current project. If MFractor find the same thickness declaration 2 or more times, a warning is issued to let the user know of this duplication: From the tooltip you can invoke tools for consolidation.","title":"Duplicate Thickness Declaration Analysis"},{"location":"xamarin-forms/thicknesses/consolidation/#view-all-usages","text":"This action will bring the Search Results Pad/Toolbar Window showing the list of files and the places where this thickness declaration is being used:","title":"View all usages"},{"location":"xamarin-forms/thicknesses/consolidation/#consolidate-into-a-static-resource","text":"Having knowledge of the places where you've already used this thickness declaration you can now consolidate them as a Static Resource and handle it as a project asset. By invoking this action you'll ask for a name to identify this thickness declaration: An entry will be added to the App.xaml static resources dictionary and then every instance of the thickness will be replaced by a Static Resource declaration. Tip MFractor bases this analysis on the Thickness data type and not on separate properties that may be of this type. This means that margin and padding properties that has the same thickness declaration are considered duplicate declarations. Even though MFractor doesn't make this distinction on property types, you may wish to have separte Static Resources to represent margin and padding values. This may be useful in case your requirements for this different kinds of properties changes.","title":"Consolidate into a Static Resource"},{"location":"xamarin-forms/thicknesses/consolidation/#thickness-replacement-analysis","text":"When you have thickness declared as static resources in your project, the analysis will identify if the declaration matches any existing one and will suggest to apply it: You can even replace all the instances of the same thickness declaration, which is very handy when we are not used to Static Resources declaration.","title":"Thickness Replacement Analysis"},{"location":"xamarin-forms/thicknesses/intellisense/","text":"Quickly and easily create a new MVVM Component Introduction Using the MVVM Wizard","title":"Intellisense"},{"location":"xamarin-forms/thicknesses/intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/thicknesses/intellisense/#using-the-mvvm-wizard","text":"","title":"Using the MVVM Wizard"},{"location":"xamarin-forms/thicknesses/invalid-thickness/","text":"Avoid typos and simplify declarations for better legibility. Introduction In Xamarin.Forms there are a few ways of declaring Thickness values on XAML files. Novices tend to get confused by the available ways of doing this, and experience programmers can also fall on typos. This code analysis tries to aid you on identifying mismatches and cases where the declaration can be simplified. Declaring Thicknesses Thicknesses values can be declared mainly to Padding and Margin properties of XAML (althought other custom components may use it for other purposes). The Thickness type is a struct that declares four main properties: Left, Right, Top, Bottom. It's used to represent the of spacing of of each of those four directions. Suppose you want to declare a Label that has a margin around itself of 8 points on its left and right sides and 16 points on its top and bottom: <Label Text= \"Thickness Sample\" Margin= \"8,16,8,16\" /> When declaring a Thickness you pass the value of each side separeted by a comma in the following order: [left],[top],[right],[bottom] . I personally like to think of a line going around a box starting from its left side until it closes itself, its how I always remember this order of sides. It turns out that the values for left and right are the same, as the values for the bottom and bottom. This is a so common scenario that Xamarin.Forms allows you to simplify this declaration using only 2 values: <Label Text= \"Thickness Sample\" Margin= \"8,16\" /> This is equivalent to the previous declaration. The first number refers to margin that will be set to the left and right of the label (referred to as horizontal size ), and second refers to its top and bottom (referred to as vertical size ). The code analysis will check for such declarations and suggest you to simplify then: But wait, there's more! Sometimes you wish to apply the same margin value to every side. This is called uniform size and you can declare it as a single value: <Label Text= \"Thickness Sample\" Margin= \"16\" /> This will apply a margin of 16 points to each side of this label. The analyzer also identifies declarations that are considered uniform, such as 16,16,16,16 or 16,16 and provides suggestion for simplification. Invalid Values Any values that falls out off the patterns presented on the previous section are invalid thickness declarations. Thankfully, XAML compilation is standard for new Xamarin.Forms projects, and invalid declarations are catch on build time. But for older projects that doesn't use pre-compiled XAML assets, MFractor brings a handy analyzer that prevents those errors to occur on runtime:","title":"Validate and Simplify"},{"location":"xamarin-forms/thicknesses/invalid-thickness/#introduction","text":"In Xamarin.Forms there are a few ways of declaring Thickness values on XAML files. Novices tend to get confused by the available ways of doing this, and experience programmers can also fall on typos. This code analysis tries to aid you on identifying mismatches and cases where the declaration can be simplified.","title":"Introduction"},{"location":"xamarin-forms/thicknesses/invalid-thickness/#declaring-thicknesses","text":"Thicknesses values can be declared mainly to Padding and Margin properties of XAML (althought other custom components may use it for other purposes). The Thickness type is a struct that declares four main properties: Left, Right, Top, Bottom. It's used to represent the of spacing of of each of those four directions. Suppose you want to declare a Label that has a margin around itself of 8 points on its left and right sides and 16 points on its top and bottom: <Label Text= \"Thickness Sample\" Margin= \"8,16,8,16\" /> When declaring a Thickness you pass the value of each side separeted by a comma in the following order: [left],[top],[right],[bottom] . I personally like to think of a line going around a box starting from its left side until it closes itself, its how I always remember this order of sides. It turns out that the values for left and right are the same, as the values for the bottom and bottom. This is a so common scenario that Xamarin.Forms allows you to simplify this declaration using only 2 values: <Label Text= \"Thickness Sample\" Margin= \"8,16\" /> This is equivalent to the previous declaration. The first number refers to margin that will be set to the left and right of the label (referred to as horizontal size ), and second refers to its top and bottom (referred to as vertical size ). The code analysis will check for such declarations and suggest you to simplify then: But wait, there's more! Sometimes you wish to apply the same margin value to every side. This is called uniform size and you can declare it as a single value: <Label Text= \"Thickness Sample\" Margin= \"16\" /> This will apply a margin of 16 points to each side of this label. The analyzer also identifies declarations that are considered uniform, such as 16,16,16,16 or 16,16 and provides suggestion for simplification.","title":"Declaring Thicknesses"},{"location":"xamarin-forms/thicknesses/invalid-thickness/#invalid-values","text":"Any values that falls out off the patterns presented on the previous section are invalid thickness declarations. Thankfully, XAML compilation is standard for new Xamarin.Forms projects, and invalid declarations are catch on build time. But for older projects that doesn't use pre-compiled XAML assets, MFractor brings a handy analyzer that prevents those errors to occur on runtime:","title":"Invalid Values"},{"location":"xamarin-forms/value-converters/analysis/","text":"","title":"Analysis"},{"location":"xamarin-forms/value-converters/value-converter-wizard/","text":"Quickly create a Value Converter and reference it on your XAML code Introduction Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic. Using the Wizard The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behaviour of the newly created Value Converter and the options are as follows: Name and Location Parameters Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convention Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Please see the Automatic Type Inference documentation to learn more. Folder : the folder where the converter will be created inside the project. Defaults to Converters . Type Parameters Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the chosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object . Input Type Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method. Output Type Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned. Parameter Type Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: <Label Text= \"{Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'}\" /> The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type. Optional XML Entry Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: <ResourceDictionary> <converters:BoolNegationConverter x:Key= \"boolNegationConverter\" /> </ResourceDictionary> MFractor will also take care of adding the required namespace imports to the file. Default Code Snippet This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Value Converter Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#introduction","text":"Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic.","title":"Introduction"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#using-the-wizard","text":"The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behaviour of the newly created Value Converter and the options are as follows:","title":"Using the Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#name-and-location-parameters","text":"Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convention Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Please see the Automatic Type Inference documentation to learn more. Folder : the folder where the converter will be created inside the project. Defaults to Converters .","title":"Name and Location Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#type-parameters","text":"Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the chosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object .","title":"Type Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#input-type","text":"Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method.","title":"Input Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#output-type","text":"Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned.","title":"Output Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#parameter-type","text":"Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: <Label Text= \"{Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'}\" /> The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type.","title":"Parameter Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#optional-xml-entry","text":"Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: <ResourceDictionary> <converters:BoolNegationConverter x:Key= \"boolNegationConverter\" /> </ResourceDictionary> MFractor will also take care of adding the required namespace imports to the file.","title":"Optional XML Entry"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#default-code-snippet","text":"This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Default Code Snippet"},{"location":"xamarin-forms/working-with-styles/analysis/","text":"Code analysers that inspect usages of Style's and spot a variety of common issues Introduction Styles are one of the most powerful building blocks in Xamarin.Forms for crafting clean, maintainable XAML code. Using styles, we can group initialise a set of properties with values for an element into reusable collection. This allows us to ensure a consistent user interface and organises the maintenance of a visual appearance into a single place. A style is composed of the following syntax structures: The Style tag declares the style. The TargetType attribute specifies the type that the style applies to. The x:Key declares a resource key we can use to lookup this style. If no x:Key is defined, the style is implicit and is automatically applied to all elements matching TargetType in the scope. The BasedOn and BaseKey The inner Setter element(s) targets a Property on the specified TargetType and initialises it with a Value . Let's consider the following code: <Style x:Key=\"TitleLabelStyle\" TargetType=\"Label\"> <Setter Property=\"FontSize\" Value=\"Large\"/> <Setter Property=\"FontAttributes\" Value=\"Bold\"/> <Setter Property=\"TextColor\" Value=\"{StaticResource AccentOne}\"/ </Style> We would then apply this style using a StaticResource expression: <Label Style=\"{StaticResource TitleLabelStyle}\"/> The Label will automatically apply the FontSize=\"Large\" , FontAttributes=\"Bold\" and TextColor=\"TextColor\" properties as specified by the TitleLabelStyle style. MFractor provides many code inspections and fixes that help make working with styles much easier. Style Is Missing TargetType When you declare a style, it must include a TargetType attribute that specifies type the style applies to. Styles defined without a target type are invalid and will cause a compiler error. MFractor will detect this and notify you when a style does not have the TargetType attribute: MFractor will also offer a code fix to add the missing TargetType attribute. Style Has Duplicate Setters When declaring new Style , each property defined by a Setter only needs to be declared once. MFractor inspects a styles Setter 's and verifies that only one setter per property is applied: Static Resource Style Target Type Is Incompatible When using a Style , the TargetType of that style must be compatible with the type of the element it is applied onto. If the types are not compatible, your app will crash at runtime. MFractor inspects the TargetType of a styles applied onto elements and verifies that they are type-compatible. Style TargetType Does Not Match BasedOn TargetType When using the BasedOn and BaseResourceKey to create style inheritance, MFactor will inspect the parent styles TargetType and make sure that the types are compatible. Property Setter Does Not Exist In Style TargetType When creating a new style and configuring its Setters , MFractor will inspect the value provided to the Property attribute and verify that they exist on the TargetType : Property Value Is Already Applied By Style When a style is applied onto an element, and that element initalises a property to the same value as initialised by the style, MFractor will provide a warning that the property initialise is redundant: MFractor will also offer code fixes to remove all property initialisations that are already set to the same value by the style. Unknown Style Detection MFractor will inspect StaticResource expressions and verify that the referenced style exists within the application. MFractor will offer a code-fix to generate a new style when a missing style is detected. Triggering this code fix will launch the style creation tool. Additionally, if the style name closely matches a known static resource, MFractor will offer to replace the invalid name with an autocorrection.","title":"Analysis"},{"location":"xamarin-forms/working-with-styles/analysis/#introduction","text":"Styles are one of the most powerful building blocks in Xamarin.Forms for crafting clean, maintainable XAML code. Using styles, we can group initialise a set of properties with values for an element into reusable collection. This allows us to ensure a consistent user interface and organises the maintenance of a visual appearance into a single place. A style is composed of the following syntax structures: The Style tag declares the style. The TargetType attribute specifies the type that the style applies to. The x:Key declares a resource key we can use to lookup this style. If no x:Key is defined, the style is implicit and is automatically applied to all elements matching TargetType in the scope. The BasedOn and BaseKey The inner Setter element(s) targets a Property on the specified TargetType and initialises it with a Value . Let's consider the following code: <Style x:Key=\"TitleLabelStyle\" TargetType=\"Label\"> <Setter Property=\"FontSize\" Value=\"Large\"/> <Setter Property=\"FontAttributes\" Value=\"Bold\"/> <Setter Property=\"TextColor\" Value=\"{StaticResource AccentOne}\"/ </Style> We would then apply this style using a StaticResource expression: <Label Style=\"{StaticResource TitleLabelStyle}\"/> The Label will automatically apply the FontSize=\"Large\" , FontAttributes=\"Bold\" and TextColor=\"TextColor\" properties as specified by the TitleLabelStyle style. MFractor provides many code inspections and fixes that help make working with styles much easier.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/analysis/#style-is-missing-targettype","text":"When you declare a style, it must include a TargetType attribute that specifies type the style applies to. Styles defined without a target type are invalid and will cause a compiler error. MFractor will detect this and notify you when a style does not have the TargetType attribute: MFractor will also offer a code fix to add the missing TargetType attribute.","title":"Style Is Missing TargetType"},{"location":"xamarin-forms/working-with-styles/analysis/#style-has-duplicate-setters","text":"When declaring new Style , each property defined by a Setter only needs to be declared once. MFractor inspects a styles Setter 's and verifies that only one setter per property is applied:","title":"Style Has Duplicate Setters"},{"location":"xamarin-forms/working-with-styles/analysis/#static-resource-style-target-type-is-incompatible","text":"When using a Style , the TargetType of that style must be compatible with the type of the element it is applied onto. If the types are not compatible, your app will crash at runtime. MFractor inspects the TargetType of a styles applied onto elements and verifies that they are type-compatible.","title":"Static Resource Style Target Type Is Incompatible"},{"location":"xamarin-forms/working-with-styles/analysis/#style-targettype-does-not-match-basedon-targettype","text":"When using the BasedOn and BaseResourceKey to create style inheritance, MFactor will inspect the parent styles TargetType and make sure that the types are compatible.","title":"Style TargetType Does Not Match BasedOn TargetType"},{"location":"xamarin-forms/working-with-styles/analysis/#property-setter-does-not-exist-in-style-targettype","text":"When creating a new style and configuring its Setters , MFractor will inspect the value provided to the Property attribute and verify that they exist on the TargetType :","title":"Property Setter Does Not Exist In Style TargetType"},{"location":"xamarin-forms/working-with-styles/analysis/#property-value-is-already-applied-by-style","text":"When a style is applied onto an element, and that element initalises a property to the same value as initialised by the style, MFractor will provide a warning that the property initialise is redundant: MFractor will also offer code fixes to remove all property initialisations that are already set to the same value by the style.","title":"Property Value Is Already Applied By Style"},{"location":"xamarin-forms/working-with-styles/analysis/#unknown-style-detection","text":"MFractor will inspect StaticResource expressions and verify that the referenced style exists within the application. MFractor will offer a code-fix to generate a new style when a missing style is detected. Triggering this code fix will launch the style creation tool. Additionally, if the style name closely matches a known static resource, MFractor will offer to replace the invalid name with an autocorrection.","title":"Unknown Style Detection"},{"location":"xamarin-forms/working-with-styles/extracting-styles/","text":"A rich toolbox for quickly extract and organize XAML styles. Introduction Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply. How to Extract a style The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style. Configuring the Style Extraction The extraction dialog offer several options to control how the extraction will be done. Name The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element. TargetType The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes. Target Type Xmlns This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: <Style x:Key= \"[styleName]\" TargetType= \"views:Label\" > <!-- The rest of the style declaration --> </Style> File The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application. Parent The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey=\"[ParentResourceKey]\" For a BasedOn parent type, the output will be: BasedOn=\"{StaticResource [ParentResourceKey]}\" If you leave the parent resource key field blank the parent declaration will be supressed. Properties The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style. Previewing the new Style The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: <Style x:Key= \"[styleName]\" TargetType= \"[TargetType]\" BaseResourceKey= \"[ParentResouceKey]\" BasedOn= \"{StaticResource [ParentResourceKey]}\" > <Setter Property= \"[PropertyName]\" Value= \"[PropertyValue]\" /> <!-- Repeats for each property set in the dialog... --> </Style> Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section. Extracting the Style By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: <Label Style= \"{StaticResource defaultLabel}\" /> Summary The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Extracting Styles"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#introduction","text":"Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#how-to-extract-a-style","text":"The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style.","title":"How to Extract a style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#configuring-the-style-extraction","text":"The extraction dialog offer several options to control how the extraction will be done.","title":"Configuring the Style Extraction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#name","text":"The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element.","title":"Name"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#targettype","text":"The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes.","title":"TargetType"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#target-type-xmlns","text":"This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: <Style x:Key= \"[styleName]\" TargetType= \"views:Label\" > <!-- The rest of the style declaration --> </Style>","title":"Target Type Xmlns"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#file","text":"The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application.","title":"File"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#parent","text":"The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey=\"[ParentResourceKey]\" For a BasedOn parent type, the output will be: BasedOn=\"{StaticResource [ParentResourceKey]}\" If you leave the parent resource key field blank the parent declaration will be supressed.","title":"Parent"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#properties","text":"The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style.","title":"Properties"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#previewing-the-new-style","text":"The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: <Style x:Key= \"[styleName]\" TargetType= \"[TargetType]\" BaseResourceKey= \"[ParentResouceKey]\" BasedOn= \"{StaticResource [ParentResourceKey]}\" > <Setter Property= \"[PropertyName]\" Value= \"[PropertyValue]\" /> <!-- Repeats for each property set in the dialog... --> </Style> Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section.","title":"Previewing the new Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#extracting-the-style","text":"By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: <Label Style= \"{StaticResource defaultLabel}\" />","title":"Extracting the Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#summary","text":"The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Summary"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/","text":"Inspects XAML elements that do not have a style applied and, if possible, matches them to an available style that targets the element type and also applies the same properties. Introduction Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties. Matching Style Detection The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element. Applying A Matching style When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style. Disabling This Code Analyser The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Matching Style Analysis"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#introduction","text":"Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#matching-style-detection","text":"The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element.","title":"Matching Style Detection"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#applying-a-matching-style","text":"When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style.","title":"Applying A Matching style"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#disabling-this-code-analyser","text":"The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Disabling This Code Analyser"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/","text":"Code inspections to verify data-binding expressions. Introduction Data-Binding Expressions are XAML Markup Extensions that allows you to describe how a property is bound. Markup expressions are a kind of DSL (domain-specific language) that allows you to describe extended information on attributes of XML documents. Markup expressions are just validated against it syntax, but you can still write a Binding Expression that references invalid properties and it won't cause runtime issues other than simply not working as expected. The Code analysis tools provided by MFractor guards you against common issues that are hard track other than by trial and error. Note Most of the Binding Expressions Analysis relies on a implicit or explicit Binding Context. Make sure to understand how MFractor resolves the Binding Context of a file to ensure the analysis are correctly applied. Data-Binding Expression Analysis Binding Expressions must declare a Path that resolves to a public property of the Binding Context and the data types must match. Check out the Data Binding Bascis docs for more information about Binding Expressions. The code analysis helps you validate those requirements. For the examples bellow consider the following Binding Context class: public class BindingAnalyzersViewModel { // A public field for storing the name. public string Name ; // A private property for storing the Email. private string Email { get ; set ; } // The user Birthday stored as a string public string Birthday { get ; set ; } } Expression is against an invalid symbol This analysis validates and warn if the expression path doesn't resolve to any symbol on the binding context. In the example bellow we try to bind against a non-existing Mail member: Some fix suggestions may appear on the code analysis tooltip: If MFractor identifies a similar named properties on the Binding Context it will suggest replacements, example: Replace with 'Email' action. MFractor can generate a new property on the binding context, the generated property will have the name of the expression and will match the type of the target property, example: Generate property named ' Mail' in 'BindingAnalyzersViewModel action. Expression doesn't return a property This analysis validates and warn if the expression path refers to a field or method rather than a property. In the example bellow we try to bind against the public field Name : To fix this issue you should provide a path to a existing public property or refactor the field to a property. Expression is against non-public property This analysis will validate if your expression resolves to a public property of the Binding Context. In the example bellow we try to bind against the private Email property: To fix this issue you can either change the access modifier of the property or change the path to reference a valid public property. Expression doesn't Resolve to a Compatible Type This analysis will validate if your expression resolves to a public property of the same type of the element property being bound to. In the example bellow we try to bind the Date property of the DatePicker that is of the type DateTime against the Birthday property of the context that is a string : The analyzer tooltip provides a fix suggestion of creating a Value Converter which invokes the MFractor Value Converter Wizard . You can also fix this issue by adjusting the data type of the source to match target property type.","title":"Data Binding Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#introduction","text":"Data-Binding Expressions are XAML Markup Extensions that allows you to describe how a property is bound. Markup expressions are a kind of DSL (domain-specific language) that allows you to describe extended information on attributes of XML documents. Markup expressions are just validated against it syntax, but you can still write a Binding Expression that references invalid properties and it won't cause runtime issues other than simply not working as expected. The Code analysis tools provided by MFractor guards you against common issues that are hard track other than by trial and error. Note Most of the Binding Expressions Analysis relies on a implicit or explicit Binding Context. Make sure to understand how MFractor resolves the Binding Context of a file to ensure the analysis are correctly applied.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#data-binding-expression-analysis","text":"Binding Expressions must declare a Path that resolves to a public property of the Binding Context and the data types must match. Check out the Data Binding Bascis docs for more information about Binding Expressions. The code analysis helps you validate those requirements. For the examples bellow consider the following Binding Context class: public class BindingAnalyzersViewModel { // A public field for storing the name. public string Name ; // A private property for storing the Email. private string Email { get ; set ; } // The user Birthday stored as a string public string Birthday { get ; set ; } }","title":"Data-Binding Expression Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#expression-is-against-an-invalid-symbol","text":"This analysis validates and warn if the expression path doesn't resolve to any symbol on the binding context. In the example bellow we try to bind against a non-existing Mail member: Some fix suggestions may appear on the code analysis tooltip: If MFractor identifies a similar named properties on the Binding Context it will suggest replacements, example: Replace with 'Email' action. MFractor can generate a new property on the binding context, the generated property will have the name of the expression and will match the type of the target property, example: Generate property named ' Mail' in 'BindingAnalyzersViewModel action.","title":"Expression is against an invalid symbol"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#expression-doesnt-return-a-property","text":"This analysis validates and warn if the expression path refers to a field or method rather than a property. In the example bellow we try to bind against the public field Name : To fix this issue you should provide a path to a existing public property or refactor the field to a property.","title":"Expression doesn't return a property"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#expression-is-against-non-public-property","text":"This analysis will validate if your expression resolves to a public property of the Binding Context. In the example bellow we try to bind against the private Email property: To fix this issue you can either change the access modifier of the property or change the path to reference a valid public property.","title":"Expression is against non-public property"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/#expression-doesnt-resolve-to-a-compatible-type","text":"This analysis will validate if your expression resolves to a public property of the same type of the element property being bound to. In the example bellow we try to bind the Date property of the DatePicker that is of the type DateTime against the Birthday property of the context that is a string : The analyzer tooltip provides a fix suggestion of creating a Value Converter which invokes the MFractor Value Converter Wizard . You can also fix this issue by adjusting the data type of the source to match target property type.","title":"Expression doesn't Resolve to a Compatible Type"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/","text":"Locate ViewModel properties while editing binding expressions and generate properties and commands This feature is available in MFractor Professional Introduction Data-binding is one of top features of Xamarin.Forms allowing you to easily create reactive components declaratively, and is core to the the MVVM pattern. MFractor enhances Visual Studio by adding powerful intellisense for working with data-binding over XAML files, by providing completions and actions that generate code without the need of going back and forth a View and its View Model. Using Data-Binding IntelliSense The data-binding intellisense is available on the XAML editor for Views that have a corresponding View Model class. Check-out the Automatic View Model Detection docs to understand how MFractor identify View Models. Those features appears to Bindable Properties on the objects you declare to your XAML files and depending on the context and conditions of your code. Expression Binding IntelliSense Binding Expressions are XAML Markup Extensions that allows you to describe how a property is bound. A simple expression just describes to which property of the Binding Context that property should be bound to, such as: <Entry Placeholder= \"Enter your name\" Text= \"{Binding Name}\" /> The example above bounds the Text property of the entry field to the Name property of the context. Using the MVVM pattern we normaly set the context to a View Model class specific to that view. When a View has a View Model class related to it, MFractor will automatically identify the class properties and suggest them as you type your Binding Expression, like the following example: MFractor also validates your Binding Expressions with the Data-Binding Code Analysis tools. Shorthand Binding IntelliSense This is similar to the previous one, but it appears as suggestion when you start typing on any bindable property that doesn't have a Binding Expression declared. In the following example we want to bind the Text property of the Entry component to an Email property that already exists in our View Model: Notice that the tooltip provides all information about the source of the property and a preview of the code that will be inserted. Generating Commands and Properties MFractor can generate Commands and Properties to your View Model directly from the XAML editor. This option appears as an Action on the Intellisense menu. When you declare an attribute of a Bindable Property of that object, the following will be presented: If the suggestion doesn't appear as you type you can use the CTLR + Space shortcut to show the menu. By selecting this option the following dialog will be presented: Type the name you want for the property and click ok to have it generated on your View Model class, based on the following snippet: public string Name { get ; set ; } Info MFractor currently doesn't support custom declaration of View Models properties, such as ones that call OnPropertyChanged method for INotifyPropertyChanged implementors or that relies on base class methods. While custom templates for property generation is under consideration for future versions (and we appreciate your comments on our Feedback Page ), we've found that most users prefer to use PropertyChanged.Fody package to inject this behavior in their View Model classes. Fody is a powerful weaving tool for .NET that allows code to be injected during the compilation, and automates the generation several boilerplate code. For more information check the project repository . If the Bindable Property is of the type ICommand MFractor will also show an option for generating a Command to the View Model as well: Just like with the Generate Property, you can force the intellisense options to appear with the CTRL + Space shortcut. Selecting the option will present the Create Command dialog: Type the name you want for the command and click ok to have it generated on your View Model class, based on the following snippet: public ICommand SignUpCommand { get { return new Command (() => { throw new NotImplementedException (); }); } } Notice that this will also add the required using statements for ICommand and Command types.","title":"Data Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#introduction","text":"Data-binding is one of top features of Xamarin.Forms allowing you to easily create reactive components declaratively, and is core to the the MVVM pattern. MFractor enhances Visual Studio by adding powerful intellisense for working with data-binding over XAML files, by providing completions and actions that generate code without the need of going back and forth a View and its View Model.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#using-data-binding-intellisense","text":"The data-binding intellisense is available on the XAML editor for Views that have a corresponding View Model class. Check-out the Automatic View Model Detection docs to understand how MFractor identify View Models. Those features appears to Bindable Properties on the objects you declare to your XAML files and depending on the context and conditions of your code.","title":"Using Data-Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#expression-binding-intellisense","text":"Binding Expressions are XAML Markup Extensions that allows you to describe how a property is bound. A simple expression just describes to which property of the Binding Context that property should be bound to, such as: <Entry Placeholder= \"Enter your name\" Text= \"{Binding Name}\" /> The example above bounds the Text property of the entry field to the Name property of the context. Using the MVVM pattern we normaly set the context to a View Model class specific to that view. When a View has a View Model class related to it, MFractor will automatically identify the class properties and suggest them as you type your Binding Expression, like the following example: MFractor also validates your Binding Expressions with the Data-Binding Code Analysis tools.","title":"Expression Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#shorthand-binding-intellisense","text":"This is similar to the previous one, but it appears as suggestion when you start typing on any bindable property that doesn't have a Binding Expression declared. In the following example we want to bind the Text property of the Entry component to an Email property that already exists in our View Model: Notice that the tooltip provides all information about the source of the property and a preview of the code that will be inserted.","title":"Shorthand Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#generating-commands-and-properties","text":"MFractor can generate Commands and Properties to your View Model directly from the XAML editor. This option appears as an Action on the Intellisense menu. When you declare an attribute of a Bindable Property of that object, the following will be presented: If the suggestion doesn't appear as you type you can use the CTLR + Space shortcut to show the menu. By selecting this option the following dialog will be presented: Type the name you want for the property and click ok to have it generated on your View Model class, based on the following snippet: public string Name { get ; set ; } Info MFractor currently doesn't support custom declaration of View Models properties, such as ones that call OnPropertyChanged method for INotifyPropertyChanged implementors or that relies on base class methods. While custom templates for property generation is under consideration for future versions (and we appreciate your comments on our Feedback Page ), we've found that most users prefer to use PropertyChanged.Fody package to inject this behavior in their View Model classes. Fody is a powerful weaving tool for .NET that allows code to be injected during the compilation, and automates the generation several boilerplate code. For more information check the project repository . If the Bindable Property is of the type ICommand MFractor will also show an option for generating a Command to the View Model as well: Just like with the Generate Property, you can force the intellisense options to appear with the CTRL + Space shortcut. Selecting the option will present the Create Command dialog: Type the name you want for the command and click ok to have it generated on your View Model class, based on the following snippet: public ICommand SignUpCommand { get { return new Command (() => { throw new NotImplementedException (); }); } } Notice that this will also add the required using statements for ICommand and Command types.","title":"Generating Commands and Properties"},{"location":"xamarin-forms/working-with-viewmodels/generating-properties-and-commands/","text":"Creating new ViewModel properties and commands from your View","title":"Generating Properties/Commands"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/","text":"Quickly and easily create a new MVVM Component This feature is available in MFractor Professional Introduction When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file. Using the MVVM Wizard The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented. Wizard Options The Wizard is pretty simple and only asks you about two pieces of information: Target Project A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created. Name The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings . Previewing the files The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code. Wizard Settings As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard. Wizard Settings Options The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options. View Project A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. View Suffix Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page View Folder Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages View Base Class and XML Namespace This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to <namespace:ClassName> to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages Binding Context Initialisation In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers. Initialise BindingContext in Code-Behind This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel => BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } } Initialise BindingContext in XAML This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: <ContentPage xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns= \"http://xamarin.com/schemas/2014/forms\" x:Class= \"MFractor.Samples.Pages.Page\" xmlns:viewModels= \"clr-namespace:MFractor.Samples.ViewModels\" > <ContentPage.BindingContext> <viewModels:ViewModel x:Key= \"ViewModel\" /> </ContentPage.BindingContext> </ContentPage> Register Withing Application.RegisterTypes Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation < Pages . HomePage , ViewModels . HomeViewModel >(); } ViewModel Project A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. ViewModel Suffix Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel ViewModel Folder Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels ViewModel Base Class Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix . Reseting Settings If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#introduction","text":"When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#using-the-mvvm-wizard","text":"The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented.","title":"Using the MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-options","text":"The Wizard is pretty simple and only asks you about two pieces of information:","title":"Wizard Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#target-project","text":"A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created.","title":"Target Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#name","text":"The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings .","title":"Name"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#previewing-the-files","text":"The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code.","title":"Previewing the files"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings","text":"As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard.","title":"Wizard Settings"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings-options","text":"The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options.","title":"Wizard Settings Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-project","text":"A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"View Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-suffix","text":"Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page","title":"View Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-folder","text":"Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages","title":"View Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-base-class-and-xml-namespace","text":"This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to <namespace:ClassName> to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages","title":"View Base Class and XML Namespace"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#binding-context-initialisation","text":"In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers.","title":"Binding Context Initialisation"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-code-behind","text":"This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel => BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } }","title":"Initialise BindingContext in Code-Behind"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-xaml","text":"This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: <ContentPage xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns= \"http://xamarin.com/schemas/2014/forms\" x:Class= \"MFractor.Samples.Pages.Page\" xmlns:viewModels= \"clr-namespace:MFractor.Samples.ViewModels\" > <ContentPage.BindingContext> <viewModels:ViewModel x:Key= \"ViewModel\" /> </ContentPage.BindingContext> </ContentPage>","title":"Initialise BindingContext in XAML"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#register-withing-applicationregistertypes","text":"Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation < Pages . HomePage , ViewModels . HomeViewModel >(); }","title":"Register Withing Application.RegisterTypes"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-project","text":"A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"ViewModel Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-suffix","text":"Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel","title":"ViewModel Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-folder","text":"Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels","title":"ViewModel Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-base-class","text":"Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix .","title":"ViewModel Base Class"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#reseting-settings","text":"If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"Reseting Settings"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/","text":"Navigation shortcuts to switch among the core components of the MVVM pattern Introduction The Model-View-ViewModel (MVVM) is a modern architectural pattern for building applications based on XAML views. It allows us separate Model and View logic from View declaration while keeping the code clean and testable. This pattern is widely used in Xamarin.Forms applications and by convention each View is composed of 3 files: The XAML View ( .xaml ) file where we describe our UI declaratively The View's code-behind ( .xaml.cs ) file The View Model , a C# class that provide View logic through properties and commands that are bound to the view using the data-binding engine Important Please read the Binding Context Resolution documentation to understand how MFractor associates view models with XAML views. When working on a View you frequently switch back and forth this 3 files. Manually switching from the Solution Explorer or the open tabs is tedious and time-consuming. MFractor adds several shortcuts for navigating among those files. Using the Navigation Shortcuts The shortcuts becames available contextually when one of the 3 files that compose a group is open and active on the code editor. Shortcuts are available on the context menu of editor: There are also very convenient and easy to remember keyboard shortcuts available: Navigation Shortcuts Go-To View Model \u2325 + \u21e7 + 1 Alt + 1 Go-To Code-Behind \u2325 + \u21e7 + 2 Alt + 2 Go-To View \u2325 + \u21e7 + 3 Alt + 3 Tip Use the MVVM Wizard to create a XAML View with its corresponding code-behind and View Model files all at once, and using standards and conventions that you can set on project basis.","title":"View-ViewModel Navigation"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#introduction","text":"The Model-View-ViewModel (MVVM) is a modern architectural pattern for building applications based on XAML views. It allows us separate Model and View logic from View declaration while keeping the code clean and testable. This pattern is widely used in Xamarin.Forms applications and by convention each View is composed of 3 files: The XAML View ( .xaml ) file where we describe our UI declaratively The View's code-behind ( .xaml.cs ) file The View Model , a C# class that provide View logic through properties and commands that are bound to the view using the data-binding engine Important Please read the Binding Context Resolution documentation to understand how MFractor associates view models with XAML views. When working on a View you frequently switch back and forth this 3 files. Manually switching from the Solution Explorer or the open tabs is tedious and time-consuming. MFractor adds several shortcuts for navigating among those files.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#using-the-navigation-shortcuts","text":"The shortcuts becames available contextually when one of the 3 files that compose a group is open and active on the code editor. Shortcuts are available on the context menu of editor: There are also very convenient and easy to remember keyboard shortcuts available: Navigation Shortcuts Go-To View Model \u2325 + \u21e7 + 1 Alt + 1 Go-To Code-Behind \u2325 + \u21e7 + 2 Alt + 2 Go-To View \u2325 + \u21e7 + 3 Alt + 3 Tip Use the MVVM Wizard to create a XAML View with its corresponding code-behind and View Model files all at once, and using standards and conventions that you can set on project basis.","title":"Using the Navigation Shortcuts"}]}