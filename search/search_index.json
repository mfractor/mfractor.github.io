{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to the documentation for MFractor, a powerful productivity tool for Xamarin developers. MFractor is available for the Visual Studio Windows and Visual Studio Mac. Feature Matrix Check out the MFractor Feature Matrix for a list of all the featuers available to the product and to what editions and platforms it's available. Getting Started To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac Licensing MFractor's licensing levels and end user license can be found in our Licensing article. MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. Help And Support To get help using MFractor, please see our Support article. Release Notes MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Home"},{"location":"#welcome","text":"Welcome to the documentation for MFractor, a powerful productivity tool for Xamarin developers. MFractor is available for the Visual Studio Windows and Visual Studio Mac.","title":"Welcome"},{"location":"#feature-matrix","text":"Check out the MFractor Feature Matrix for a list of all the featuers available to the product and to what editions and platforms it's available.","title":"Feature Matrix"},{"location":"#getting-started","text":"To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac","title":"Getting Started"},{"location":"#licensing","text":"MFractor's licensing levels and end user license can be found in our Licensing article.","title":"Licensing"},{"location":"#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy .","title":"MFractor Professional"},{"location":"#mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day.","title":"MFractor Lite"},{"location":"#help-and-support","text":"To get help using MFractor, please see our Support article.","title":"Help And Support"},{"location":"#release-notes","text":"MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Release Notes"},{"location":"code-actions/","text":"Enhance your developer productivity with contextual refactorings, code generation and utilities Introduction Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code. Using the Code Actions MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documetation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied. Code Actions for C# Code The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu: Code Actions for XAML Code The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to referece it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action. List of MFractor Code Actions Warning The complete list of MFractor is still being compiled. Here we show only the currently documented ones. C# Code Actions Language Code Actions Generate Interface Imlementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String Xamarin.Forms Code Actions Create Bindable Property Create Attached Property XAML Code Actions Extract XAML Style Extract Custom Control Generate a new View Model for XAML view","title":"Code Actions"},{"location":"code-actions/#introduction","text":"Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code.","title":"Introduction"},{"location":"code-actions/#using-the-code-actions","text":"MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documetation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied.","title":"Using the Code Actions"},{"location":"code-actions/#code-actions-for-c-code","text":"The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu:","title":"Code Actions for C# Code"},{"location":"code-actions/#code-actions-for-xaml-code","text":"The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to referece it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action.","title":"Code Actions for XAML Code"},{"location":"code-actions/#list-of-mfractor-code-actions","text":"Warning The complete list of MFractor is still being compiled. Here we show only the currently documented ones.","title":"List of MFractor Code Actions"},{"location":"code-actions/#c-code-actions","text":"","title":"C# Code Actions"},{"location":"code-actions/#language-code-actions","text":"Generate Interface Imlementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String","title":"Language Code Actions"},{"location":"code-actions/#xamarinforms-code-actions","text":"Create Bindable Property Create Attached Property","title":"Xamarin.Forms Code Actions"},{"location":"code-actions/#xaml-code-actions","text":"Extract XAML Style Extract Custom Control Generate a new View Model for XAML view","title":"XAML Code Actions"},{"location":"contributing/","text":"Help us enhance and fix MFractor docs so everyone can get the most of this tool. Introduction The MFractor Documentation site is an open source project created and maintained by MFractor. Our goal is to provide rich documentation and reference to our users and customers so they can get the most of the tool. The docs is not only about the tool features itself, but we always try to bring knowledge on development platforms that MFractor assists. Mission Our readers must learn something new beyond the product feature they're searching information itself and enrich their knowledge of the platforms that our tool assists. Documenting a product is critical and hard to do right and keep up to date. The MFractor team is very small and strive to keep up with the ever changing product features. Community contribution is very desired and welcome to achieve the goal of having this site not only as a source of information for MFractor but also as an important knowledge base for developers. Contribution Workflow Contributing to MFractor Documentation is much like any Git hosted open source project: Pick an issue you wish to contribute and comment on Fork the project repository at GitHub Make your changes to your forked repository Open a Pull Request to merge your changes to the main repo If your changes are accepted we'll merge it and notify you about it. We may ask you for additional changes or reply with suggestions through comments on the Pull Request. In case we add suggestions to your Pull Request we will provide a 3 day time-frame for you to review before merging your changes. We may decide to apply the suggestions internally after the merge. This is the high level diagram of the Contribution Workflow: Important All the work to this repository is tracked through issues. We can't track forks to know about ongoing contributions to the project, so please keep your comments on the issues you may be working on so we can manage conflicts. If you've found a problem or a missing documentation that is not listed on the issues, please open one before starting your work. Info We may change parts of your contribution to fix typos, correct data or add missing information. This will be done without notice. Accepted contributions will be acknowledge on a specific section of the home page. Don't add the acknowledgements to your Pull Requests , otherwise they will be rejected. Citations will be only handled internally by our moderation team. Requirements This documentation is written using mkdocs , a popular platform for software documentation sites, and takes advantage of the mkdocs-material a plugin that adds material design concepts and themes to the site. To contribute you can use the mkdocs-material docker image (preferred) or will need to install a few things: Install Python . Install pip . Install mkdocs from the pip tool pip install mkdocs . Install the [Material Theme for mkdocs] from pip install mkdocs-material Important Make sure to install mkdocs and the material theme both using pip . If you install mkdocs from Homebrew and them install the material theme from pip (the only place where its available as a package) you will get errors trying to compile the docs or running it locally. Local installation is error prone. Consider using the docker image for faster and simpler setup. The script file docker-serve at the root of the repository ( docs branch) will try to download the correct image and run the local server. Extensions admonition and codehilite are part of the material theme. markdown_extensions: - attr_list - admonition - codehilite Troubleshooting If the Material Theme isn't installed when you try to run the project it won't work and you'll get the following error: mkdocs serve INFO - Building documentation... ERROR - Config value: 'theme'. Error: Unrecognised theme name: 'material'. The available installed themes are: readthedocs, mkdocs Make sure to install mkdocs and material theme from pip . Get in touch If you need further assistance on contribution please refer to Matthew Robins or Rafael Veronezi or open an issue. We'll be glas to assist.","title":"Contributing"},{"location":"contributing/#introduction","text":"The MFractor Documentation site is an open source project created and maintained by MFractor. Our goal is to provide rich documentation and reference to our users and customers so they can get the most of the tool. The docs is not only about the tool features itself, but we always try to bring knowledge on development platforms that MFractor assists. Mission Our readers must learn something new beyond the product feature they're searching information itself and enrich their knowledge of the platforms that our tool assists. Documenting a product is critical and hard to do right and keep up to date. The MFractor team is very small and strive to keep up with the ever changing product features. Community contribution is very desired and welcome to achieve the goal of having this site not only as a source of information for MFractor but also as an important knowledge base for developers.","title":"Introduction"},{"location":"contributing/#contribution-workflow","text":"Contributing to MFractor Documentation is much like any Git hosted open source project: Pick an issue you wish to contribute and comment on Fork the project repository at GitHub Make your changes to your forked repository Open a Pull Request to merge your changes to the main repo If your changes are accepted we'll merge it and notify you about it. We may ask you for additional changes or reply with suggestions through comments on the Pull Request. In case we add suggestions to your Pull Request we will provide a 3 day time-frame for you to review before merging your changes. We may decide to apply the suggestions internally after the merge. This is the high level diagram of the Contribution Workflow: Important All the work to this repository is tracked through issues. We can't track forks to know about ongoing contributions to the project, so please keep your comments on the issues you may be working on so we can manage conflicts. If you've found a problem or a missing documentation that is not listed on the issues, please open one before starting your work. Info We may change parts of your contribution to fix typos, correct data or add missing information. This will be done without notice. Accepted contributions will be acknowledge on a specific section of the home page. Don't add the acknowledgements to your Pull Requests , otherwise they will be rejected. Citations will be only handled internally by our moderation team.","title":"Contribution Workflow"},{"location":"contributing/#requirements","text":"This documentation is written using mkdocs , a popular platform for software documentation sites, and takes advantage of the mkdocs-material a plugin that adds material design concepts and themes to the site. To contribute you can use the mkdocs-material docker image (preferred) or will need to install a few things: Install Python . Install pip . Install mkdocs from the pip tool pip install mkdocs . Install the [Material Theme for mkdocs] from pip install mkdocs-material Important Make sure to install mkdocs and the material theme both using pip . If you install mkdocs from Homebrew and them install the material theme from pip (the only place where its available as a package) you will get errors trying to compile the docs or running it locally. Local installation is error prone. Consider using the docker image for faster and simpler setup. The script file docker-serve at the root of the repository ( docs branch) will try to download the correct image and run the local server.","title":"Requirements"},{"location":"contributing/#extensions","text":"admonition and codehilite are part of the material theme. markdown_extensions: - attr_list - admonition - codehilite","title":"Extensions"},{"location":"contributing/#troubleshooting","text":"If the Material Theme isn't installed when you try to run the project it won't work and you'll get the following error: mkdocs serve INFO - Building documentation... ERROR - Config value: 'theme'. Error: Unrecognised theme name: 'material'. The available installed themes are: readthedocs, mkdocs Make sure to install mkdocs and material theme from pip .","title":"Troubleshooting"},{"location":"contributing/#get-in-touch","text":"If you need further assistance on contribution please refer to Matthew Robins or Rafael Veronezi or open an issue. We'll be glas to assist.","title":"Get in touch"},{"location":"faq/","text":"Answers to commonly asked questions Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. Where do I find the latest version of MFractor? Visual Studio Macs The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300 Visual Studio Windows The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS What version of Visual Studio does MFractor support? Visual Studio Mac MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release. Visual Studio Window MFractor for Visual Studio Windows supports Visual Studio 2019 and higher. How do I get a refund? Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d Do you offer company licenses? Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing. I require an invoice or quote to purchase MFractor, can you provide one? Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order. How do I report a bug? To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug. I've got a great feature idea, how do I request it? Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality. I'd like to try MFractor Professional, how do I get a trial? To request an MFractor Professional trial, please email matthew@mfractor.com. How do I recover my MFractor Professional license? To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license. Where can I find MFracor's release notes? MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes Does MFractor support the Preview versions of Visual Studio? No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk. MFractor is not visible in Visual Studio Macs Extension Manager. MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ; I'd like to write a blog about MFractor. Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding. What is the .mfractor folder? The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it. Should I check .mfractor into source control? No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default. How do I uninstall MFractor for Visual Studio Windows manually? Locate the VSIXInstaller executable and run the following command: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE>VSIXInstaller.exe /u:9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c Our VSIX identifier is 9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c . Can you help me make a Visual Studio extension? Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call. Are you available for hire to develop Xamarin applications? Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with. Are you available for hire to develop Visual Studio extension? Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor. What is the licensing agreement? Please see our End User License . What is your privacy policy? Please see our Privacy Policy .","title":"FAQ"},{"location":"faq/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"faq/#where-do-i-find-the-latest-version-of-mfractor","text":"","title":"Where do I find the latest version of MFractor?"},{"location":"faq/#visual-studio-macs","text":"The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300","title":"Visual Studio Macs"},{"location":"faq/#visual-studio-windows","text":"The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS","title":"Visual Studio Windows"},{"location":"faq/#what-version-of-visual-studio-does-mfractor-support","text":"","title":"What version of Visual Studio does MFractor support?"},{"location":"faq/#visual-studio-mac","text":"MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release.","title":"Visual Studio Mac"},{"location":"faq/#visual-studio-window","text":"MFractor for Visual Studio Windows supports Visual Studio 2019 and higher.","title":"Visual Studio Window"},{"location":"faq/#how-do-i-get-a-refund","text":"Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d","title":"How do I get a refund?"},{"location":"faq/#do-you-offer-company-licenses","text":"Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing.","title":"Do you offer company licenses?"},{"location":"faq/#i-require-an-invoice-or-quote-to-purchase-mfractor-can-you-provide-one","text":"Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order.","title":"I require an invoice or quote to purchase MFractor, can you provide one?"},{"location":"faq/#how-do-i-report-a-bug","text":"To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug.","title":"How do I report a bug?"},{"location":"faq/#ive-got-a-great-feature-idea-how-do-i-request-it","text":"Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality.","title":"I've got a great feature idea, how do I request it?"},{"location":"faq/#id-like-to-try-mfractor-professional-how-do-i-get-a-trial","text":"To request an MFractor Professional trial, please email matthew@mfractor.com.","title":"I'd like to try MFractor Professional, how do I get a trial?"},{"location":"faq/#how-do-i-recover-my-mfractor-professional-license","text":"To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license.","title":"How do I recover my MFractor Professional license?"},{"location":"faq/#where-can-i-find-mfracors-release-notes","text":"MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes","title":"Where can I find MFracor's release notes?"},{"location":"faq/#does-mfractor-support-the-preview-versions-of-visual-studio","text":"No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk.","title":"Does MFractor support the Preview versions of Visual Studio?"},{"location":"faq/#mfractor-is-not-visible-in-visual-studio-macs-extension-manager","text":"MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ;","title":"MFractor is not visible in Visual Studio Macs Extension Manager."},{"location":"faq/#id-like-to-write-a-blog-about-mfractor","text":"Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding.","title":"I'd like to write a blog about MFractor."},{"location":"faq/#what-is-the-mfractor-folder","text":"The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it.","title":"What is the .mfractor folder?"},{"location":"faq/#should-i-check-mfractor-into-source-control","text":"No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default.","title":"Should I check .mfractor into source control?"},{"location":"faq/#how-do-i-uninstall-mfractor-for-visual-studio-windows-manually","text":"Locate the VSIXInstaller executable and run the following command: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE>VSIXInstaller.exe /u:9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c Our VSIX identifier is 9e8ace0e-61dd-486f-bfeb-0c7ad1fc0b1c .","title":"How do I uninstall MFractor for Visual Studio Windows manually?"},{"location":"faq/#can-you-help-me-make-a-visual-studio-extension","text":"Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call.","title":"Can you help me make a Visual Studio extension?"},{"location":"faq/#are-you-available-for-hire-to-develop-xamarin-applications","text":"Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with.","title":"Are you available for hire to develop Xamarin applications?"},{"location":"faq/#are-you-available-for-hire-to-develop-visual-studio-extension","text":"Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor.","title":"Are you available for hire to develop Visual Studio extension?"},{"location":"faq/#what-is-the-licensing-agreement","text":"Please see our End User License .","title":"What is the licensing agreement?"},{"location":"faq/#what-is-your-privacy-policy","text":"Please see our Privacy Policy .","title":"What is your privacy policy?"},{"location":"feature-matrix/","text":"This feature matrix presents all the features provided by MFractor. All features are available in MFractor for Visual Studio for Mac. The third column shows the features available to the Windows version. Asset Management Image Management Feature Lite Pro Platforms Import Image Assets Manage Image Assets Delete Image Tool Optimise Image Tools Image Tooltips Mobile.BuildTools Support ResizetizerNT Support Font Management Feature Lite Pro Platforms Import Font Generate Font Glyph Code Class Font Glyph Tooltips Font Glyph IntelliSense Font Viewer Font Text Preview Tooltips Embedded Font Tooltip Wizards Xamarin.Forms Feature Lite Pro Platforms Localization Wizard MVVM Wizard Value Converter Wizard C Feature Lite Pro Platforms Scaffolder C# Language Code Actions Feature Lite Pro Platforms Create Class From Clipboard Code Actions C# Language Code Actions Feature Lite Pro Platforms Generate Interface Implementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String Create constructor to initialize all readonly members Create Lazy Field Accessor Locate Class File In Solution Explorer Select String Span Align Namespace To Folder Path Copy Var Type To Clipboard Simplify Qualified Type Simplify All Qualified Types Invert Event Handler Assignment Xamarin Code Actions Feature Lite Pro Platforms Exclude Symbol from Linker Xamarin.Forms Code Actions Feature Lite Pro Platforms Create Bindable Property Create Attached Property Generate Custom Renderers XAML Code Actions Feature Lite Pro Platforms Extract XAML Style Extract Custom Control Generate a new View Model for XAML view Convert StackLayout to Grid Generate Resource Dictionary Generate New Value Converter for Type Flow Generate Xaml Localisation Infrastructure Encapsulate Content Page Children With StackLayout Encapsulate Content Page Children With Grid Encapsulate Content View Children With StackLayout Encapsulate Content View Children With Grid Correct Member Name Create Missing Property For Class Fixs Malformed Color Using Color Editor Replace Color Value With StaticResource Replace Hexadecimal Value With Named Color Generate Event Handler Correct Name To Matching Callback Remove Redundant Grid Properties Autocorrect Invalid FontSize Correct Property Binding Name Import Value Converter For Binding Type Flow Correct Image Resource name Import Missing Image Resource Encapsulate Scroll View Children With Grid Encapsulate Scroll View Children With StackLayout Correct Static Resource Name Apply Available Style Remove Redundant Style Property Initialisation Replace Style Setter Property With Autocorrection Add Missing Target Type Attribute Replace Thickness Value With Static Resource Simplify Thickness Value Add Trigger Target Type Fix Trigger Target Type Import Namespace And Assembly For Unresolved XAML Node Replace Node With Auto-Correction Rename Duplicate Namespace References Move Grid Properties To Parent Element Create Missing Style Consolidate Thicknesses Escape Newline Characters Auto-Correct Embedded Font Reference Xamarin.Forms Search and Navigation Feature Lite Pro Platforms Go To View Model Go To Code Behind Go To Xaml View Go To Xaml Symbol Find Custom Renderers Code Analysis XAML Code Analysis Feature Lite Pro Platforms Duplicate AutomationIds Empty AutomationId Declaration x:Name Has Invalid Characters Duplicate Code Behind Field Declarations Empty Code Behind Field Declaration ContentPage Has Multiple Direct Children ContentView Has Multiple Direct Children Class Does Not Have Attached Property Empty Value Assignment Empty Event Handler Assignment Event Handler Exists In Code Behind Class Event Handler Signature Mismatch Referenced Code Behind Field Exists Value Converter Input Type Mismatch Value Converter Output Type Mismatch Unresolved .NET Symbols Within Xaml Expression Unresolved Namespace Within Xaml Expression Invalid Named Font Size Generic Usage Is Missing x:TypeArguments x:TypeArguments Used On Non-Generic Class Unknown Type Provided To Generic Column Is Outside Grid Boundaries ColumnSpan Is Outside Grid Boundaries ColumnSpan Is Zero Grid.Column Usage Is Redundant Grid.ColumnSpan Usage Is Redundant Grid.Row Usage Is Redundant Grid.RowSpan Usage Is Redundant Row Is Outside Grid Boundaries RowSpan Is Outside Grid Boundaries RowSpan Is Zero Obsolete Property Used OnIdiom Return Type Mismatch OnPlatform Return Type Mismatch Referenced Attribute Member Exists In Parent Type Property Node Maps To Member In Parent Type Property Setter Node Misuse Property Setter Type Mismatch Duplicate Resource Dictionary Keys Resource Entry Does Not Define Key Unused Resource Missing Microsoft Schema ScrollView Has Multiple Direct Children Style Is Missing TargetType Property Setter Does Not Exist In Style TargetType Invalid Thickness Attribute Value Unknown Field Modifier Unknown Static Property Value Validate Value Types Duplicate Namespace Declaration Unresolved Xml Namespace Unresolved Xmlns Assembly Xaml Node Resolves Trigger Is Missing Target Type Trigger TargetType Does Not Match Parent Thickness Value Can Be Replaced By Static Resource Thickness Value Can Be Simplified Element Can Use Available Style Property Value Is Already Applied By Style Style TargetType Does Not Match BasedOn TargetType Ambiguous Static Resource Reference No Key Provided To Static Resource Expression StaticResource Return Type Mismatch Static Resource Style Target Type Is Incompatible x:Static Return Type Mismatch Undefined Static Resource Usage Slider Minimum Set Before Maximum Duplicate ShellItem Route Empty Shell Route Scheme Multiple VisualElements Defined In Shell Content Shell Requires At Least One Shell Item Validate Setter Attached Property Usage Setter Property Exists Style Or Trigger Has Duplicate Setters Resource Key Conflict Detect Missing Image In Linked Projects Grid Row/Column Setter Is Not A Number No Key Provided To DynamicResource Expression Validate Binding Expressions Return A Property Binding Against Non-Public Property Binding Expressions Resolve Binding Expression Return Type Mismatch Color Value Matches Static Resource Color Value Closely Matches Available Static Resource Hexadecimal Value Matches Named Color Malformed Hexadecimal Color Value Cell Usage Within CollectionView ItemTemplate Glyph Does Not Exist In Font Thickness Value Can Be Consolidated Color Value Can Be Consolidated Unescaped Newline In String Literal Unknown Embedded Font Reference Unknown OnPlatform Value RefreshView Content Should Be Scrollable Layout Intellisense XAML Intellisense Completions Feature Lite Pro Platforms x:Name Shorthand Completion x:Key Shorthand Completion Color Value Completion DataBinding Shorthand Completion DataTrigger Binding Shorthand Completion Event Handler Completion Font Asset Completion Grid Boilerplate Completion Grid Location Completion Grid Unit Completion Image Asset Completion Import Font Asset Completion Property Setter Completion RepeaterView Boilerplate Completion Row/Column Shorthand Completion Setter Shorthand Completion StackLayout Orientation Shorthand Completion Star/Auto Shorthand Completion Thickness Attribute Completion ViewModel Data Binding Completion Xaml Editor Adornments Feature Lite Pro Platforms Grid Index Adornments Color Adornments Tooltips Feature Lite Pro Platforms Grid Index Tooltips Color Format Tooltips Named FontSize Platform Values Tooltips Thickness Formats Tooltips Static Resource Tooltips Value Converter Input/Output Type Tootips Intellisense Feature Lite Pro Platforms Embedded Font Asset Completion Utilities Project and Solution Utilities Feature Lite Pro Platforms Copy Android Package ID To Clipboard Delete Output Folder Clean and Compress Edit Shared Project Items Search Categories Feature Lite Pro Platforms MFractor Commands Search ResX Localisation Search Xamarin.Forms Automation Identifiers Search Xamarin.Forms Static Resources Search Xamarin.Forms Dynamic Resources Search","title":"Feature Matrix"},{"location":"feature-matrix/#asset-management","text":"","title":"Asset Management"},{"location":"feature-matrix/#image-management","text":"Feature Lite Pro Platforms Import Image Assets Manage Image Assets Delete Image Tool Optimise Image Tools Image Tooltips Mobile.BuildTools Support ResizetizerNT Support","title":"Image Management"},{"location":"feature-matrix/#font-management","text":"Feature Lite Pro Platforms Import Font Generate Font Glyph Code Class Font Glyph Tooltips Font Glyph IntelliSense Font Viewer Font Text Preview Tooltips Embedded Font Tooltip","title":"Font Management"},{"location":"feature-matrix/#wizards","text":"","title":"Wizards"},{"location":"feature-matrix/#xamarinforms","text":"Feature Lite Pro Platforms Localization Wizard MVVM Wizard Value Converter Wizard","title":"Xamarin.Forms"},{"location":"feature-matrix/#c","text":"Feature Lite Pro Platforms Scaffolder","title":"C"},{"location":"feature-matrix/#c-language-code-actions","text":"Feature Lite Pro Platforms Create Class From Clipboard","title":"C# Language Code Actions"},{"location":"feature-matrix/#code-actions","text":"","title":"Code Actions"},{"location":"feature-matrix/#c-language-code-actions_1","text":"Feature Lite Pro Platforms Generate Interface Implementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String Create constructor to initialize all readonly members Create Lazy Field Accessor Locate Class File In Solution Explorer Select String Span Align Namespace To Folder Path Copy Var Type To Clipboard Simplify Qualified Type Simplify All Qualified Types Invert Event Handler Assignment","title":"C# Language Code Actions"},{"location":"feature-matrix/#xamarin-code-actions","text":"Feature Lite Pro Platforms Exclude Symbol from Linker","title":"Xamarin Code Actions"},{"location":"feature-matrix/#xamarinforms-code-actions","text":"Feature Lite Pro Platforms Create Bindable Property Create Attached Property Generate Custom Renderers","title":"Xamarin.Forms Code Actions"},{"location":"feature-matrix/#xaml-code-actions","text":"Feature Lite Pro Platforms Extract XAML Style Extract Custom Control Generate a new View Model for XAML view Convert StackLayout to Grid Generate Resource Dictionary Generate New Value Converter for Type Flow Generate Xaml Localisation Infrastructure Encapsulate Content Page Children With StackLayout Encapsulate Content Page Children With Grid Encapsulate Content View Children With StackLayout Encapsulate Content View Children With Grid Correct Member Name Create Missing Property For Class Fixs Malformed Color Using Color Editor Replace Color Value With StaticResource Replace Hexadecimal Value With Named Color Generate Event Handler Correct Name To Matching Callback Remove Redundant Grid Properties Autocorrect Invalid FontSize Correct Property Binding Name Import Value Converter For Binding Type Flow Correct Image Resource name Import Missing Image Resource Encapsulate Scroll View Children With Grid Encapsulate Scroll View Children With StackLayout Correct Static Resource Name Apply Available Style Remove Redundant Style Property Initialisation Replace Style Setter Property With Autocorrection Add Missing Target Type Attribute Replace Thickness Value With Static Resource Simplify Thickness Value Add Trigger Target Type Fix Trigger Target Type Import Namespace And Assembly For Unresolved XAML Node Replace Node With Auto-Correction Rename Duplicate Namespace References Move Grid Properties To Parent Element Create Missing Style Consolidate Thicknesses Escape Newline Characters Auto-Correct Embedded Font Reference","title":"XAML Code Actions"},{"location":"feature-matrix/#xamarinforms_1","text":"","title":"Xamarin.Forms"},{"location":"feature-matrix/#search-and-navigation","text":"Feature Lite Pro Platforms Go To View Model Go To Code Behind Go To Xaml View Go To Xaml Symbol Find Custom Renderers","title":"Search and Navigation"},{"location":"feature-matrix/#code-analysis","text":"","title":"Code Analysis"},{"location":"feature-matrix/#xaml-code-analysis","text":"Feature Lite Pro Platforms Duplicate AutomationIds Empty AutomationId Declaration x:Name Has Invalid Characters Duplicate Code Behind Field Declarations Empty Code Behind Field Declaration ContentPage Has Multiple Direct Children ContentView Has Multiple Direct Children Class Does Not Have Attached Property Empty Value Assignment Empty Event Handler Assignment Event Handler Exists In Code Behind Class Event Handler Signature Mismatch Referenced Code Behind Field Exists Value Converter Input Type Mismatch Value Converter Output Type Mismatch Unresolved .NET Symbols Within Xaml Expression Unresolved Namespace Within Xaml Expression Invalid Named Font Size Generic Usage Is Missing x:TypeArguments x:TypeArguments Used On Non-Generic Class Unknown Type Provided To Generic Column Is Outside Grid Boundaries ColumnSpan Is Outside Grid Boundaries ColumnSpan Is Zero Grid.Column Usage Is Redundant Grid.ColumnSpan Usage Is Redundant Grid.Row Usage Is Redundant Grid.RowSpan Usage Is Redundant Row Is Outside Grid Boundaries RowSpan Is Outside Grid Boundaries RowSpan Is Zero Obsolete Property Used OnIdiom Return Type Mismatch OnPlatform Return Type Mismatch Referenced Attribute Member Exists In Parent Type Property Node Maps To Member In Parent Type Property Setter Node Misuse Property Setter Type Mismatch Duplicate Resource Dictionary Keys Resource Entry Does Not Define Key Unused Resource Missing Microsoft Schema ScrollView Has Multiple Direct Children Style Is Missing TargetType Property Setter Does Not Exist In Style TargetType Invalid Thickness Attribute Value Unknown Field Modifier Unknown Static Property Value Validate Value Types Duplicate Namespace Declaration Unresolved Xml Namespace Unresolved Xmlns Assembly Xaml Node Resolves Trigger Is Missing Target Type Trigger TargetType Does Not Match Parent Thickness Value Can Be Replaced By Static Resource Thickness Value Can Be Simplified Element Can Use Available Style Property Value Is Already Applied By Style Style TargetType Does Not Match BasedOn TargetType Ambiguous Static Resource Reference No Key Provided To Static Resource Expression StaticResource Return Type Mismatch Static Resource Style Target Type Is Incompatible x:Static Return Type Mismatch Undefined Static Resource Usage Slider Minimum Set Before Maximum Duplicate ShellItem Route Empty Shell Route Scheme Multiple VisualElements Defined In Shell Content Shell Requires At Least One Shell Item Validate Setter Attached Property Usage Setter Property Exists Style Or Trigger Has Duplicate Setters Resource Key Conflict Detect Missing Image In Linked Projects Grid Row/Column Setter Is Not A Number No Key Provided To DynamicResource Expression Validate Binding Expressions Return A Property Binding Against Non-Public Property Binding Expressions Resolve Binding Expression Return Type Mismatch Color Value Matches Static Resource Color Value Closely Matches Available Static Resource Hexadecimal Value Matches Named Color Malformed Hexadecimal Color Value Cell Usage Within CollectionView ItemTemplate Glyph Does Not Exist In Font Thickness Value Can Be Consolidated Color Value Can Be Consolidated Unescaped Newline In String Literal Unknown Embedded Font Reference Unknown OnPlatform Value RefreshView Content Should Be Scrollable Layout","title":"XAML Code Analysis"},{"location":"feature-matrix/#intellisense","text":"","title":"Intellisense"},{"location":"feature-matrix/#xaml-intellisense-completions","text":"Feature Lite Pro Platforms x:Name Shorthand Completion x:Key Shorthand Completion Color Value Completion DataBinding Shorthand Completion DataTrigger Binding Shorthand Completion Event Handler Completion Font Asset Completion Grid Boilerplate Completion Grid Location Completion Grid Unit Completion Image Asset Completion Import Font Asset Completion Property Setter Completion RepeaterView Boilerplate Completion Row/Column Shorthand Completion Setter Shorthand Completion StackLayout Orientation Shorthand Completion Star/Auto Shorthand Completion Thickness Attribute Completion ViewModel Data Binding Completion","title":"XAML Intellisense Completions"},{"location":"feature-matrix/#xaml-editor","text":"","title":"Xaml Editor"},{"location":"feature-matrix/#adornments","text":"Feature Lite Pro Platforms Grid Index Adornments Color Adornments","title":"Adornments"},{"location":"feature-matrix/#tooltips","text":"Feature Lite Pro Platforms Grid Index Tooltips Color Format Tooltips Named FontSize Platform Values Tooltips Thickness Formats Tooltips Static Resource Tooltips Value Converter Input/Output Type Tootips","title":"Tooltips"},{"location":"feature-matrix/#intellisense_1","text":"Feature Lite Pro Platforms Embedded Font Asset Completion","title":"Intellisense"},{"location":"feature-matrix/#utilities","text":"","title":"Utilities"},{"location":"feature-matrix/#project-and-solution-utilities","text":"Feature Lite Pro Platforms Copy Android Package ID To Clipboard Delete Output Folder Clean and Compress Edit Shared Project Items","title":"Project and Solution Utilities"},{"location":"feature-matrix/#search-categories","text":"Feature Lite Pro Platforms MFractor Commands Search ResX Localisation Search Xamarin.Forms Automation Identifiers Search Xamarin.Forms Static Resources Search Xamarin.Forms Dynamic Resources Search","title":"Search Categories"},{"location":"installation-and-setup/","text":"Installing, activating and updating MFractor. Introduction This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows. Visual Studio Mac Installation (Marketplace) MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version. Uninstallation MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor. Release Note The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article. Visual Studio Windows Installation (Marketplace) MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019 Uninstallation MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor. Release Notes The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Installation And Setup"},{"location":"installation-and-setup/#introduction","text":"This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows.","title":"Introduction"},{"location":"installation-and-setup/#visual-studio-mac","text":"","title":"Visual Studio Mac"},{"location":"installation-and-setup/#installation-marketplace","text":"MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file","text":"Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation.","title":"Installation (File)"},{"location":"installation-and-setup/#activation","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades","text":"MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version.","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation","text":"MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-note","text":"The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article.","title":"Release Note"},{"location":"installation-and-setup/#visual-studio-windows","text":"","title":"Visual Studio Windows"},{"location":"installation-and-setup/#installation-marketplace_1","text":"MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file_1","text":"Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows.","title":"Installation (File)"},{"location":"installation-and-setup/#activation_1","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license_1","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades_1","text":"Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation_1","text":"MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-notes","text":"The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Release Notes"},{"location":"licensing/","text":"Information about MFractor's licensing and terms of use Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows. End User License Please find our End User License here. Privacy policy Please find our Private Policy here.","title":"Licensing"},{"location":"licensing/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"licensing/#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"MFractor Professional"},{"location":"licensing/#mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows.","title":"MFractor Lite"},{"location":"licensing/#end-user-license","text":"Please find our End User License here.","title":"End User License"},{"location":"licensing/#privacy-policy","text":"Please find our Private Policy here.","title":"Privacy policy"},{"location":"quickstart-mac/","text":"Getting started with MFractor for Visual Studio Mac Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Mac documentation. Main Menu Overview When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Mac"},{"location":"quickstart-mac/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-mac/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Mac documentation.","title":"Setup And Maintenance"},{"location":"quickstart-mac/#main-menu-overview","text":"When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-mac/#feature-overview","text":"MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-mac/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-mac/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-mac/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-mac/#formatting","text":"","title":"Formatting"},{"location":"quickstart-windows/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Windows documentation. Main Menu Overview When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Windows"},{"location":"quickstart-windows/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-windows/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Windows documentation.","title":"Setup And Maintenance"},{"location":"quickstart-windows/#main-menu-overview","text":"When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-windows/#feature-overview","text":"MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-windows/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-windows/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-windows/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-windows/#formatting","text":"","title":"Formatting"},{"location":"resharper-compatibility/","text":"Using MFractor alongside ReSharper Introduction ReSharper is a very popular productivity extension for Visual Studio and it is important that MFractor works smoothly along side it. This guide covers how to enable MFractor to work alongside ReSharper. Enabling MFractor with ReSharper In a default ReSharper installation, MFractor's code actions will not appear in ReSharpers light-bulb menu. To ensure ReSharper merges in our code actions, first go to the top Extensions menu, then ReSharper -> Options . In the options window, go to Editor -> Visual Studio Features and then check Merge Visual Studio light bulb actions into ReSharper action indicator. In ReSharper Ultimate, go to Code Inspection -> Settings -> Merge Visual Studio light bulb actions into ReSharper action indicator","title":"ReSharper Compatibility"},{"location":"resharper-compatibility/#introduction","text":"ReSharper is a very popular productivity extension for Visual Studio and it is important that MFractor works smoothly along side it. This guide covers how to enable MFractor to work alongside ReSharper.","title":"Introduction"},{"location":"resharper-compatibility/#enabling-mfractor-with-resharper","text":"In a default ReSharper installation, MFractor's code actions will not appear in ReSharpers light-bulb menu. To ensure ReSharper merges in our code actions, first go to the top Extensions menu, then ReSharper -> Options . In the options window, go to Editor -> Visual Studio Features and then check Merge Visual Studio light bulb actions into ReSharper action indicator. In ReSharper Ultimate, go to Code Inspection -> Settings -> Merge Visual Studio light bulb actions into ReSharper action indicator","title":"Enabling MFractor with ReSharper"},{"location":"support/","text":"How to get support or report issues for MFractor Reporting a Bug We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE. Visual Studio Mac To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log . Visual Studio Windows To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback . Support Channels In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support"},{"location":"support/#reporting-a-bug","text":"We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE.","title":"Reporting a Bug"},{"location":"support/#visual-studio-mac","text":"To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log .","title":"Visual Studio Mac"},{"location":"support/#visual-studio-windows","text":"To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback .","title":"Visual Studio Windows"},{"location":"support/#support-channels","text":"In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support Channels"},{"location":"analysis/disabling-analysers/","text":"How to disable unwanted code analysers Introduction Disabling A Code Analyser","title":"Disabling analysers"},{"location":"analysis/disabling-analysers/#introduction","text":"","title":"Introduction"},{"location":"analysis/disabling-analysers/#disabling-a-code-analyser","text":"","title":"Disabling A Code Analyser"},{"location":"analysis/overview/","text":"Detect errors, improvements and maintainability suggestions with Introduction","title":"Overview"},{"location":"analysis/overview/#introduction","text":"","title":"Introduction"},{"location":"analysis/solution-analysis/","text":"Scan your mobile solution for a wide range of errors, improvements and maintainability suggestions","title":"Solution analysis"},{"location":"configuration/overview/","text":"**","title":"Overview"},{"location":"csharp/create-class-from-clipboard/","text":"Generate a new class using the contents of the clipboard This feature is available in MFractor Professional Introduction When working as developers, we often need to add a class copied into the clipboard into our code base. This classes contents could come from a wide range of sources but some common ones are: An answer from StackOverflow. Some code from on Github or CodeProject. Code from an online code-generation tool like QuickType or IconFont2Code . Another one of our code bases. Let's consider a common example, that we are using a class from an answer on StackOverflow. You discover an answer with a class that solves your problem and now you would like add it to your project. To add the class to your code base, you would do something like so: Copy the code to the clipboard. Open your project and create a new file. Paste the class into the new file. Ensure the file name to match the class name. Cleanup the namespace to match the folder path. This involves a lot of steps and a lot of manual cleanup work, making it error prone and tedius. To simplify this process, MFractor includes the Add Class Using Clipboard tool to make this easier. This tool is very useful when copying code from Github, StackOverflow or other code bases. (Be honest, we all do it). We can use Add Class Using Clipboard to create a new class using the clipboards content; it will automatically detect the file name based on the clipboards class and also correct or create the namespace based on project and folder you are creating it from. Creating A Class From Clipboard The Create Class From Clipboard tool does not currently support shared projects To use the Create Class From Clipboard tool, copy a valid C# class (with or without it's namespace and usings) to the clipboard. Next, right click on a project or project folder and beneath the Add menu, choose the Add Class Using Clipboard A window will now appear that previews the code that will be created. In this window we can change the following: Name: The name of the class. By default this is the name of the first class found in the clipboard Folder: The folder path where the new file will be placed. This will also control the namespace of the new class. When the Create Class From Clipboard window is launched, MFractor will automatically perform the following: Inspect the clipboards contents and use the name of the first class found as the file name. If no namespaces are declared, MFractor will wrap the class in a namespace based on the projects default namespace and the folder path the file is being placed into. If a namespace is defined, MFractor will correct it to use the project and folder path.","title":"Create Class From Clipboard"},{"location":"csharp/create-class-from-clipboard/#introduction","text":"When working as developers, we often need to add a class copied into the clipboard into our code base. This classes contents could come from a wide range of sources but some common ones are: An answer from StackOverflow. Some code from on Github or CodeProject. Code from an online code-generation tool like QuickType or IconFont2Code . Another one of our code bases. Let's consider a common example, that we are using a class from an answer on StackOverflow. You discover an answer with a class that solves your problem and now you would like add it to your project. To add the class to your code base, you would do something like so: Copy the code to the clipboard. Open your project and create a new file. Paste the class into the new file. Ensure the file name to match the class name. Cleanup the namespace to match the folder path. This involves a lot of steps and a lot of manual cleanup work, making it error prone and tedius. To simplify this process, MFractor includes the Add Class Using Clipboard tool to make this easier. This tool is very useful when copying code from Github, StackOverflow or other code bases. (Be honest, we all do it). We can use Add Class Using Clipboard to create a new class using the clipboards content; it will automatically detect the file name based on the clipboards class and also correct or create the namespace based on project and folder you are creating it from.","title":"Introduction"},{"location":"csharp/create-class-from-clipboard/#creating-a-class-from-clipboard","text":"The Create Class From Clipboard tool does not currently support shared projects To use the Create Class From Clipboard tool, copy a valid C# class (with or without it's namespace and usings) to the clipboard. Next, right click on a project or project folder and beneath the Add menu, choose the Add Class Using Clipboard A window will now appear that previews the code that will be created. In this window we can change the following: Name: The name of the class. By default this is the name of the first class found in the clipboard Folder: The folder path where the new file will be placed. This will also control the namespace of the new class. When the Create Class From Clipboard window is launched, MFractor will automatically perform the following: Inspect the clipboards contents and use the name of the first class found as the file name. If no namespaces are declared, MFractor will wrap the class in a namespace based on the projects default namespace and the folder path the file is being placed into. If a namespace is defined, MFractor will correct it to use the project and folder path.","title":"Creating A Class From Clipboard"},{"location":"csharp/localisation/","text":"","title":"Localisation"},{"location":"csharp/code-actions/convert-to-interpolated-string/","text":"Quickly convert a string literal to a interpolated string This feature is available in MFractor Professional Introduction When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string. Using Convert To Interpolated String To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Convert To Interpolated String"},{"location":"csharp/code-actions/convert-to-interpolated-string/#introduction","text":"When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string.","title":"Introduction"},{"location":"csharp/code-actions/convert-to-interpolated-string/#using-convert-to-interpolated-string","text":"To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Using Convert To Interpolated String"},{"location":"csharp/code-actions/create-lazy-field-property/","text":"Create a property to access the inner value of a Lazy<> field This feature is available in MFractor Professional Introduction In .NET, the System.Lazy<T> class can be used to provide lazy initialisation . That is, System.Lazy<T> defers the creation cost of something until the first time it's used. Please refer to the System.Lazy documentation for more in-depth documentation. Each time we use Lazy<T> , we use the .Value property to retrieve the underlying object. When the Lazy<T> is a field, it's common to create a property that accesses the value. For example: readonly Lazy<IIconService> iconService; public IIconService IconService => iconService.Value; We would then use IIconService like so: IconService.MyMethod(); // Equates to iconService.Value.MyMethod(). Accessor properties for lazy fields cleanup our code, making it easier to maintain and read as each time we use IIconService we . However, we now need to create a property each time we use a lazy field to ensure our code remains clean. To simplify this, MFractor includes the Create Lazy Field Property code action to generate this code for us. Using Create Lazy Field Property To use the code action, locate then name of a field whose type is Lazy<T> and press Alt+Return or right click and choose Quick Fix on the name. In the context menu that opens, choose Create a property that access this lazy fields value : After confirming the code action, MFractor will generate a property to access the fields value:","title":"Create Lazy Field Property"},{"location":"csharp/code-actions/create-lazy-field-property/#introduction","text":"In .NET, the System.Lazy<T> class can be used to provide lazy initialisation . That is, System.Lazy<T> defers the creation cost of something until the first time it's used. Please refer to the System.Lazy documentation for more in-depth documentation. Each time we use Lazy<T> , we use the .Value property to retrieve the underlying object. When the Lazy<T> is a field, it's common to create a property that accesses the value. For example: readonly Lazy<IIconService> iconService; public IIconService IconService => iconService.Value; We would then use IIconService like so: IconService.MyMethod(); // Equates to iconService.Value.MyMethod(). Accessor properties for lazy fields cleanup our code, making it easier to maintain and read as each time we use IIconService we . However, we now need to create a property each time we use a lazy field to ensure our code remains clean. To simplify this, MFractor includes the Create Lazy Field Property code action to generate this code for us.","title":"Introduction"},{"location":"csharp/code-actions/create-lazy-field-property/#using-create-lazy-field-property","text":"To use the code action, locate then name of a field whose type is Lazy<T> and press Alt+Return or right click and choose Quick Fix on the name. In the context menu that opens, choose Create a property that access this lazy fields value : After confirming the code action, MFractor will generate a property to access the fields value:","title":"Using Create Lazy Field Property"},{"location":"csharp/code-actions/generate-interface-implementation/","text":"Quickly generate a class stub implementation for an interface This feature is available in MFractor Professional Introduction The Generate Implementation for Interface code action allows you to quickly generate a class implementing stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation. Using the Code Action This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. For this code action, it can be invoked from the interface declaration file when the cusor is over the interface name or it's body, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the Intellisense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened on the code editor.","title":"Generate Interface Implementation"},{"location":"csharp/code-actions/generate-interface-implementation/#introduction","text":"The Generate Implementation for Interface code action allows you to quickly generate a class implementing stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation.","title":"Introduction"},{"location":"csharp/code-actions/generate-interface-implementation/#using-the-code-action","text":"This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. For this code action, it can be invoked from the interface declaration file when the cusor is over the interface name or it's body, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the Intellisense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened on the code editor.","title":"Using the Code Action"},{"location":"csharp/code-actions/generate-readonly-constructor/","text":"","title":"Generate readonly constructor"},{"location":"csharp/code-actions/locate-in-solution-explorer/","text":"Locate the project file in the solution pad for a given type declaration This feature is available in MFractor Professional Introduction When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration. Using Locate In Solution Explorer To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Locate In Solution Explorer"},{"location":"csharp/code-actions/locate-in-solution-explorer/#introduction","text":"When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration.","title":"Introduction"},{"location":"csharp/code-actions/locate-in-solution-explorer/#using-locate-in-solution-explorer","text":"To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Using Locate In Solution Explorer"},{"location":"csharp/code-actions/simplify-qualified-types/","text":"Generate a new using statement from a qualified type usage This feature is available in MFractor Professional Introduction In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System.IO.FileInfo fileInfo; // Qualified type is 'System.IO.FileInfo' var myTask = System.Threading.Tasks.Task.Run(); // Qualified type is 'System.Threading.Tasks.Task' To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System . IO ; using System . Threading . Tasks ; FileInfo fileInfo ; var myTask = Task . Run (); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings. Using the Code Action To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name: The Simplify Types Wizard In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"Simplifying Qualified Types"},{"location":"csharp/code-actions/simplify-qualified-types/#introduction","text":"In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System.IO.FileInfo fileInfo; // Qualified type is 'System.IO.FileInfo' var myTask = System.Threading.Tasks.Task.Run(); // Qualified type is 'System.Threading.Tasks.Task' To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System . IO ; using System . Threading . Tasks ; FileInfo fileInfo ; var myTask = Task . Run (); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings.","title":"Introduction"},{"location":"csharp/code-actions/simplify-qualified-types/#using-the-code-action","text":"To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name:","title":"Using the Code Action"},{"location":"csharp/code-actions/simplify-qualified-types/#the-simplify-types-wizard","text":"In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"The Simplify Types Wizard"},{"location":"fonts/fontfamily-xaml-entry/","text":"Inject the Font Family XAML entry for a font asset the Resource Dictionary of a Xamarin.Forms App Introduction Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: <ResourceDictionary> <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"OpenSans\" > <On Platform= \"iOS\" Value= \"OpenSans\" /> <On Platform= \"Android\" Value= \"OpenSans-Regular.ttf#Regular\" /> </OnPlatform> <!-- Other dictionary resources --> </ResourceDictionary> The Font Importer can add this to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customise the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.CustomFontPage\" > <StackLayout VerticalOptions= \"Center\" > <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> </StackLayout> </ContentPage> References Fonts in Xamarin.Forms","title":"FontFamily XAML Entry"},{"location":"fonts/fontfamily-xaml-entry/#introduction","text":"Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: <ResourceDictionary> <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"OpenSans\" > <On Platform= \"iOS\" Value= \"OpenSans\" /> <On Platform= \"Android\" Value= \"OpenSans-Regular.ttf#Regular\" /> </OnPlatform> <!-- Other dictionary resources --> </ResourceDictionary> The Font Importer can add this to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customise the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.CustomFontPage\" > <StackLayout VerticalOptions= \"Center\" > <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> </StackLayout> </ContentPage>","title":"Introduction"},{"location":"fonts/fontfamily-xaml-entry/#references","text":"Fonts in Xamarin.Forms","title":"References"},{"location":"fonts/generate-font-character-code-class/","text":"Create a helper class that includes named constants for all character codes in a font asset This feature is available in MFractor Professional Introduction When building mobile apps, we can use font glyphs instead of image assets for icons to simplify our codebase and make it more maintainable. There are several major benefits when using fonts for our iconography: Our app size becomes smaller by reducing the amount of image assetsin our app. Font icons are rendered vectors. You can be recolour and resize them in code. No need to wrangle many different image asset densities in your Android and iOS projects. However, a drawback of this approach is we need to refer to font glyphs by their unicode character like so: label.Text = \"/uf00c\"; This impacts code readability as it becomes difficult to understand what icon the code /uf00c translates to visually. To address this issue Android improve readability, it's best practice to use a helper class that contains a named constant for each glyph in the font. For example: FontAwesomeIcons.cs public class FontAwesomeIcons { // ... public const string Check = \"\\uf00c\" ; public const string CheckCircle = \"\\uf058\" ; public const string CheckDouble = \"\\uf560\" ; public const string CheckSquare = \"\\uf14a\" ; // ... } We can now use this class to reference a named constant when setting icons: label.Text = FontAwesome.FontAwesomeIcons.Check; It is now obvious that the icon is a check from FontAwesome, making the code cleaner, more readable and more maintainable. To help improve your code-bases readability by using a helper class for font icons, MFractor contains a Generate Font Glyph Code Class tool. Using the Generate Font Glyph Code Class tool Desktop Fonts vs Web Fonts When generating a glyph class, MFractor requires that the font asset be a Web Font . Typically, desktop font assets do not include the glyph names associated with a unicode characters whereas web fonts include these names to allow referencing by name via CSS. If the Generate Font Glyph Code Code tool does not generate a class, verify that the font asset is a web font. To use the Generate Font Glyph Code Class tool, locate a font asset (otf or ttf) in your solution, right click on it and choose Generate Font Glyph Glyph Class tool : MFractor will present a preview of the code it will generating and allow you to select the target project and change the class name. To generate the class, press Generate :","title":"Generate Font Glyph Code Class"},{"location":"fonts/generate-font-character-code-class/#introduction","text":"When building mobile apps, we can use font glyphs instead of image assets for icons to simplify our codebase and make it more maintainable. There are several major benefits when using fonts for our iconography: Our app size becomes smaller by reducing the amount of image assetsin our app. Font icons are rendered vectors. You can be recolour and resize them in code. No need to wrangle many different image asset densities in your Android and iOS projects. However, a drawback of this approach is we need to refer to font glyphs by their unicode character like so: label.Text = \"/uf00c\"; This impacts code readability as it becomes difficult to understand what icon the code /uf00c translates to visually. To address this issue Android improve readability, it's best practice to use a helper class that contains a named constant for each glyph in the font. For example: FontAwesomeIcons.cs public class FontAwesomeIcons { // ... public const string Check = \"\\uf00c\" ; public const string CheckCircle = \"\\uf058\" ; public const string CheckDouble = \"\\uf560\" ; public const string CheckSquare = \"\\uf14a\" ; // ... } We can now use this class to reference a named constant when setting icons: label.Text = FontAwesome.FontAwesomeIcons.Check; It is now obvious that the icon is a check from FontAwesome, making the code cleaner, more readable and more maintainable. To help improve your code-bases readability by using a helper class for font icons, MFractor contains a Generate Font Glyph Code Class tool.","title":"Introduction"},{"location":"fonts/generate-font-character-code-class/#using-the-generate-font-glyph-code-class-tool","text":"Desktop Fonts vs Web Fonts When generating a glyph class, MFractor requires that the font asset be a Web Font . Typically, desktop font assets do not include the glyph names associated with a unicode characters whereas web fonts include these names to allow referencing by name via CSS. If the Generate Font Glyph Code Code tool does not generate a class, verify that the font asset is a web font. To use the Generate Font Glyph Code Class tool, locate a font asset (otf or ttf) in your solution, right click on it and choose Generate Font Glyph Glyph Class tool : MFractor will present a preview of the code it will generating and allow you to select the target project and change the class name. To generate the class, press Generate :","title":"Using the Generate Font Glyph Code Class tool"},{"location":"fonts/importing-fonts/","text":"Add new assets into your Android and iOS applications This feature is available in MFractor Professional Introduction The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way. Using the Font Importer The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Importing Fonts"},{"location":"fonts/importing-fonts/#introduction","text":"The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way.","title":"Introduction"},{"location":"fonts/importing-fonts/#using-the-font-importer","text":"The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Using the Font Importer"},{"location":"fonts/uiappfonts-plist-entry/","text":"Inject the UIAppFonts entry for a font asset into the info.plist Introduction When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: <key> UIAppFonts </key> <array> <string> OpenSans-Regular.ttf </string> </array> You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button . Example of using custom font in UIKit","title":"UIAppFonts Entry"},{"location":"fonts/uiappfonts-plist-entry/#introduction","text":"When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: <key> UIAppFonts </key> <array> <string> OpenSans-Regular.ttf </string> </array> You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button .","title":"Introduction"},{"location":"fonts/uiappfonts-plist-entry/#example-of-using-custom-font-in-uikit","text":"","title":"Example of using custom font in UIKit"},{"location":"image-management/deleting-image-assets/","text":"Remove all traces of image assets from your Android and iOS projects Introduction The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Identifying Image Assets Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view. Android When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable/logo.xml drawable-ldpi/logo.png drawable-mdpi/logo.png drawable-hdpi/logo.png drawable-night-mdpi/logo.png (dark mode version) drawable-landscape-hdpi/logo.png (landscape version ) mipmap-de-ldpi/logo.png (Deutsch translation) mipmap-ldpi/logo.png mipmap-mdpi/logo.png mipmap-hdpi/logo1.png MFractor would delete the following assets: drawable-ldpi/logo.png drawable-night-mdpi/logo.png drawable-landscape-hdpi/logo.png mipmap-de-ldpi/logo.png mipmap-ldpi/logo.png mipmap-mdpi/logo.png MFractor would ignore the following assets: drawable/logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/logo1.png (Excluded as logo1 is not a match with logo). iOS The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog. Deleting stand-alone images MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png Resources / logo1 @2 x . png Resources / logo2 @3 x . png The deletion tool will track and delete the following files as the image set of the logo asset: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png MFractor will ignore the following files: Resources / logo1 @2 x . png ( Excluded as logo1 is not a match with logo ) Resources / logo2 @3 x . png ( Excluded as logo2 is not a match with logo ) Deleting images from Asset Catalogs For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / other . png Assets . xcassets / logo . imageset / other @2 x . png Assets . xcassets / logo . imageset / Contents . json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { \"images\" : [ { \"filename\" : \"logo.png\" , \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@2x.png\" , \"scale\" : \"2x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@3x.png\" , \"scale\" : \"3x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample@3x.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"3x\" , \"idiom\" : \"universal\" } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / Contents . json ( metadata file is also deleted because its part of the asset definition ) MFractor will ignore the following files: Assets . xcassets / logo . imageset / other . png ( Not listed in the Contents . json file ) Assets . xcassets / logo . imageset / other @2 x . png ( Not listed in the Contents . json file ) Launching The Deletion Tool Solution Explorer The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option. Image Asset Manager The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane. Using The Deletion Tool After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Deleting Image Assets"},{"location":"image-management/deleting-image-assets/#introduction","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently.","title":"Introduction"},{"location":"image-management/deleting-image-assets/#identifying-image-assets","text":"Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view.","title":"Identifying Image Assets"},{"location":"image-management/deleting-image-assets/#android","text":"When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable/logo.xml drawable-ldpi/logo.png drawable-mdpi/logo.png drawable-hdpi/logo.png drawable-night-mdpi/logo.png (dark mode version) drawable-landscape-hdpi/logo.png (landscape version ) mipmap-de-ldpi/logo.png (Deutsch translation) mipmap-ldpi/logo.png mipmap-mdpi/logo.png mipmap-hdpi/logo1.png MFractor would delete the following assets: drawable-ldpi/logo.png drawable-night-mdpi/logo.png drawable-landscape-hdpi/logo.png mipmap-de-ldpi/logo.png mipmap-ldpi/logo.png mipmap-mdpi/logo.png MFractor would ignore the following assets: drawable/logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/logo1.png (Excluded as logo1 is not a match with logo).","title":"Android"},{"location":"image-management/deleting-image-assets/#ios","text":"The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog.","title":"iOS"},{"location":"image-management/deleting-image-assets/#deleting-stand-alone-images","text":"MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png Resources / logo1 @2 x . png Resources / logo2 @3 x . png The deletion tool will track and delete the following files as the image set of the logo asset: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png MFractor will ignore the following files: Resources / logo1 @2 x . png ( Excluded as logo1 is not a match with logo ) Resources / logo2 @3 x . png ( Excluded as logo2 is not a match with logo )","title":"Deleting stand-alone images"},{"location":"image-management/deleting-image-assets/#deleting-images-from-asset-catalogs","text":"For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / other . png Assets . xcassets / logo . imageset / other @2 x . png Assets . xcassets / logo . imageset / Contents . json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { \"images\" : [ { \"filename\" : \"logo.png\" , \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@2x.png\" , \"scale\" : \"2x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"logo@3x.png\" , \"scale\" : \"3x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"1x\" , \"idiom\" : \"universal\" }, { \"filename\" : \"sample@3x.png\" , \"appearances\" : [ { \"appearance\" : \"luminosity\" , \"value\" : \"dark\" } ], \"scale\" : \"3x\" , \"idiom\" : \"universal\" } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / Contents . json ( metadata file is also deleted because its part of the asset definition ) MFractor will ignore the following files: Assets . xcassets / logo . imageset / other . png ( Not listed in the Contents . json file ) Assets . xcassets / logo . imageset / other @2 x . png ( Not listed in the Contents . json file )","title":"Deleting images from Asset Catalogs"},{"location":"image-management/deleting-image-assets/#launching-the-deletion-tool","text":"","title":"Launching The Deletion Tool"},{"location":"image-management/deleting-image-assets/#solution-explorer","text":"The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option.","title":"Solution Explorer"},{"location":"image-management/deleting-image-assets/#image-asset-manager","text":"The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane.","title":"Image Asset Manager"},{"location":"image-management/deleting-image-assets/#using-the-deletion-tool","text":"After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Using The Deletion Tool"},{"location":"image-management/image-importer/","text":"Add new image assets into your Android and iOS applications Introduction The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets. Using the Image Importer The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next. Target Projects MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images. Setting the Image Size The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image. Import Image When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Importing Images"},{"location":"image-management/image-importer/#introduction","text":"The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets.","title":"Introduction"},{"location":"image-management/image-importer/#using-the-image-importer","text":"The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next.","title":"Using the Image Importer"},{"location":"image-management/image-importer/#target-projects","text":"MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images.","title":"Target Projects"},{"location":"image-management/image-importer/#setting-the-image-size","text":"The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image.","title":"Setting the Image Size"},{"location":"image-management/image-importer/#import-image","text":"When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Import Image"},{"location":"image-management/image-tooltips/","text":"Visualise the image asset a piece of code is referencing Introduction The Image Tooltips let you preview any image asset. Using Image Tooltips Simply hover your cursor over an image name and a preview of that image will display. We even offer previews of image assets in IntelliSense! XAML Add your Image tag to your xaml file and edit the Source attribute to see the tooltip, or \"Import an image asset\". <Image Source=\"\" /> Android var dd = Resource . Drawable . mfractor C# Links See the announcement in the Blog ( GitHub ).","title":"Image Tooltips"},{"location":"image-management/image-tooltips/#introduction","text":"The Image Tooltips let you preview any image asset.","title":"Introduction"},{"location":"image-management/image-tooltips/#using-image-tooltips","text":"Simply hover your cursor over an image name and a preview of that image will display. We even offer previews of image assets in IntelliSense!","title":"Using Image Tooltips"},{"location":"image-management/image-tooltips/#xaml","text":"Add your Image tag to your xaml file and edit the Source attribute to see the tooltip, or \"Import an image asset\". <Image Source=\"\" />","title":"XAML"},{"location":"image-management/image-tooltips/#android","text":"var dd = Resource . Drawable . mfractor","title":"Android"},{"location":"image-management/image-tooltips/#c","text":"","title":"C#"},{"location":"image-management/image-tooltips/#links","text":"See the announcement in the Blog ( GitHub ).","title":"Links"},{"location":"image-management/managing-image-assets/","text":"A centralised location to easily manage the image assets in your mobile solution Introduction The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Opening The Image Manager The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden: Top Menu By acessing the top menu selecting the Manage Image Assets options. Solution Pad You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list. Overview What is an image asset? MFractor works with the concept of Image Assets , where a single asset is composed by a set of files that represent a single image at each possible density supported by Android or iOS devices. This concept is implemented to facilitate managing those assets, because a single item may be represented by a large number of individual files, that can also be shared among projects. For this documentation, every time we use the term Image Asset , we are refering the set of images that form a single element as consumed by the user interface engines of the platforms, and we will use the term Asset File to refer to a specific item of this set. The Image Manager Pad is composed of the following parts: The Assets List : the main listing on the left side of the pane contains all the image assets identified by MFractor in the current solution. The list consider an asset a set of images that compose a single image as recognized by an Android or iOS project. The List of Assets File : when you select an asset from the previous list, MFractor will list the files that compose this asset in this section. Further grouping is provided by project on the Combo Box on the top of this list, where you can select the project of which you want list the files of the asset. The list provides the image size aside with it's path in the solution. The Preview Area : just above the listing of asset files on the Asset, you'll find the preview of the currently selected file along with some metadata of the image: it's current file size and dimensions. The Commands Area : you'll find buttons for the commands available to the image assets on the bottom area of the assets listing. Filtering Image assets You can filter image assets using the search bar on the top of the listing. Start typing and MFractor will filter the items that contains the text you've typed. Note The filtering tool is case-sensitive. Importing Image Assets Click on the Import New Image Asset on the bottom part of the pad to open the Import Image Asset tool. See the section docs for instructions on how to import images. Deleting Image Assets You can delete an Image Asset by selecting the image on the assets list and clicking on the Delete image name on the bottom of the listing. This will present the Delete Image Asset tool dialog, that previews the delete operations that will be run for that asset. You can also right click on a asset of the list and select Delete from the context menu. Click Delete Images button to confirm the operation. Tip For further information about the MFractor Delete Image Asset tool see the docs of the feature . Optimising Image Assets Through the Image Asset Manager you can optimise the all images of your solution, a single Image Asset or a specific Asset File. Please check the Optimising Image Assets docs for details on how to setup image optimization and launch it for the desired items of your solution. Searching For Image Asset Usages The Image Asset Manager allows you to search for places where an Image Asset is referenced in your solutions code. Warning This feature is currently in preview and will search for the exact name of the asset. This may not detect all usages of this image resource and may detect false positives. To Invoke the Search Usage feature you should use the context menu over the Image Asset you want to do the search and select the Find Usages option. MFractor will present the results on the Search Results Pane on the bottom area of the IDE. Drag And Drop The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ; Context Actions In both the Image Assets list and the Asset Files list, you may right click on any item to launch a context menu that may provide the following options: Delete Please see Deleting Image Assets Reveal In Finder/Explorer The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image. Reveal In Project Pad The Reveal Project Pad action will locate the image file in the solution pad. Copy Name To Clipboard The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard. Copy File Path To Clipboard The Copy File Path To Clipboard action copies the file path of that image file to the clipboard. Optimise Please see Optimising Image Assets Open Image The Open action opens the selected image file in the operating systems default image viewer. Search For Usages Please see Searching For Image Asset Usages","title":"Managing Images Assets"},{"location":"image-management/managing-image-assets/#introduction","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location.","title":"Introduction"},{"location":"image-management/managing-image-assets/#opening-the-image-manager","text":"The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden:","title":"Opening The Image Manager"},{"location":"image-management/managing-image-assets/#top-menu","text":"By acessing the top menu selecting the Manage Image Assets options.","title":"Top Menu"},{"location":"image-management/managing-image-assets/#solution-pad","text":"You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list.","title":"Solution Pad"},{"location":"image-management/managing-image-assets/#overview","text":"What is an image asset? MFractor works with the concept of Image Assets , where a single asset is composed by a set of files that represent a single image at each possible density supported by Android or iOS devices. This concept is implemented to facilitate managing those assets, because a single item may be represented by a large number of individual files, that can also be shared among projects. For this documentation, every time we use the term Image Asset , we are refering the set of images that form a single element as consumed by the user interface engines of the platforms, and we will use the term Asset File to refer to a specific item of this set. The Image Manager Pad is composed of the following parts: The Assets List : the main listing on the left side of the pane contains all the image assets identified by MFractor in the current solution. The list consider an asset a set of images that compose a single image as recognized by an Android or iOS project. The List of Assets File : when you select an asset from the previous list, MFractor will list the files that compose this asset in this section. Further grouping is provided by project on the Combo Box on the top of this list, where you can select the project of which you want list the files of the asset. The list provides the image size aside with it's path in the solution. The Preview Area : just above the listing of asset files on the Asset, you'll find the preview of the currently selected file along with some metadata of the image: it's current file size and dimensions. The Commands Area : you'll find buttons for the commands available to the image assets on the bottom area of the assets listing.","title":"Overview"},{"location":"image-management/managing-image-assets/#filtering-image-assets","text":"You can filter image assets using the search bar on the top of the listing. Start typing and MFractor will filter the items that contains the text you've typed. Note The filtering tool is case-sensitive.","title":"Filtering Image assets"},{"location":"image-management/managing-image-assets/#importing-image-assets","text":"Click on the Import New Image Asset on the bottom part of the pad to open the Import Image Asset tool. See the section docs for instructions on how to import images.","title":"Importing Image Assets"},{"location":"image-management/managing-image-assets/#deleting-image-assets","text":"You can delete an Image Asset by selecting the image on the assets list and clicking on the Delete image name on the bottom of the listing. This will present the Delete Image Asset tool dialog, that previews the delete operations that will be run for that asset. You can also right click on a asset of the list and select Delete from the context menu. Click Delete Images button to confirm the operation. Tip For further information about the MFractor Delete Image Asset tool see the docs of the feature .","title":"Deleting Image Assets"},{"location":"image-management/managing-image-assets/#optimising-image-assets","text":"Through the Image Asset Manager you can optimise the all images of your solution, a single Image Asset or a specific Asset File. Please check the Optimising Image Assets docs for details on how to setup image optimization and launch it for the desired items of your solution.","title":"Optimising Image Assets"},{"location":"image-management/managing-image-assets/#searching-for-image-asset-usages","text":"The Image Asset Manager allows you to search for places where an Image Asset is referenced in your solutions code. Warning This feature is currently in preview and will search for the exact name of the asset. This may not detect all usages of this image resource and may detect false positives. To Invoke the Search Usage feature you should use the context menu over the Image Asset you want to do the search and select the Find Usages option. MFractor will present the results on the Search Results Pane on the bottom area of the IDE.","title":"Searching For Image Asset Usages"},{"location":"image-management/managing-image-assets/#drag-and-drop","text":"The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ;","title":"Drag And Drop"},{"location":"image-management/managing-image-assets/#context-actions","text":"In both the Image Assets list and the Asset Files list, you may right click on any item to launch a context menu that may provide the following options:","title":"Context Actions"},{"location":"image-management/managing-image-assets/#delete","text":"Please see Deleting Image Assets","title":"Delete"},{"location":"image-management/managing-image-assets/#reveal-in-finderexplorer","text":"The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image.","title":"Reveal In Finder/Explorer"},{"location":"image-management/managing-image-assets/#reveal-in-project-pad","text":"The Reveal Project Pad action will locate the image file in the solution pad.","title":"Reveal In Project Pad"},{"location":"image-management/managing-image-assets/#copy-name-to-clipboard","text":"The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard.","title":"Copy Name To Clipboard"},{"location":"image-management/managing-image-assets/#copy-file-path-to-clipboard","text":"The Copy File Path To Clipboard action copies the file path of that image file to the clipboard.","title":"Copy File Path To Clipboard"},{"location":"image-management/managing-image-assets/#optimise","text":"Please see Optimising Image Assets","title":"Optimise"},{"location":"image-management/managing-image-assets/#open-image","text":"The Open action opens the selected image file in the operating systems default image viewer.","title":"Open Image"},{"location":"image-management/managing-image-assets/#search-for-usages","text":"Please see Searching For Image Asset Usages","title":"Search For Usages"},{"location":"image-management/optimising-image-assets/","text":"Reducing the size your image assets using the image optimiser Introduction MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries. Configuring TinyPNG API Key MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key. Launching The Optimiser The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution. To optimise a single image file Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise To optimise all files of an asset Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise To optimise all images To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user. Processing the files Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Optimising Image Assets"},{"location":"image-management/optimising-image-assets/#introduction","text":"MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries.","title":"Introduction"},{"location":"image-management/optimising-image-assets/#configuring-tinypng-api-key","text":"MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key.","title":"Configuring TinyPNG API Key"},{"location":"image-management/optimising-image-assets/#launching-the-optimiser","text":"The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution.","title":"Launching The Optimiser"},{"location":"image-management/optimising-image-assets/#to-optimise-a-single-image-file","text":"Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise","title":"To optimise a single image file"},{"location":"image-management/optimising-image-assets/#to-optimise-all-files-of-an-asset","text":"Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise","title":"To optimise all files of an asset"},{"location":"image-management/optimising-image-assets/#to-optimise-all-images","text":"To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user.","title":"To optimise all images"},{"location":"image-management/optimising-image-assets/#processing-the-files","text":"Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Processing the files"},{"location":"image-management/overview/","text":"Use MFractors image management suite to import, delete, optimise and manage the image assets in your iOS and Android apps Image Management Tool Suite Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features: Image Asset Manager The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets . Image Importer The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets . Image Deletion Tool The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets . Image Optimiser The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets . Image Tooltips The image tooltips let you preview any image asset. Read more about image tooltips at Image Tooltips .","title":"Overview"},{"location":"image-management/overview/#image-management-tool-suite","text":"Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features:","title":"Image Management Tool Suite"},{"location":"image-management/overview/#image-asset-manager","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets .","title":"Image Asset Manager"},{"location":"image-management/overview/#image-importer","text":"The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets .","title":"Image Importer"},{"location":"image-management/overview/#image-deletion-tool","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets .","title":"Image Deletion Tool"},{"location":"image-management/overview/#image-optimiser","text":"The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Image Optimiser"},{"location":"image-management/overview/#image-tooltips","text":"The image tooltips let you preview any image asset. Read more about image tooltips at Image Tooltips .","title":"Image Tooltips"},{"location":"legal/third-party-software/","text":"Attribution to the third party software and libraries used by MFractor Introduction This document lists the third party software and libraries used by MFractor. Third Party Attribution Android Robot Icon Url: https://developer.android.com/distribute/marketing-tools/brand-guidelines#android_robot License (Creative Commons): https://creativecommons.org/licenses/by/3.0/legalcode Microsoft.ApplicationInsights URL: https://github.com/Microsoft/ApplicationInsights-Home License (MIT): https://github.com/microsoft/ApplicationInsights-Home/blob/master/LICENSE Newtonsoft.Json URL: https://www.newtonsoft.com/json License (MIT): https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md Open Toolkit Library URL: https://github.com/opentk/opentk License (MIT): https://github.com/opentk/opentk/blob/master/LICENSE.md PeaPdf URL: https://github.com/elicym/peapdf License (Apache 2): https://github.com/elicym/peapdf/blob/master/LICENSE Portable.Licensing URL: https://github.com/dnauck/Portable.Licensing License (MIT): https://github.com/dnauck/Portable.Licensing/blob/develop/LICENSE.md Typography URL: https://github.com/LayoutFarm/Typography License (MIT): https://github.com/LayoutFarm/Typography/blob/master/LICENSE.md tinify-net URL: https://github.com/tinify/tinify-net License (MIT): https://github.com/tinify/tinify-net/blob/master/LICENSE WebKit Sharp URL: https://github.com/mono/webkit-sharp License (Novell): Novell License XmlParser URL: https://github.com/KirillOsenkov/XmlParser License (Apache License 2.0): https://github.com/KirillOsenkov/XmlParser/blob/master/LICENSE","title":"Third Party Software"},{"location":"legal/third-party-software/#introduction","text":"This document lists the third party software and libraries used by MFractor.","title":"Introduction"},{"location":"legal/third-party-software/#third-party-attribution","text":"","title":"Third Party Attribution"},{"location":"legal/third-party-software/#android-robot-icon","text":"Url: https://developer.android.com/distribute/marketing-tools/brand-guidelines#android_robot License (Creative Commons): https://creativecommons.org/licenses/by/3.0/legalcode","title":"Android Robot Icon"},{"location":"legal/third-party-software/#microsoftapplicationinsights","text":"URL: https://github.com/Microsoft/ApplicationInsights-Home License (MIT): https://github.com/microsoft/ApplicationInsights-Home/blob/master/LICENSE","title":"Microsoft.ApplicationInsights"},{"location":"legal/third-party-software/#newtonsoftjson","text":"URL: https://www.newtonsoft.com/json License (MIT): https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md","title":"Newtonsoft.Json"},{"location":"legal/third-party-software/#open-toolkit-library","text":"URL: https://github.com/opentk/opentk License (MIT): https://github.com/opentk/opentk/blob/master/LICENSE.md","title":"Open Toolkit Library"},{"location":"legal/third-party-software/#peapdf","text":"URL: https://github.com/elicym/peapdf License (Apache 2): https://github.com/elicym/peapdf/blob/master/LICENSE","title":"PeaPdf"},{"location":"legal/third-party-software/#portablelicensing","text":"URL: https://github.com/dnauck/Portable.Licensing License (MIT): https://github.com/dnauck/Portable.Licensing/blob/develop/LICENSE.md","title":"Portable.Licensing"},{"location":"legal/third-party-software/#typography","text":"URL: https://github.com/LayoutFarm/Typography License (MIT): https://github.com/LayoutFarm/Typography/blob/master/LICENSE.md","title":"Typography"},{"location":"legal/third-party-software/#tinify-net","text":"URL: https://github.com/tinify/tinify-net License (MIT): https://github.com/tinify/tinify-net/blob/master/LICENSE","title":"tinify-net"},{"location":"legal/third-party-software/#webkit-sharp","text":"URL: https://github.com/mono/webkit-sharp License (Novell): Novell License","title":"WebKit Sharp"},{"location":"legal/third-party-software/#xmlparser","text":"URL: https://github.com/KirillOsenkov/XmlParser License (Apache License 2.0): https://github.com/KirillOsenkov/XmlParser/blob/master/LICENSE","title":"XmlParser"},{"location":"linker/excluding-symbols-from-linker/","text":"Exclude assemblies, classes or members from the Xamarin linker Introduction The Linker 101 Define what the linker is? Why do we use it? Using Exclude From Linker Excluding Assemblies Excluding Types Exclude Members","title":"Excluding symbols from linker"},{"location":"linker/excluding-symbols-from-linker/#introduction","text":"The","title":"Introduction"},{"location":"linker/excluding-symbols-from-linker/#linker-101","text":"Define what the linker is? Why do we use it?","title":"Linker 101"},{"location":"linker/excluding-symbols-from-linker/#using-exclude-from-linker","text":"","title":"Using Exclude From Linker"},{"location":"linker/excluding-symbols-from-linker/#excluding-assemblies","text":"","title":"Excluding Assemblies"},{"location":"linker/excluding-symbols-from-linker/#excluding-types","text":"","title":"Excluding Types"},{"location":"linker/excluding-symbols-from-linker/#exclude-members","text":"","title":"Exclude Members"},{"location":"linker/linker-intellisense/","text":"Using the Linker.xml IntelliSense to exclude assemblies, classes or members from the Xamarin linker Introduction Linker IntelliSense","title":"Linker intellisense"},{"location":"linker/linker-intellisense/#introduction","text":"","title":"Introduction"},{"location":"linker/linker-intellisense/#linker-intellisense","text":"","title":"Linker IntelliSense"},{"location":"linker/linker-introduction/","text":"An introduction to the Xamarin linker\\ Introduction The Linker 101 Define what the linker is? Why do we use it? Linker source code: https://github.com/mono/linker Excluding Assemblies Excluding Types Exclude Members","title":"Linker introduction"},{"location":"linker/linker-introduction/#introduction","text":"The","title":"Introduction"},{"location":"linker/linker-introduction/#linker-101","text":"Define what the linker is? Why do we use it? Linker source code: https://github.com/mono/linker","title":"Linker 101"},{"location":"linker/linker-introduction/#excluding-assemblies","text":"","title":"Excluding Assemblies"},{"location":"linker/linker-introduction/#excluding-types","text":"","title":"Excluding Types"},{"location":"linker/linker-introduction/#exclude-members","text":"","title":"Exclude Members"},{"location":"release-notes/mac/current/","text":"A summary of our current release of MFractor for Visual Studio Mac Releases (v4) Releases (v4.0) v4.0.13 - Released on April 20th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.7 - Released on March 29th 2020 - Create class from clipboard tool and Resizetizer image asset support. v4.0.6 - Released on March 24th 2020 - Support for Visual Studio Mac 8.5 and adds insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in color and grid adornments. v4.0.4 - Released on March 17th 2020 - Adds grid row/column index adornments. Adds color adornments (enabled via a feature flag). v4.0.3 - Released on March 10th 2020 - Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution and font glyph tooltips + IntelliSense. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - Marketing release to announce the launch of MFractor for Visual Studio Windows. Releases (v3) Releases (v3.10) v3.10.4 - Released on February 11th 2020 - Adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. v3.10.3 - Released on February 3rd 2020 - Fixes many small XAML IntelliSense issues and adds grouping for MFractors commands in the Key Bindings preferences. v3.10.2 - Released on January 28th 2020 - Bump release to trigger Visual Studio Macs updater mechanisms. v3.10.1 - Released on January 23rd 2020 - Maintenance release to fix a bug in color analysis. v3.10.0 - Released on January 22nd 2020 - Focuses improving our on-boarding workflow, improving the UX and discoverability of code actions plus adding tooltips for colors and images. Releases (v3.9) v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bugs. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Current Release"},{"location":"release-notes/mac/current/#releases-v4","text":"","title":"Releases (v4)"},{"location":"release-notes/mac/current/#releases-v40","text":"v4.0.13 - Released on April 20th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.7 - Released on March 29th 2020 - Create class from clipboard tool and Resizetizer image asset support. v4.0.6 - Released on March 24th 2020 - Support for Visual Studio Mac 8.5 and adds insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in color and grid adornments. v4.0.4 - Released on March 17th 2020 - Adds grid row/column index adornments. Adds color adornments (enabled via a feature flag). v4.0.3 - Released on March 10th 2020 - Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution and font glyph tooltips + IntelliSense. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - Marketing release to announce the launch of MFractor for Visual Studio Windows.","title":"Releases (v4.0)"},{"location":"release-notes/mac/current/#releases-v3","text":"","title":"Releases (v3)"},{"location":"release-notes/mac/current/#releases-v310","text":"v3.10.4 - Released on February 11th 2020 - Adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. v3.10.3 - Released on February 3rd 2020 - Fixes many small XAML IntelliSense issues and adds grouping for MFractors commands in the Key Bindings preferences. v3.10.2 - Released on January 28th 2020 - Bump release to trigger Visual Studio Macs updater mechanisms. v3.10.1 - Released on January 23rd 2020 - Maintenance release to fix a bug in color analysis. v3.10.0 - Released on January 22nd 2020 - Focuses improving our on-boarding workflow, improving the UX and discoverability of code actions plus adding tooltips for colors and images.","title":"Releases (v3.10)"},{"location":"release-notes/mac/current/#releases-v39","text":"v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bugs. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Releases (v3.9)"},{"location":"release-notes/mac/v3/v3.10/","text":"Release notes for our 3.10 versions of MFractor for Visual Studio Mac v3.10.4 Released on 11th of February 2020 This release adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. Enhancements: A new onboarding dialog welcomes you when you first install MFractor. A new Legal top level menu. Smaller distributable package size thanks to the removal of some no longer needed assemblies. Issues Fixed: Fixed: Add Image Tooltip support for C# code and ImageSource Properties. #189 v3.10.3 Released on 3rd of February 2020 This release fixes many small XAML IntelliSense issues related to attribute value and attribute shorthand completions plus adds a grouping for MFractors commands. Enhancements: In the Key Bindings preferences, all MFractor commands are now grouped under an \"MFractor\" section. Issues Fixed: Fixed: MFractor's IntelliSense would not trigger when starting an attribute value with \" . Fixed: MFractor's IntelliSense would not trigger sometimes when starting a new attribute with a letter. You would need to manually start the session with Control+Space . Fixed: Image assets are no longer suggested inside XAML expressions. Fixed: XAML styles would incorrectly report style mismatches. v3.10.2 Released on 28th of January 2020 This release is a \"bump\" release to trigger Visual Studio Macs update mechanisms. Enhancements: When an MFractor feature is Professional only, show a much more obvious status message using the toolbar. v3.10.1 Released on 23rd of January 2020 Maintenance release to fix a bug in color analysis. Enhancements: We've trimmed down the size of the extensions by removing some unnecessary assets. Third party attribution is now on docs.mfractor.com. Issues Fixed: Fixed: Small bug in color Intellisense warnings. #184 . v3.10.0 Released on 22nd of January 2020 The v3.10.0 release focuses improving our on-boarding workflow, improving the UX and discoverability of code actions, adds tooltips for images and colors and includes better refactoring support for static resources. Features: Our new code issue tooltip window presents available fixes for a code issue in the tooltip. You can them click on the suggestion to apply the fix. Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Click on the color value to copy the hex value to the clipboard. Image tooltips in XAML and C#. Hover over an image name to preview the image. Click on the image preview to open it in the image manager. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the App.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. The new Generate Font Character Code Class creates a C# class with all font character names and icons available as string constants. Enhancements: We've cleaned up our Activation Dialog UI structure and direct you to the documentation site after you activate. We've addd a new Request Trial main menu option so you can quickly request a trial license. We've addd a new Recover Professional License menu option so that you can recover you MFractor license. We've addd a new View Release Notes menu option under the About menu so that you can view the release notes for the current release. New Import font asset completion in XAML to launch the font importer and inject the FontFamily XAML needed to reference that code. We've added help links to the following features: Generate custom renderers. Image Importer. Image manager. Image deletion tool. Image optimisation tool. Bindable property wizard. Attached property wizard. Generate Interface Implementation. Font Importer. We've added a help links section to our XAML analysis preferences panel. As we document each analyser, a link to view the docs for that analyser become available. The Find Custom Renderers code action is now accessible through the Alt+Return menu in C#. When you update MFractor, we now show a small thank you message and provide you with a link to the release notes for that version. When you first install MFractor, we trigger Visual Studio Mac to restart to complete the installation. Issues Fixed: We've multiple issues where MFractor Lite wouldn't properly record and inform you that you were on a restriction of 4 documents per day. Fixed: The Start Accessibility Inspector command would not appear or launch. Fixed: The Edit Shared Project Items command wasn't opening the .projitems . Fixed: Sometimes Row and Column location completions wouldn't appear while editing a child of a grid. Fixed: Numeric data-bindings no longer give type mismatch warnings.","title":"v3.10"},{"location":"release-notes/mac/v3/v3.10/#v3104","text":"Released on 11th of February 2020 This release adds our new onboarding dialog, adds a new legal main menu item and reduces the final package size of MFractor. Enhancements: A new onboarding dialog welcomes you when you first install MFractor. A new Legal top level menu. Smaller distributable package size thanks to the removal of some no longer needed assemblies. Issues Fixed: Fixed: Add Image Tooltip support for C# code and ImageSource Properties. #189","title":"v3.10.4"},{"location":"release-notes/mac/v3/v3.10/#v3103","text":"Released on 3rd of February 2020 This release fixes many small XAML IntelliSense issues related to attribute value and attribute shorthand completions plus adds a grouping for MFractors commands. Enhancements: In the Key Bindings preferences, all MFractor commands are now grouped under an \"MFractor\" section. Issues Fixed: Fixed: MFractor's IntelliSense would not trigger when starting an attribute value with \" . Fixed: MFractor's IntelliSense would not trigger sometimes when starting a new attribute with a letter. You would need to manually start the session with Control+Space . Fixed: Image assets are no longer suggested inside XAML expressions. Fixed: XAML styles would incorrectly report style mismatches.","title":"v3.10.3"},{"location":"release-notes/mac/v3/v3.10/#v3102","text":"Released on 28th of January 2020 This release is a \"bump\" release to trigger Visual Studio Macs update mechanisms. Enhancements: When an MFractor feature is Professional only, show a much more obvious status message using the toolbar.","title":"v3.10.2"},{"location":"release-notes/mac/v3/v3.10/#v3101","text":"Released on 23rd of January 2020 Maintenance release to fix a bug in color analysis. Enhancements: We've trimmed down the size of the extensions by removing some unnecessary assets. Third party attribution is now on docs.mfractor.com. Issues Fixed: Fixed: Small bug in color Intellisense warnings. #184 .","title":"v3.10.1"},{"location":"release-notes/mac/v3/v3.10/#v3100","text":"Released on 22nd of January 2020 The v3.10.0 release focuses improving our on-boarding workflow, improving the UX and discoverability of code actions, adds tooltips for images and colors and includes better refactoring support for static resources. Features: Our new code issue tooltip window presents available fixes for a code issue in the tooltip. You can them click on the suggestion to apply the fix. Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Click on the color value to copy the hex value to the clipboard. Image tooltips in XAML and C#. Hover over an image name to preview the image. Click on the image preview to open it in the image manager. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the App.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. The new Generate Font Character Code Class creates a C# class with all font character names and icons available as string constants. Enhancements: We've cleaned up our Activation Dialog UI structure and direct you to the documentation site after you activate. We've addd a new Request Trial main menu option so you can quickly request a trial license. We've addd a new Recover Professional License menu option so that you can recover you MFractor license. We've addd a new View Release Notes menu option under the About menu so that you can view the release notes for the current release. New Import font asset completion in XAML to launch the font importer and inject the FontFamily XAML needed to reference that code. We've added help links to the following features: Generate custom renderers. Image Importer. Image manager. Image deletion tool. Image optimisation tool. Bindable property wizard. Attached property wizard. Generate Interface Implementation. Font Importer. We've added a help links section to our XAML analysis preferences panel. As we document each analyser, a link to view the docs for that analyser become available. The Find Custom Renderers code action is now accessible through the Alt+Return menu in C#. When you update MFractor, we now show a small thank you message and provide you with a link to the release notes for that version. When you first install MFractor, we trigger Visual Studio Mac to restart to complete the installation. Issues Fixed: We've multiple issues where MFractor Lite wouldn't properly record and inform you that you were on a restriction of 4 documents per day. Fixed: The Start Accessibility Inspector command would not appear or launch. Fixed: The Edit Shared Project Items command wasn't opening the .projitems . Fixed: Sometimes Row and Column location completions wouldn't appear while editing a child of a grid. Fixed: Numeric data-bindings no longer give type mismatch warnings.","title":"v3.10.0"},{"location":"release-notes/mac/v3/v3.9/","text":"Release notes for our 3.9 versions of MFractor for Visual Studio Mac v3.9.8 Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. v3.9.7 Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176 v3.9.6 Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements. v3.9.5 Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 . v3.9.4 Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation. v3.9.3 Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix -> Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.2 Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac. v3.9.1 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.0 Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9"},{"location":"release-notes/mac/v3/v3.9/#v398","text":"Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml.","title":"v3.9.8"},{"location":"release-notes/mac/v3/v3.9/#v397","text":"Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176","title":"v3.9.7"},{"location":"release-notes/mac/v3/v3.9/#v396","text":"Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements.","title":"v3.9.6"},{"location":"release-notes/mac/v3/v3.9/#v395","text":"Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 .","title":"v3.9.5"},{"location":"release-notes/mac/v3/v3.9/#v394","text":"Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation.","title":"v3.9.4"},{"location":"release-notes/mac/v3/v3.9/#v393","text":"Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix -> Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.3"},{"location":"release-notes/mac/v3/v3.9/#v392","text":"Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac.","title":"v3.9.2"},{"location":"release-notes/mac/v3/v3.9/#v391","text":"Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.1"},{"location":"release-notes/mac/v3/v3.9/#v390","text":"Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9.0"},{"location":"release-notes/mac/v4/v4.0/","text":"Release notes for our 4.0 versions of MFractor for Visual Studio Mac v4.0.13 Released on April 20th 2020 Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. Features Font string preview tooltips. Embedded font tooltips. Go to definition support for fonts that opens the font viewer. Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished. v4.0.12 Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties. v4.0.11 Released on April 14th 2020 Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. Features The new font viewer pad allows you to visually explore the content of a font asset. Support for embedded font assets in font analysis, IntelliSense and tooltips. When setting the BindingContext for a control, new shorthand completion that provides available x:Name fields to create a {x:Reference fieldName} expression. v4.0.10 Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors. v4.0.9 Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times. v4.0.7 Released on 29th of March 2020 Service release to add the Create class from clipboard tool and Resizetizer image asset support. v4.0.6 Released on 24th of March 2020 Service release to support Visual Studio Mac 8.5 and adds Features Insert row/column code actions. Delete row/column code actions. Enhancements All of MFractors code actions are now grouped under a single MFractor Code Actions menu. This makes it easier to discover our code actions. New code fix to remove all redundant grid row and columns. v4.0.5 Released on 19th of March 2020 Service release to fix bugs in color and grid adornments. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: Grid adornments with double digits are no longer clipped. Fixed: Show color elaborations on black and white. #195 Fixed: Grid adornments should honor IDE theme (dark vs light). Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 . v4.0.4 Released on 17th of March 2020 Adds adornments for grid indices and color values. Enhancements: MFractor now adds an annotation before a Row/Column definition to show it's index. MFractor now adds a color annotation alongside color values to show the color inline. v4.0.3 Released on 10th of March 2020 Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . v4.0.2 Released on 2nd of March 2020 Adds x:DataType support to binding context resolution and font glyph tooltips and IntelliSense. Enhancements: When hovering over a font glyph code and MFractor can resolve the font family, a tooltip preview of that glyph will now be shown. When editing string values and the font applied has glyphs, MFractor now suggests the font glyphs in IntelliSense. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType. v4.0.1 Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. v4.0.0 Released on 20th of February 2020 MFractor 4.0.0 is a marketing release to announce the launch of MFractor for Visual Studio Windows. Features: Our New onboarding dialog to welcome you after installing.","title":"v4.0"},{"location":"release-notes/mac/v4/v4.0/#v4013","text":"Released on April 20th 2020 Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. Features Font string preview tooltips. Embedded font tooltips. Go to definition support for fonts that opens the font viewer. Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished.","title":"v4.0.13"},{"location":"release-notes/mac/v4/v4.0/#v4012","text":"Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties.","title":"v4.0.12"},{"location":"release-notes/mac/v4/v4.0/#v4011","text":"Released on April 14th 2020 Service release to improve font tool suite by adding a font viewer pad and support for embedded font assets. Features The new font viewer pad allows you to visually explore the content of a font asset. Support for embedded font assets in font analysis, IntelliSense and tooltips. When setting the BindingContext for a control, new shorthand completion that provides available x:Name fields to create a {x:Reference fieldName} expression.","title":"v4.0.11"},{"location":"release-notes/mac/v4/v4.0/#v4010","text":"Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors.","title":"v4.0.10"},{"location":"release-notes/mac/v4/v4.0/#v409","text":"Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings.","title":"v4.0.9"},{"location":"release-notes/mac/v4/v4.0/#v408","text":"Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times.","title":"v4.0.8"},{"location":"release-notes/mac/v4/v4.0/#v407","text":"Released on 29th of March 2020 Service release to add the Create class from clipboard tool and Resizetizer image asset support.","title":"v4.0.7"},{"location":"release-notes/mac/v4/v4.0/#v406","text":"Released on 24th of March 2020 Service release to support Visual Studio Mac 8.5 and adds Features Insert row/column code actions. Delete row/column code actions. Enhancements All of MFractors code actions are now grouped under a single MFractor Code Actions menu. This makes it easier to discover our code actions. New code fix to remove all redundant grid row and columns.","title":"v4.0.6"},{"location":"release-notes/mac/v4/v4.0/#v405","text":"Released on 19th of March 2020 Service release to fix bugs in color and grid adornments. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: Grid adornments with double digits are no longer clipped. Fixed: Show color elaborations on black and white. #195 Fixed: Grid adornments should honor IDE theme (dark vs light). Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 .","title":"v4.0.5"},{"location":"release-notes/mac/v4/v4.0/#v404","text":"Released on 17th of March 2020 Adds adornments for grid indices and color values. Enhancements: MFractor now adds an annotation before a Row/Column definition to show it's index. MFractor now adds a color annotation alongside color values to show the color inline.","title":"v4.0.4"},{"location":"release-notes/mac/v4/v4.0/#v403","text":"Released on 10th of March 2020 Adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= .","title":"v4.0.3"},{"location":"release-notes/mac/v4/v4.0/#v402","text":"Released on 2nd of March 2020 Adds x:DataType support to binding context resolution and font glyph tooltips and IntelliSense. Enhancements: When hovering over a font glyph code and MFractor can resolve the font family, a tooltip preview of that glyph will now be shown. When editing string values and the font applied has glyphs, MFractor now suggests the font glyphs in IntelliSense. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType.","title":"v4.0.2"},{"location":"release-notes/mac/v4/v4.0/#v401","text":"Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style.","title":"v4.0.1"},{"location":"release-notes/mac/v4/v4.0/#v400","text":"Released on 20th of February 2020 MFractor 4.0.0 is a marketing release to announce the launch of MFractor for Visual Studio Windows. Features: Our New onboarding dialog to welcome you after installing.","title":"v4.0.0"},{"location":"release-notes/windows/current/","text":"A summary of our current release of MFractor for Visual Studio Windows Releases (v4) Releases (v4.0) v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Hotfix release to fix image manager list items not appearing. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.6 - Released on March 24th 2020 - Service release add insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. v4.0.4 - Released on March 17th 2020 - Fixes an issue where trial license requests were not going through. v4.0.3 - Released on March 10th 2020 - Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - v4.0 is our stable release of MFractor for Visual Studio Windows, reaching approximate feature parity with MFractor for Visual Studio Mac. Releases (v0) v0.6.0 - Released on February 12th 2020 : Preview 6 release of MFractor for Visual Studio Windows. v0.5.0 - Released on February 11th 2020 : Preview 5 release of MFractor for Visual Studio Windows. v0.4.0 - Released on February 4th 2020 : Preview 4 release of MFractor for Visual Studio Windows. v0.3.0 - Released on January 28th 2020 : Preview 3 release of MFractor for Visual Studio Windows. v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows. v0.1.0 - Released on November 25th 2019 : Preview 1 release of MFractor for Visual Studio Windows.","title":"Current Release"},{"location":"release-notes/windows/current/#releases-v4","text":"","title":"Releases (v4)"},{"location":"release-notes/windows/current/#releases-v40","text":"v4.0.13 - Released on April 20th 2020 - Service release to expand the font tooling, new XAML analysers and improved performance for the XAML analyser. v4.0.12 - Released on April 18th 2020 - Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. v4.0.11 - Released on April 14th 2020 - Hotfix release to fix image manager list items not appearing. v4.0.10 - Released on April 10th 2020 - Service release to add color consolidation, UWP support for the image manager plus bug fixes for binding analysis. v4.0.9 - Released on April 8th 2020 - Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 - Released on April 7th 2020 - Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. v4.0.6 - Released on March 24th 2020 - Service release add insert/delete grid row and column refactorings. v4.0.5 - Released on March 19th 2020 - Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. v4.0.4 - Released on March 17th 2020 - Fixes an issue where trial license requests were not going through. v4.0.3 - Released on March 10th 2020 - Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. v4.0.2 - Released on March 2nd 2020 - Adds x:DataType support to binding context resolution. v4.0.1 - Released on February 24th 2020 - Fixes style and grid refactoring bugs. v4.0.0 - Released on February 20th 2020 - v4.0 is our stable release of MFractor for Visual Studio Windows, reaching approximate feature parity with MFractor for Visual Studio Mac.","title":"Releases (v4.0)"},{"location":"release-notes/windows/current/#releases-v0","text":"v0.6.0 - Released on February 12th 2020 : Preview 6 release of MFractor for Visual Studio Windows. v0.5.0 - Released on February 11th 2020 : Preview 5 release of MFractor for Visual Studio Windows. v0.4.0 - Released on February 4th 2020 : Preview 4 release of MFractor for Visual Studio Windows. v0.3.0 - Released on January 28th 2020 : Preview 3 release of MFractor for Visual Studio Windows. v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows. v0.1.0 - Released on November 25th 2019 : Preview 1 release of MFractor for Visual Studio Windows.","title":"Releases (v0)"},{"location":"release-notes/windows/v0/v0.1/","text":"Release notes for our 0.1 versions of MFractor for Visual Studio Windows v0.1.0 Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1"},{"location":"release-notes/windows/v0/v0.1/#v010","text":"Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1.0"},{"location":"release-notes/windows/v0/v0.2/","text":"Release notes for our 0.2 versions of MFractor for Visual Studio Windows v0.2.0 Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accessible through Extensions -> MFractor -> Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2"},{"location":"release-notes/windows/v0/v0.2/#v020","text":"Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accessible through Extensions -> MFractor -> Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2.0"},{"location":"release-notes/windows/v0/v0.3/","text":"Release notes for our 0.3 versions of MFractor for Visual Studio Windows v0.3.0 Released on January 28th 2020 MFractor for Visual Studio Windows v0.3.0 is a major upgrade from v0.2, adding our IntelliSense engine, custom tooltips for XAML, additional menu items for requesting a trial and recovering an existing license. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 3 . Preview 3 : IntelliSense Integration. Custom tooltips for code issues, colors and image assets. Main menu items for: Request 30 day trial. Recover license. View release notes. Go to XAML symbol action. Find Custom Renderers action. Generate Font Character Code Class tool. Fixes numerous issues in our core engine. Please see Mac v3.10 and Mac v3.9 release notes for full details.","title":"v0.3"},{"location":"release-notes/windows/v0/v0.3/#v030","text":"Released on January 28th 2020 MFractor for Visual Studio Windows v0.3.0 is a major upgrade from v0.2, adding our IntelliSense engine, custom tooltips for XAML, additional menu items for requesting a trial and recovering an existing license. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 3 . Preview 3 : IntelliSense Integration. Custom tooltips for code issues, colors and image assets. Main menu items for: Request 30 day trial. Recover license. View release notes. Go to XAML symbol action. Find Custom Renderers action. Generate Font Character Code Class tool. Fixes numerous issues in our core engine. Please see Mac v3.10 and Mac v3.9 release notes for full details.","title":"v0.3.0"},{"location":"release-notes/windows/v0/v0.4/","text":"Release notes for our 0.4 versions of MFractor for Visual Studio Windows v0.4.0 Released on February 4th 2020 MFractor for Visual Studio Windows v0.4 is a major upgrade from v0.3, shifting significantly closer to a stable release. This release integrates our workspace events and data engines to activate all features related to static resources (analysis, code actions, tooltips and IntelliSense) and image assets (analysis, code actions, tooltips and IntelliSense). Officially, this product release is known as MFractor for Visual Studio Windows - Preview 4 . Preview 4 : The workspace events engine is now integrated, having flow on effects to enable several other core systems and features. The meta-data engine is now integrated and switches on many remaining features that required the solution meta-data database. Tooltips for static resources, image assets and dynamic resources. New IntelliSense suggestions. Static resources. Dynamic resources. Image assets. Analysis integration for static resources and missing images. The performance of the image manager is now significantly improved due to the meta-data engine being integrated. The image manager is now able to watch for images being added/removed and update itself to show these changes. Reduced VSIX size by removing unused assets. Issues Fixed: Fixed: The delete image asset tool no longer locks up the IDE.","title":"v0.4"},{"location":"release-notes/windows/v0/v0.4/#v040","text":"Released on February 4th 2020 MFractor for Visual Studio Windows v0.4 is a major upgrade from v0.3, shifting significantly closer to a stable release. This release integrates our workspace events and data engines to activate all features related to static resources (analysis, code actions, tooltips and IntelliSense) and image assets (analysis, code actions, tooltips and IntelliSense). Officially, this product release is known as MFractor for Visual Studio Windows - Preview 4 . Preview 4 : The workspace events engine is now integrated, having flow on effects to enable several other core systems and features. The meta-data engine is now integrated and switches on many remaining features that required the solution meta-data database. Tooltips for static resources, image assets and dynamic resources. New IntelliSense suggestions. Static resources. Dynamic resources. Image assets. Analysis integration for static resources and missing images. The performance of the image manager is now significantly improved due to the meta-data engine being integrated. The image manager is now able to watch for images being added/removed and update itself to show these changes. Reduced VSIX size by removing unused assets. Issues Fixed: Fixed: The delete image asset tool no longer locks up the IDE.","title":"v0.4.0"},{"location":"release-notes/windows/v0/v0.5/","text":"Release notes for our 0.5 versions of MFractor for Visual Studio Windows v0.5.0 Released on February 11th 2020 MFractor for Visual Studio Windows v0.5 is an incremental upgrade from v0.4, focusing on performance, stability and improving feature parity with MFractor for Visual Studio Mac This release enables data-binding IntelliSense using our powerful view model resolution engine, adds a new onboarding experience and fixes several bugs in our image tooltips. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 5 . Preview 5 : Adds support for view model property IntelliSense. Adds a new onboarding dialog. Add Manage Image Assets to the solution explorer menu. Issues Fixed: Fixed: Image tooltips in C# would not appear.","title":"v0.5"},{"location":"release-notes/windows/v0/v0.5/#v050","text":"Released on February 11th 2020 MFractor for Visual Studio Windows v0.5 is an incremental upgrade from v0.4, focusing on performance, stability and improving feature parity with MFractor for Visual Studio Mac This release enables data-binding IntelliSense using our powerful view model resolution engine, adds a new onboarding experience and fixes several bugs in our image tooltips. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 5 . Preview 5 : Adds support for view model property IntelliSense. Adds a new onboarding dialog. Add Manage Image Assets to the solution explorer menu. Issues Fixed: Fixed: Image tooltips in C# would not appear.","title":"v0.5.0"},{"location":"release-notes/windows/v0/v0.6/","text":"Release notes for our 0.6 versions of MFractor for Visual Studio Windows v0.6.0 Released on February 12th 2020 MFractor for Visual Studio Windows v0.5 fixes a bug in the request license workflow where license requests would not go through. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 6 .","title":"v0.6"},{"location":"release-notes/windows/v0/v0.6/#v060","text":"Released on February 12th 2020 MFractor for Visual Studio Windows v0.5 fixes a bug in the request license workflow where license requests would not go through. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 6 .","title":"v0.6.0"},{"location":"release-notes/windows/v4/v4.0/","text":"Release notes for our 4.0 versions of MFractor for Visual Studio Windows v4.0.13 Released on April 20th 2020 Service release to add new XAML analysers and improved performance for the XAML analyser. Features Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished. v4.0.12 Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work on Windows. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties. v4.0.11 Released on April 14th 2020 Hotfix release to fix image manager list items not appearing. Issues Fixed: Fixed: The images listed by the image manager would not appear correctly. v4.0.10 Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors. v4.0.9 Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings. v4.0.8 Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times. v4.0.6 Released on 24th of March 2020 Service release to add insert/delete row and column actions. Features Insert row/column code actions. Delete row/column code actions. Enhancements New code fix to remove all redundant grid row and columns. v4.0.5 Released on 19th of March 2020 Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 . v4.0.4 Released on 17th of March 2020 Fixes an issue where trial license requests were not going through. v4.0.3 Released on 10th of March 2020 Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . Issues Fixed: Fixed: Hint window in dark mode for VS Win has low contrast. #193 Fixed: Image managers image no longer appeared. v4.0.2 Released on 2nd of March 2020 Adds x:DataType support to binding context resolution. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType. v4.0.1 Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. Fixed: Fixed issues where sometimes project files would not synchronise and features like manage images or MVVM navigation would stop working v4.0.0 Released on February 20th 2020 The v4.0 release of MFractor for Visual Studio is the stable release of MFractor, reaching approximate feature parity with MFractor for Visual Studio Mac. At a glance, MFractor for Visual Studio Windows offers: A powerful XAML feature suite makes it faster and easier to writing beautiful XAML. Write better XAML, faster with supercharged IntelliSense. MFractor suggests ViewModel properties, image assets, short cut completions for grids, setters and trigger plus much more. Over 80 XAML analysers find a huge range of bugs, improvements, code smells and maintainability issues. Even better, you can often fix an issue with a single click. Over 100 XAML code actions make it dead easy to refactor and cleanup your XAML. Custom tooltips give you deeper insight into your codebase. Preview image assets, colour and static resources! MFractors image management tool suite lets you import new Android and iOS assets in seconds, delete images across all projects and visually browse all assets in your solution. Wizards for importing fonts, generating view models, creating value converters, bindable properties, interface implementations and much more.","title":"v4.0"},{"location":"release-notes/windows/v4/v4.0/#v4013","text":"Released on April 20th 2020 Service release to add new XAML analysers and improved performance for the XAML analyser. Features Analyser to verify the content of a refresh view is scrollable. Analyser to verify the content that the platform specified by an On element is a known platform. Analyser to verify that a referenced embedded font is defined. Analyser to detect when a C# style newline ( \\n ) is used within XAML and warn that it is not escaped. Issues Fixed: Fixed: The XAML analyser would always re-analyse the document if it's window lost focus and then regained it. Fixed: The XAML analyser would not re-analyse the document after a solution sync had finished.","title":"v4.0.13"},{"location":"release-notes/windows/v4/v4.0/#v4012","text":"Released on April 18th 2020 Service release to hotfix an XML syntax transformation failure and adds MobileBuildTools image support. Features Support for MobileBuildTools style image assets in all image features. Issues Fixed: Fixed: XML syntax refactorings would not work on Windows. Fixed: The XAML analyser no longer flags the design schema as unknown when inspecting properties.","title":"v4.0.12"},{"location":"release-notes/windows/v4/v4.0/#v4011","text":"Released on April 14th 2020 Hotfix release to fix image manager list items not appearing. Issues Fixed: Fixed: The images listed by the image manager would not appear correctly.","title":"v4.0.11"},{"location":"release-notes/windows/v4/v4.0/#v4010","text":"Released on April 10th 2020 Service release to add color consolidation analysis and refactorings and support for UWP in the image manager. Features Color consolidation analyser finds colors usages throughout your app and notifies you when you could merge them into a single static resource. Color consolidation refactorings to batch replace all duplicate color values with a static resource. UWP support for the font importer. UWP support for the image manager. UWP support for the delete image asset tool. When using a custom font and a static resource to resolve the glyph code, MFractor can now render a preview of that glyph. Issues Fixed: Fixed: The choose file dialog doesn't disappear when importing a license. Fixed: Using x:Reference to refer to the root XAML element as a binding context would generate binding validation errors.","title":"v4.0.10"},{"location":"release-notes/windows/v4/v4.0/#v409","text":"Released on 8th of April 2020 Hotfix to address thickness simplification analysis bug showing too many warnings.","title":"v4.0.9"},{"location":"release-notes/windows/v4/v4.0/#v408","text":"Released on 7th of April 2020 Service release to add thickness consolidation and significant performance improvements to the XAML analysis engine. Features Thickness consolidation analyser finds thickness usages throughout your app and notifies you when you could merge them into a single static resource. Thickness consolidation refactorings to batch replace all duplicate thickness values with a static resource. Enhancements Significant reduction in memory consumption when MFractor analysis XAML and a 400% improvement in performance times.","title":"v4.0.8"},{"location":"release-notes/windows/v4/v4.0/#v406","text":"Released on 24th of March 2020 Service release to add insert/delete row and column actions. Features Insert row/column code actions. Delete row/column code actions. Enhancements New code fix to remove all redundant grid row and columns.","title":"v4.0.6"},{"location":"release-notes/windows/v4/v4.0/#v405","text":"Released on 19th of March 2020 Service release to fix bugs in MVVM wizard and x:Reference code behind data bindings. Enhancements When editing inside an OnPlatform element, MFractor now suggests the available platforms as completions. Issues Fixed: Fixed: MFractor doesn't correctly recognize type of binding source. #194 . Fixed: MVVM Wizard - Color Coding the XAML File Previewer. #119 .","title":"v4.0.5"},{"location":"release-notes/windows/v4/v4.0/#v404","text":"Released on 17th of March 2020 Fixes an issue where trial license requests were not going through.","title":"v4.0.4"},{"location":"release-notes/windows/v4/v4.0/#v403","text":"Released on 10th of March 2020 Fixes the contrast in XAML code issue tooltips, adds several new XAML analysers, improves performance/memory usage and introduces a new C# refactoring. Enhancements: We've retired the legacy way we resolved symbols in XAML files to significantly in improve performance and memory consumption in XAML analysis, tooltips, code actions and IntelliSense. Code Analysis: When a ViewCell is used inside a CollectionView, MFractor will warn you that it is obsolete. MFractor now inspects the Glyph codes used with a FontFamily and verify the glyph exists in the font. Code Issue Fixes: When a style resource does not exists, use the create style fix to start the style wizard and create a new one. Refactorings: Swap event handler binding between += and -= . Issues Fixed: Fixed: Hint window in dark mode for VS Win has low contrast. #193 Fixed: Image managers image no longer appeared.","title":"v4.0.3"},{"location":"release-notes/windows/v4/v4.0/#v402","text":"Released on 2nd of March 2020 Adds x:DataType support to binding context resolution. Issues Fixed: Fixed: MFractor now supports binding context resolution using x:DataType.","title":"v4.0.2"},{"location":"release-notes/windows/v4/v4.0/#v401","text":"Released on 24th of February 2020 Fixes bugs in extract style and convert stack layout to grid refactorings. Issues Fixed: Fixed: Horizontal stack layouts would generate broken code when converting to a grid. Fixed: Do not include Text properties when extracting a style. Fixed: Fixed issues where sometimes project files would not synchronise and features like manage images or MVVM navigation would stop working","title":"v4.0.1"},{"location":"release-notes/windows/v4/v4.0/#v400","text":"Released on February 20th 2020 The v4.0 release of MFractor for Visual Studio is the stable release of MFractor, reaching approximate feature parity with MFractor for Visual Studio Mac. At a glance, MFractor for Visual Studio Windows offers: A powerful XAML feature suite makes it faster and easier to writing beautiful XAML. Write better XAML, faster with supercharged IntelliSense. MFractor suggests ViewModel properties, image assets, short cut completions for grids, setters and trigger plus much more. Over 80 XAML analysers find a huge range of bugs, improvements, code smells and maintainability issues. Even better, you can often fix an issue with a single click. Over 100 XAML code actions make it dead easy to refactor and cleanup your XAML. Custom tooltips give you deeper insight into your codebase. Preview image assets, colour and static resources! MFractors image management tool suite lets you import new Android and iOS assets in seconds, delete images across all projects and visually browse all assets in your solution. Wizards for importing fonts, generating view models, creating value converters, bindable properties, interface implementations and much more.","title":"v4.0.0"},{"location":"utilities/clean-and-compress/","text":"Quickly create a zip archive for solution or projects Introduction The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac. Archiving Solutions To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop. Archiving Projects To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop. Example","title":"Clean And Compress"},{"location":"utilities/clean-and-compress/#introduction","text":"The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/clean-and-compress/#archiving-solutions","text":"To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop.","title":"Archiving Solutions"},{"location":"utilities/clean-and-compress/#archiving-projects","text":"To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop.","title":"Archiving Projects"},{"location":"utilities/clean-and-compress/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/","text":"Remove the working and output folders for a solution or project Introduction The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac. Using Delete Output Folders To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system. Example Configuring Delete Output Folders The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Delete Output Folders"},{"location":"utilities/delete-output-folders/#introduction","text":"The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/delete-output-folders/#using-delete-output-folders","text":"To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system.","title":"Using Delete Output Folders"},{"location":"utilities/delete-output-folders/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/#configuring-delete-output-folders","text":"The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Configuring Delete Output Folders"},{"location":"utilities/edit-shared-project-items/","text":"Edit the msbuild for a shared project Introduction One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to. Editing Shared Project Items Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Edit Shared Project Items"},{"location":"utilities/edit-shared-project-items/#introduction","text":"One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to.","title":"Introduction"},{"location":"utilities/edit-shared-project-items/#editing-shared-project-items","text":"Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Editing Shared Project Items"},{"location":"xamarin-forms/overview/","text":"Introduction MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite. Xamarin.Forms Features XAML Editor XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation. MVVM Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard. Search Static resource global search. Dynamic resource global search. AutomationID global search. Localisation Generating localisation infrastructure. Localising XAML files. Custom Renderers Finding custom renderers. Creating custom renderers. Custom Controls Creating bindable properties . Extracting XAML controls . Styles Extracting XAML styles. Style analysis. Value Converters Value converter wizard. Value converter analysis.","title":"Overview"},{"location":"xamarin-forms/overview/#introduction","text":"MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite.","title":"Introduction"},{"location":"xamarin-forms/overview/#xamarinforms-features","text":"","title":"Xamarin.Forms Features"},{"location":"xamarin-forms/overview/#xaml-editor","text":"XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation.","title":"XAML Editor"},{"location":"xamarin-forms/overview/#mvvm","text":"Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard.","title":"MVVM"},{"location":"xamarin-forms/overview/#search","text":"Static resource global search. Dynamic resource global search. AutomationID global search.","title":"Search"},{"location":"xamarin-forms/overview/#localisation","text":"Generating localisation infrastructure. Localising XAML files.","title":"Localisation"},{"location":"xamarin-forms/overview/#custom-renderers","text":"Finding custom renderers. Creating custom renderers.","title":"Custom Renderers"},{"location":"xamarin-forms/overview/#custom-controls","text":"Creating bindable properties . Extracting XAML controls .","title":"Custom Controls"},{"location":"xamarin-forms/overview/#styles","text":"Extracting XAML styles. Style analysis.","title":"Styles"},{"location":"xamarin-forms/overview/#value-converters","text":"Value converter wizard. Value converter analysis.","title":"Value Converters"},{"location":"xamarin-forms/tooltips/","text":"Introduction XAML Tooltips Grids Colors Thicknesses","title":"Tooltips"},{"location":"xamarin-forms/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/tooltips/#xaml-tooltips","text":"","title":"XAML Tooltips"},{"location":"xamarin-forms/tooltips/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/tooltips/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/tooltips/#thicknesses","text":"","title":"Thicknesses"},{"location":"xamarin-forms/xaml-intellisense/","text":"TODO: An overview of MFractors XAML intellisense integration. Introduction IntelliSense Features Data-Binding Grids Static Resources Dynamic Resources Images Colors DataTriggers Setter's StackLayout's","title":"Xaml intellisense"},{"location":"xamarin-forms/xaml-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/xaml-intellisense/#intellisense-features","text":"","title":"IntelliSense Features"},{"location":"xamarin-forms/xaml-intellisense/#data-binding","text":"","title":"Data-Binding"},{"location":"xamarin-forms/xaml-intellisense/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/xaml-intellisense/#static-resources","text":"","title":"Static Resources"},{"location":"xamarin-forms/xaml-intellisense/#dynamic-resources","text":"","title":"Dynamic Resources"},{"location":"xamarin-forms/xaml-intellisense/#images","text":"","title":"Images"},{"location":"xamarin-forms/xaml-intellisense/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/xaml-intellisense/#datatriggers","text":"","title":"DataTriggers"},{"location":"xamarin-forms/xaml-intellisense/#setters","text":"","title":"Setter's"},{"location":"xamarin-forms/xaml-intellisense/#stacklayouts","text":"","title":"StackLayout's"},{"location":"xamarin-forms/analysis/overview/","text":"","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/automatic-viewmodel-detection/","text":"MFractor uses automatic ViewModel resolution to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention. Let's consider the following files: LoginPage.xaml - The XAML view. LoginPage.xaml.cs - The code behind for the XAML view. LoginViewModel - The a C# class that is the view model for the LoginPage view. Because these pages share the prefix Login and each has a distinct file extension or suffix, MFractor assumes the following relationships: The .xaml extension denotes that LoginPage.xaml is a xaml view. The .xaml.cs extension and the LoginPage component denotes that LoginPage.xaml.cs is the code behind implementation LoginPage view. The ViewModel suffix implies that LoginViewModel is a view model. When ViewModel is removed from LoginViewModel and Page is removed from LoginPage, the Login component implies that the LoginViewModel is related to the LoginPage XAML view and it's code behind file. MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that LoginViewModel will probably be the BindingContext for LoginPage. The Page <-> ViewModel naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM. The following suffixes are supported for XAML views: Page: EG LoginPage.xaml <-> LoginViewModel View: EG LoginView.xaml <-> LoginViewModel The following suffixes are supported for View Models. ViewModel: LoginPage.xaml <-> LoginViewModel PageModel: LoginView.xaml <-> LoginPageModel PageViewModel: LoginView.xaml <-> LoginPageViewModel Model: LoginView.xaml <-> LoginModel VM: LoginView.xaml <-> LoginVM PageVM: LoginView.xaml <-> LoginPageVM","title":"Automatic ViewModel Detection"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/","text":"Binding Context Evaluation In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: <Entry BindingContext=\"{x:Static local:MyStaticClass.MyStaticProperty}\"/> This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml <ContentPage xmlns:local=\"clr-namespace:MyApp;assembly=MyApp\" BindingContext=\"{x:Static local:ViewModelLocator.LoginViewModel}\"/> When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: <Switch x:Name=\"mySwitch\" /> <Label BindingContext=\"{x:Reference mySwitch}\" IsVisible=\"{Binding IsToggled}\"/> When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"BindingContext Evaluation"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/#binding-context-evaluation","text":"In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: <Entry BindingContext=\"{x:Static local:MyStaticClass.MyStaticProperty}\"/> This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml <ContentPage xmlns:local=\"clr-namespace:MyApp;assembly=MyApp\" BindingContext=\"{x:Static local:ViewModelLocator.LoginViewModel}\"/> When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: <Switch x:Name=\"mySwitch\" /> <Label BindingContext=\"{x:Reference mySwitch}\" IsVisible=\"{Binding IsToggled}\"/> When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"Binding Context Evaluation"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/","text":"Cross Project Binding Context Resolution If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id= \"com.mfractor.configuration.forms.mvvm_resolution\" > <property name= \"ViewModelsProjectName\" value= \"TODO: Insert the name of your view models project as it appears in the solution explorer\" /> </configure> </mfractor> In the project that contains your view models, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id= \"com.mfractor.configuration.forms.mvvm_resolution\" > <property name= \"ViewsProjectName\" value= \"TODO: Insert the name of your views project as it appears in the solution explorer\" /> </configure> </mfractor>","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/#cross-project-binding-context-resolution","text":"If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id= \"com.mfractor.configuration.forms.mvvm_resolution\" > <property name= \"ViewModelsProjectName\" value= \"TODO: Insert the name of your view models project as it appears in the solution explorer\" /> </configure> </mfractor> In the project that contains your view models, create a file named app.mfc.xml with the following content: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <mfractor> <configure id= \"com.mfractor.configuration.forms.mvvm_resolution\" > <property name= \"ViewsProjectName\" value= \"TODO: Insert the name of your views project as it appears in the solution explorer\" /> </configure> </mfractor>","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/","text":"Data Template Binding Context Resolution Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: <ListView ItemsSource= \"{Binding Contacts}\" > <ListView.ItemTemplate> <DataTemplate> <TextCell Text= \"{Binding DisplayName}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"DataTemplate Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/#data-template-binding-context-resolution","text":"Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: <ListView ItemsSource= \"{Binding Contacts}\" > <ListView.ItemTemplate> <DataTemplate> <TextCell Text= \"{Binding DisplayName}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"Data Template Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/","text":"Using The DesignTimeBindingContextAttribute It's possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To do so, begin by adding the following code file to your project: DesignTimeBindingContextAttribute.cs using System; namespace MyApp.Attributes { /// <summary> /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class DesignTimeBindingContextAttribute : Attribute { /// <summary> /// Specifies the design time binding context using a fully qualified type name. /// /// For example: MyApp.ViewModels.LoginViewModel. /// </summary> /// <param name= \"typeName\" > The fully qualified type name for the design time binding context. </param> public DesignTimeBindingContextAttribute(string typeName) { } /// <summary> /// Specifies the design time binding context using typeof(). /// /// For example: typeof(LoginViewModel) /// </summary> /// <param name= \"type\" > The <see cref= \"System.Type\" /> for the design time binding context, using typeof(). </param> public DesignTimeBindingContextAttribute(Type type) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/#using-the-designtimebindingcontextattribute","text":"It's possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To do so, begin by adding the following code file to your project: DesignTimeBindingContextAttribute.cs using System; namespace MyApp.Attributes { /// <summary> /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context. /// </summary> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class DesignTimeBindingContextAttribute : Attribute { /// <summary> /// Specifies the design time binding context using a fully qualified type name. /// /// For example: MyApp.ViewModels.LoginViewModel. /// </summary> /// <param name= \"typeName\" > The fully qualified type name for the design time binding context. </param> public DesignTimeBindingContextAttribute(string typeName) { } /// <summary> /// Specifies the design time binding context using typeof(). /// /// For example: typeof(LoginViewModel) /// </summary> /// <param name= \"type\" > The <see cref= \"System.Type\" /> for the design time binding context, using typeof(). </param> public DesignTimeBindingContextAttribute(Type type) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/overview/","text":"Binding Context Resolution MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article. Resolution Methods MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/overview/#binding-context-resolution","text":"MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article.","title":"Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/overview/#resolution-methods","text":"MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Resolution Methods"},{"location":"xamarin-forms/colors/adornments/","text":"Visually preview color values inline in the XAML editor Introduction One of the challenges of working with colors in Xamarin.Forms Color Adornments Performance Impacts By default, color adornments are not enabled for the XAML editor. Due to rendering constraints, color adornments can have an adverse impact on IntelliSense performance. To enable color adornments, open MFractors Preferences and then go to Settings -> Feature Flags and toggle Color Adornments . Hex Color Adornments When MFractor detects a hexadecimal color declaration, it will evaluate that color and inject a small preview of that color: Named Color Adornments When MFractor detects a color attribute that assigns a named color constant (such as Red, SlateBlue, Green etc), it will evaluate the named color and inject a small preview of that color: Static Resource Color Adornments When MFractor detects a static resource expression that returns a color resource, it will evaluate the static resource and inject a small preview of the declared color:","title":"Adornments"},{"location":"xamarin-forms/colors/adornments/#introduction","text":"One of the challenges of working with colors in Xamarin.Forms Color Adornments Performance Impacts By default, color adornments are not enabled for the XAML editor. Due to rendering constraints, color adornments can have an adverse impact on IntelliSense performance. To enable color adornments, open MFractors Preferences and then go to Settings -> Feature Flags and toggle Color Adornments .","title":"Introduction"},{"location":"xamarin-forms/colors/adornments/#hex-color-adornments","text":"When MFractor detects a hexadecimal color declaration, it will evaluate that color and inject a small preview of that color:","title":"Hex Color Adornments"},{"location":"xamarin-forms/colors/adornments/#named-color-adornments","text":"When MFractor detects a color attribute that assigns a named color constant (such as Red, SlateBlue, Green etc), it will evaluate the named color and inject a small preview of that color:","title":"Named Color Adornments"},{"location":"xamarin-forms/colors/adornments/#static-resource-color-adornments","text":"When MFractor detects a static resource expression that returns a color resource, it will evaluate the static resource and inject a small preview of the declared color:","title":"Static Resource Color Adornments"},{"location":"xamarin-forms/colors/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/colors/color-analysis/","text":"Inspect XAML color properties to validate color format and suggest refactorings for better organizing your color assets. Introduction MFractor includes several code analysers to aid on managing the colors in your Xamarin.Forms projects. Those analysers are applied to active XAML documents on the editor and will check any property of the Xamarin.Forms.Color Struct , including any custom or third-party component types. Color analysers helps you with the following types of issues and enhancements: Check for mispelled hex color formats. Check for mispelled color values. Identify colors declared as static resources. Identifying mispelled hex color formats Xamarin.Forms Color Type allows passing a hexadecimal color value in several different formats: #RRGGBB : A color with 32 bit (00-FF) Red, Green and Blue channels. #AARRGGBB : A color with 32 bit (00-FF) Alpha, Red, Green and Blue channels. #RGB : A color with 16 bit (0-F) Red, Green and Blue channels. #ARGB : A color with 16 bit (0-F) Alpha, Red, Green and Blue channels. The color code analysis will check for values begining with an # to verify if they fall on one of above supported formats. If a mispelling format is identified an warning will be shown to the editor. The warning tooltip allows you to invoke the Color Picker tool to pick a valid value for your property: The color picker is a very useful tool for quickly setting a valid color value. You can iterate to it by dragging the Red , Blue , Green and Alpha channels sliders or by directly typing an integer value to its respective boxes. The picker will try to identify an existing named color (one of the static read-only fields declared in the Xamarin.Forms.Color struct ) for the RGB value set, or you can also type one of those suggestions to imediately get the channels filled. By setting a color in the picker and clicking choose, MFractor will set the new value to the property. If the value represents one of the named colors this value will be used instead of the hex value. Example : type brown on the Color field and the picker channels will be automatically set to red 165, Green 42, Blue 42 and Alpha 255 that represents Color.Brown field value of #FFA52A2A . Fixing Mispelled Named Colors Visual Studio provides completion for the named colors on properties of the Color type, even though, typos may happen. This code analysis checks for non-hex values typed on the color properties and suggests fixes to similar named colors. Suppose you have a color property with value of Blu . This is an invalid color value because it doesn't represent a valid named color, nor a hex value and neither a resource reference. This will be thrown as an error at compile time, but with the MFractor code analysis you can identify this issue as you edit your file and get suggestions to quickly fix the issue: By hovering over the typo, the code analysis tooltip will show suggestions of names that closely match the mispelled one. Just click the link to have an instant fix. Applying Named Color to Equivalent hex value Hex values are a useful way of representing and sharing color value, but you can't easily figure a color value just by looking at it (unless you're a very experienced designer). For this reason, its useful to have named colors when they apply, so we can quickly identify what the color value is. This code analysis will check Color properties that has hex values declared to verify if they match one of the named colors available. Suppose you have an element that declares a color with the value #F5F5DC which matches to the Color.Beige named color. A warning will be shown to the color declaration to suggest replacing with the named version: Applying an Existing Color Resource Its a common pattern to set theme Color values at the Resources of the App.xaml file of a Xamarin.Forms project. MFractor can identify if an explicity hex value set to a color property matches an existing resource at any level it could be declared. Suppose you a have a Color entry for the primary color of your app theme, like below: <ResourceDictionary> <Color x:Key= \"primaryColor\" > #7BCCE5 </Color> </ResourceDictionary> At another part of the code, you add an item that will apply this color value, but you didn't remember about the Color resource you've declared before, and you simply copy the hex value over from your style guide: <BoxView Color= \"#7BCCE5\" /> If you hover over the squiggles of the code analysis warning, you'll find information about the existing static resource that matches the hex value you've just typed. You can click on the link for applying the change reference the resource. The color value will be replaced with the reference to the static resource: <BoxView Color= \"{StaticResource primaryColor}\" />","title":"Color Analysis"},{"location":"xamarin-forms/colors/color-analysis/#introduction","text":"MFractor includes several code analysers to aid on managing the colors in your Xamarin.Forms projects. Those analysers are applied to active XAML documents on the editor and will check any property of the Xamarin.Forms.Color Struct , including any custom or third-party component types. Color analysers helps you with the following types of issues and enhancements: Check for mispelled hex color formats. Check for mispelled color values. Identify colors declared as static resources.","title":"Introduction"},{"location":"xamarin-forms/colors/color-analysis/#identifying-mispelled-hex-color-formats","text":"Xamarin.Forms Color Type allows passing a hexadecimal color value in several different formats: #RRGGBB : A color with 32 bit (00-FF) Red, Green and Blue channels. #AARRGGBB : A color with 32 bit (00-FF) Alpha, Red, Green and Blue channels. #RGB : A color with 16 bit (0-F) Red, Green and Blue channels. #ARGB : A color with 16 bit (0-F) Alpha, Red, Green and Blue channels. The color code analysis will check for values begining with an # to verify if they fall on one of above supported formats. If a mispelling format is identified an warning will be shown to the editor. The warning tooltip allows you to invoke the Color Picker tool to pick a valid value for your property: The color picker is a very useful tool for quickly setting a valid color value. You can iterate to it by dragging the Red , Blue , Green and Alpha channels sliders or by directly typing an integer value to its respective boxes. The picker will try to identify an existing named color (one of the static read-only fields declared in the Xamarin.Forms.Color struct ) for the RGB value set, or you can also type one of those suggestions to imediately get the channels filled. By setting a color in the picker and clicking choose, MFractor will set the new value to the property. If the value represents one of the named colors this value will be used instead of the hex value. Example : type brown on the Color field and the picker channels will be automatically set to red 165, Green 42, Blue 42 and Alpha 255 that represents Color.Brown field value of #FFA52A2A .","title":"Identifying mispelled hex color formats"},{"location":"xamarin-forms/colors/color-analysis/#fixing-mispelled-named-colors","text":"Visual Studio provides completion for the named colors on properties of the Color type, even though, typos may happen. This code analysis checks for non-hex values typed on the color properties and suggests fixes to similar named colors. Suppose you have a color property with value of Blu . This is an invalid color value because it doesn't represent a valid named color, nor a hex value and neither a resource reference. This will be thrown as an error at compile time, but with the MFractor code analysis you can identify this issue as you edit your file and get suggestions to quickly fix the issue: By hovering over the typo, the code analysis tooltip will show suggestions of names that closely match the mispelled one. Just click the link to have an instant fix.","title":"Fixing Mispelled Named Colors"},{"location":"xamarin-forms/colors/color-analysis/#applying-named-color-to-equivalent-hex-value","text":"Hex values are a useful way of representing and sharing color value, but you can't easily figure a color value just by looking at it (unless you're a very experienced designer). For this reason, its useful to have named colors when they apply, so we can quickly identify what the color value is. This code analysis will check Color properties that has hex values declared to verify if they match one of the named colors available. Suppose you have an element that declares a color with the value #F5F5DC which matches to the Color.Beige named color. A warning will be shown to the color declaration to suggest replacing with the named version:","title":"Applying Named Color to Equivalent hex value"},{"location":"xamarin-forms/colors/color-analysis/#applying-an-existing-color-resource","text":"Its a common pattern to set theme Color values at the Resources of the App.xaml file of a Xamarin.Forms project. MFractor can identify if an explicity hex value set to a color property matches an existing resource at any level it could be declared. Suppose you a have a Color entry for the primary color of your app theme, like below: <ResourceDictionary> <Color x:Key= \"primaryColor\" > #7BCCE5 </Color> </ResourceDictionary> At another part of the code, you add an item that will apply this color value, but you didn't remember about the Color resource you've declared before, and you simply copy the hex value over from your style guide: <BoxView Color= \"#7BCCE5\" /> If you hover over the squiggles of the code analysis warning, you'll find information about the existing static resource that matches the hex value you've just typed. You can click on the link for applying the change reference the resource. The color value will be replaced with the reference to the static resource: <BoxView Color= \"{StaticResource primaryColor}\" />","title":"Applying an Existing Color Resource"},{"location":"xamarin-forms/colors/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/","text":"Generate the C# code to declare a new attached property declaration Introduction In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached(\"HasShadow\", typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example <Label local:MyClass.HasShadow=\"true\"/> One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Attached Property Wizard To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#introduction","text":"In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached(\"HasShadow\", typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example <Label local:MyClass.HasShadow=\"true\"/> One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#using-the-attached-property-wizard","text":"To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#automatic-type-inference","text":"The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/","text":"Generate the C# code to declare a new bindable property for a custom control Introduction When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get => (bool)GetValue(HasShadowProperty); set => SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Bindable Property Wizard To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#introduction","text":"When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get => (bool)GetValue(HasShadowProperty); set => SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#using-the-bindable-property-wizard","text":"To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#automatic-type-inference","text":"One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/","text":"Move a XAML layout usage into its own reusable custom control Introduction When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control. Using The Extract Control Refactoring To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Extracting Custom Controls"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#introduction","text":"When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#using-the-extract-control-refactoring","text":"To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Using The Extract Control Refactoring"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/","text":"Quickly find custom renderers for Xamarin.Forms visual elements Introduction MFractor allows you to quickly find and list custom renders declared for Xamarin.Forms view components and navigate to its source code. Using the Code Action Info Check the Code Actions docs for details about how to invoke the Code Actions in Visual Studio for either C# or XAML code. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Building on the example of the previous topic, Generate Custom Handlers , where we've created a Custom Renderer for the EnhancedButton class, that derives from the Button class, we can open it's source code and right click over the symbol name. The option Find Custom Renderers will appear below the Find Refereces : This option can also be accessed from the quick fix menu, by invoking the Option + Enter keyboard shortcut or clicking on the screwdriver icon on the left of the current line: And it's also available in XAML files by right clicking on any element: MFractor will search in the projects that refereces the curret if there are renderers declared for this type and will present a list in the Search Results pad of Visual Studio: If no Renderers are found for the element you'll receive a message on the status bar: By using this feature you can quickly identify all the custom renderers declared for the component, and quickly navigate to its source code. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Find Custom Renderers"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/#introduction","text":"MFractor allows you to quickly find and list custom renders declared for Xamarin.Forms view components and navigate to its source code.","title":"Introduction"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/#using-the-code-action","text":"Info Check the Code Actions docs for details about how to invoke the Code Actions in Visual Studio for either C# or XAML code. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Building on the example of the previous topic, Generate Custom Handlers , where we've created a Custom Renderer for the EnhancedButton class, that derives from the Button class, we can open it's source code and right click over the symbol name. The option Find Custom Renderers will appear below the Find Refereces : This option can also be accessed from the quick fix menu, by invoking the Option + Enter keyboard shortcut or clicking on the screwdriver icon on the left of the current line: And it's also available in XAML files by right clicking on any element: MFractor will search in the projects that refereces the curret if there are renderers declared for this type and will present a list in the Search Results pad of Visual Studio: If no Renderers are found for the element you'll receive a message on the status bar: By using this feature you can quickly identify all the custom renderers declared for the component, and quickly navigate to its source code. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Using the Code Action"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/","text":"Quickly generate custom renderers for Xamarin.Forms visual elements Introduction MFractor allows you to quickly create the stubs for implementing a custom renderer for a Xamarin.Forms element using a Code Action that can be applied to your custom View Components. When invoked it will create the renderer class stubs in each of the selected projects including the proper export attributes. Using the Code Action Info Check the C# Code Actions docs for details about how to invoke the Code Actions. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Suppose you want to create an enhanced button component that implements a platform specific feature of Android or iOS native button components. You can start by creating a new class that derives from Button , such as: using System ; using Xamarin.Forms ; namespace MFractor.Samples.Views { public class EnhancedButton : Button { public EnhancedButton () { } } } Place the cursor over the class name declaration and use the shortcuts to invoke the list of available Code Actions. The Generat custom renderers for EnhancedButton should be available to this list: Invoking it will present the Generate Custom Renderers dialog: MFractor will identify the projects that has dependencies on the Xamarin.Forms project where the component is declared and add to this to allow selecting the ones to which you want to create the renderers. In the example above, there are an Android and an iOS project. When you confirm the selection the following files will be created: Android Code Template Defaults to Renderers/EnhancedButtonRenderer.cs . using System.ComponentModel ; using Android.Content ; using MFractor.Samples.Droid.Renderers ; using MFractor.Samples.Views ; using Xamarin.Forms.Platform.Android ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.Droid.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; public EnhancedButtonRenderer ( Context context ) : base ( context ) { } protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } iOS Code Template Defaults to: Renderers/EnhancedButtonRenderer.cs using System.ComponentModel ; using MFractor.Samples.iOS.Renderers ; using MFractor.Samples.Views ; using UIKit ; using Xamarin.Forms.Platform.iOS ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.iOS.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } This is the complete stubs for writing a renderer, including the ExportRenderer declaration. All you need to is implement the OnElementChanged and OnElementPropertyChanged custom logic and use your new component on your forms pages. Notice that MFractor will automatically resolve to the base class Renderer, so you don't need to bother about finding what is the correct native renderer to derive. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"Generate Custom Renderers"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#introduction","text":"MFractor allows you to quickly create the stubs for implementing a custom renderer for a Xamarin.Forms element using a Code Action that can be applied to your custom View Components. When invoked it will create the renderer class stubs in each of the selected projects including the proper export attributes.","title":"Introduction"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#using-the-code-action","text":"Info Check the C# Code Actions docs for details about how to invoke the Code Actions. This Code Action can be applied to any type derived from Page , Layout , View or Cell types of the Xamarin.Forms package. Suppose you want to create an enhanced button component that implements a platform specific feature of Android or iOS native button components. You can start by creating a new class that derives from Button , such as: using System ; using Xamarin.Forms ; namespace MFractor.Samples.Views { public class EnhancedButton : Button { public EnhancedButton () { } } } Place the cursor over the class name declaration and use the shortcuts to invoke the list of available Code Actions. The Generat custom renderers for EnhancedButton should be available to this list: Invoking it will present the Generate Custom Renderers dialog: MFractor will identify the projects that has dependencies on the Xamarin.Forms project where the component is declared and add to this to allow selecting the ones to which you want to create the renderers. In the example above, there are an Android and an iOS project. When you confirm the selection the following files will be created:","title":"Using the Code Action"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#android-code-template","text":"Defaults to Renderers/EnhancedButtonRenderer.cs . using System.ComponentModel ; using Android.Content ; using MFractor.Samples.Droid.Renderers ; using MFractor.Samples.Views ; using Xamarin.Forms.Platform.Android ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.Droid.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; public EnhancedButtonRenderer ( Context context ) : base ( context ) { } protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } }","title":"Android Code Template"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/#ios-code-template","text":"Defaults to: Renderers/EnhancedButtonRenderer.cs using System.ComponentModel ; using MFractor.Samples.iOS.Renderers ; using MFractor.Samples.Views ; using UIKit ; using Xamarin.Forms.Platform.iOS ; using Xamarin.Forms ; [assembly: ExportRenderer (typeof(EnhancedButton), typeof(EnhancedButtonRenderer))] namespace MFractor.Samples.iOS.Renderers { public class EnhancedButtonRenderer : ButtonRenderer { public EnhancedButton EnhancedButton => Element as EnhancedButton ; protected override void OnElementChanged ( ElementChangedEventArgs < Xamarin . Forms . Button > e ) { base . OnElementChanged ( e ); } protected override void OnElementPropertyChanged ( object sender , PropertyChangedEventArgs e ) { base . OnElementPropertyChanged ( sender , e ); } } } This is the complete stubs for writing a renderer, including the ExportRenderer declaration. All you need to is implement the OnElementChanged and OnElementPropertyChanged custom logic and use your new component on your forms pages. Notice that MFractor will automatically resolve to the base class Renderer, so you don't need to bother about finding what is the correct native renderer to derive. Tip For more information about implement Custom Renderers for Views in Xamarin.Forms see the official docs .","title":"iOS Code Template"},{"location":"xamarin-forms/data-triggers/analysis/","text":"Verifying the usage of triggers Introduction This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Analysis"},{"location":"xamarin-forms/data-triggers/analysis/#introduction","text":"This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/data-triggers/intellisense/","text":"Verify the Introduction This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Intellisense"},{"location":"xamarin-forms/data-triggers/intellisense/#introduction","text":"This documentation article outlines the XAML analysers refactorings provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/data-triggers/overview/","text":"Use data triggers to change the appearance of your XAML in response to events or state changes Introduction","title":"Overview"},{"location":"xamarin-forms/data-triggers/overview/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/data-triggers/overview/#_1","text":"","title":""},{"location":"xamarin-forms/dynamic-resources/intellisense/","text":"Code completion for the dynamic resources available in an application","title":"Intellisense"},{"location":"xamarin-forms/dynamic-resources/navigation/","text":"Navigate to the source code location of a dynamic resource Introduction Resolving By ExportFontAttribute","title":"Navigation"},{"location":"xamarin-forms/dynamic-resources/navigation/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/navigation/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/dynamic-resources/search/","text":"Use global search to locate a specific dynamic resource Introduction Resolving By ExportFontAttribute","title":"Search"},{"location":"xamarin-forms/dynamic-resources/search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/search/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/dynamic-resources/tooltips/","text":"Preview the result of a dynamic resource expression through tooltips Introduction Resolving By ExportFontAttribute","title":"Tooltips"},{"location":"xamarin-forms/dynamic-resources/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/dynamic-resources/tooltips/#resolving-by-exportfontattribute","text":"","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/fonts/code-completion/","text":"Completion for font assets in a Xamarin.Forms project and for glyphs within a font asset Introduction When working with font icons in Xamarin.Forms, it's difficult to discover the icons that are available within a font asset. To assist with working with font icons in XAML, MFractor provides code completion and previews the fonts declared through an ExportFontAttribute and for all named glyphs within a font asset. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Embedded Fonts Completion When your project has declared embedded font resources using the ExportFontAttribute , these font assets will be suggested in IntelliSense when editing the FontFamily attribute. Font Glyph Code Completion To access font glyph tooltips, ensure that the element applies a valid font asset to its FontFamily property. To access the list of available glyphs in a font asset, start typing in any property for that element that is a string . MFractor will suggest all font icons available in the referenced font by name and display a preview of that icon. To apply a completion, type the name of an icon or select it in the completion window, and press enter. MFractor will then insert the escaped unicode character reference: Desktop Fonts vs Web Fonts MFractor can only provide glyph code completion when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If no glyphs are suggested, please ensure that your font asset is a web font.","title":"Code Completion"},{"location":"xamarin-forms/fonts/code-completion/#introduction","text":"When working with font icons in Xamarin.Forms, it's difficult to discover the icons that are available within a font asset. To assist with working with font icons in XAML, MFractor provides code completion and previews the fonts declared through an ExportFontAttribute and for all named glyphs within a font asset. Please see the FontFamily resolution article to understand how MFractor resolves your font assets","title":"Introduction"},{"location":"xamarin-forms/fonts/code-completion/#embedded-fonts-completion","text":"When your project has declared embedded font resources using the ExportFontAttribute , these font assets will be suggested in IntelliSense when editing the FontFamily attribute.","title":"Embedded Fonts Completion"},{"location":"xamarin-forms/fonts/code-completion/#font-glyph-code-completion","text":"To access font glyph tooltips, ensure that the element applies a valid font asset to its FontFamily property. To access the list of available glyphs in a font asset, start typing in any property for that element that is a string . MFractor will suggest all font icons available in the referenced font by name and display a preview of that icon. To apply a completion, type the name of an icon or select it in the completion window, and press enter. MFractor will then insert the escaped unicode character reference: Desktop Fonts vs Web Fonts MFractor can only provide glyph code completion when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If no glyphs are suggested, please ensure that your font asset is a web font.","title":"Font Glyph Code Completion"},{"location":"xamarin-forms/fonts/font-family-resolution/","text":"An overview of how MFractor resolves fonts for IntelliSense and tooltips Introduction When working with custom fonts in XAML, MFractor can suggest the available glyphs in a font asset and also preview that glyph via a tooltip. This article outlines how MFractor will resolve your font asset. To accomplish this, MFractor will resolve the font asset referenced by a particular element. This is accomplished via three methods: Resolving the FontFamily through fonts defined by the ExportFontAttribute . Resolving the FontFamily static resource. Resolving the FontFamily via the elements style. Resolving By ExportFontAttribute One of the major features added in Xamarin.Forms 4.5 was EmbeddedFonts ; the ability to include a font asset as an EmbeddedResource in your code project and then use the ExportFontAttribute to expose it to Xamarin.Forms. Example: [assembly: ExportFont(\"FontAwesome.ttf\")] In XAML, we can now reference this font by name (with or without the file extension): <Label FontFamily=\"FontAwesome\"/> <Label FontFamily=\"FontAwesome.ttf\"/> When MFractor encounters a FontFamily that is not a static resource expression, it will inspect the assembly for ExportFontAttribute 's and match the defined font family with either the ExportFontAttribute.FontFileName or ExportFontAttribute.Alias value. Resolving By Static Resource When using custom fonts in XAML, a common method to reference a font is with a static resource expression that returns a string OnPlatform that returns the font for each platform. Consider the following font reference: <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"FontAwesome5ProRegular\" > <On Platform= \"iOS\" Value= \"FontAwesome5Pro-Regular\" /> <On Platform= \"Android\" Value= \"FontAwesomeRegular.ttf#Regular\" /> <On Platform= \"UWP\" Value= \"/Assets/Fonts/FontAwesomeRegular.ttf#Font Awesome 5 Pro\" /> </OnPlatform> <Label FontFamily= \"{StaticResource FontAwesome5ProRegular}\" /> In this OnPlatform , we reference the font asset by its postscript name, FontAwesome5Pro-Regular , on iOS . on Android via the asset name and font style FontAwesomeRegular.ttf#Regular and on UWP by its assets path plus the typographic family name. When MFractor encounters a FontFamily that references an OnPlatform that returns a string, it evaluates the expression to discover the iOS/Android font asset and then attempts to load that font asset. Resolving By Style MFractor can also resolve the font family declared by a style. Consider the following style declaration: <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"FontAwesome5ProRegular\" > <On Platform= \"iOS\" Value= \"FontAwesome5Pro-Regular\" /> <On Platform= \"Android\" Value= \"FontAwesomeRegular.ttf#Regular\" /> </OnPlatform> <Style x:Key= \"labelStyle\" TargetType= \"Label\" FontFamily= \"{StaticResource FontAwesome5ProRegular}\" <Label Style= \"{StaticResource labelStyle}\" /> As the Label does not use the FontFamily property, MFractor then tries to locate the Style property. If successful, MFractor evaluates that style expression, locates the FontFamily declared by the style and then evaluates the content of setter as per Resolving By Static Resource .","title":"FontFamily Resolution"},{"location":"xamarin-forms/fonts/font-family-resolution/#introduction","text":"When working with custom fonts in XAML, MFractor can suggest the available glyphs in a font asset and also preview that glyph via a tooltip. This article outlines how MFractor will resolve your font asset. To accomplish this, MFractor will resolve the font asset referenced by a particular element. This is accomplished via three methods: Resolving the FontFamily through fonts defined by the ExportFontAttribute . Resolving the FontFamily static resource. Resolving the FontFamily via the elements style.","title":"Introduction"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-exportfontattribute","text":"One of the major features added in Xamarin.Forms 4.5 was EmbeddedFonts ; the ability to include a font asset as an EmbeddedResource in your code project and then use the ExportFontAttribute to expose it to Xamarin.Forms. Example: [assembly: ExportFont(\"FontAwesome.ttf\")] In XAML, we can now reference this font by name (with or without the file extension): <Label FontFamily=\"FontAwesome\"/> <Label FontFamily=\"FontAwesome.ttf\"/> When MFractor encounters a FontFamily that is not a static resource expression, it will inspect the assembly for ExportFontAttribute 's and match the defined font family with either the ExportFontAttribute.FontFileName or ExportFontAttribute.Alias value.","title":"Resolving By ExportFontAttribute"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-static-resource","text":"When using custom fonts in XAML, a common method to reference a font is with a static resource expression that returns a string OnPlatform that returns the font for each platform. Consider the following font reference: <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"FontAwesome5ProRegular\" > <On Platform= \"iOS\" Value= \"FontAwesome5Pro-Regular\" /> <On Platform= \"Android\" Value= \"FontAwesomeRegular.ttf#Regular\" /> <On Platform= \"UWP\" Value= \"/Assets/Fonts/FontAwesomeRegular.ttf#Font Awesome 5 Pro\" /> </OnPlatform> <Label FontFamily= \"{StaticResource FontAwesome5ProRegular}\" /> In this OnPlatform , we reference the font asset by its postscript name, FontAwesome5Pro-Regular , on iOS . on Android via the asset name and font style FontAwesomeRegular.ttf#Regular and on UWP by its assets path plus the typographic family name. When MFractor encounters a FontFamily that references an OnPlatform that returns a string, it evaluates the expression to discover the iOS/Android font asset and then attempts to load that font asset.","title":"Resolving By Static Resource"},{"location":"xamarin-forms/fonts/font-family-resolution/#resolving-by-style","text":"MFractor can also resolve the font family declared by a style. Consider the following style declaration: <OnPlatform x:TypeArguments= \"x:String\" x:Key= \"FontAwesome5ProRegular\" > <On Platform= \"iOS\" Value= \"FontAwesome5Pro-Regular\" /> <On Platform= \"Android\" Value= \"FontAwesomeRegular.ttf#Regular\" /> </OnPlatform> <Style x:Key= \"labelStyle\" TargetType= \"Label\" FontFamily= \"{StaticResource FontAwesome5ProRegular}\" <Label Style= \"{StaticResource labelStyle}\" /> As the Label does not use the FontFamily property, MFractor then tries to locate the Style property. If successful, MFractor evaluates that style expression, locates the FontFamily declared by the style and then evaluates the content of setter as per Resolving By Static Resource .","title":"Resolving By Style"},{"location":"xamarin-forms/fonts/tooltips/","text":"Visually previewing glyphs from a font with glyph tooltips Introduction When working with font icons in Xamarin.Forms, one of the challenges is understanding what a particular glyph code references. Consider the following XAML code: <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\" Text=\"&#xf00c;\" This Label uses the &#xf00c; icon from the FontAwesome5ProRegular font asset. From a maintainability perspective, it's very difficult for a developer to understand what the icon code &#xf00c; refers to. To make it easier to understand what a particular references, MFractor include glyph tooltips. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Desktop Fonts vs Web Fonts MFractor can only provide glyph previews when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If glyph tooltips do not appear, please ensure that your font asset is a web font. Font Glyph Code Tooltips To access font glyph tooltips, hover over a font glyph code in XAML: x:Static Constant tooltips If you are using a font named constants class to reference font icons, MFractor can also preview these as tooltips. To access, hover over an x:Static expression that references a font character code:","title":"Tooltips"},{"location":"xamarin-forms/fonts/tooltips/#introduction","text":"When working with font icons in Xamarin.Forms, one of the challenges is understanding what a particular glyph code references. Consider the following XAML code: <Label FontFamily=\"{StaticResource FontAwesome5ProRegular}\" Text=\"&#xf00c;\" This Label uses the &#xf00c; icon from the FontAwesome5ProRegular font asset. From a maintainability perspective, it's very difficult for a developer to understand what the icon code &#xf00c; refers to. To make it easier to understand what a particular references, MFractor include glyph tooltips. Please see the FontFamily resolution article to understand how MFractor resolves your font assets Desktop Fonts vs Web Fonts MFractor can only provide glyph previews when the referenced font asset is a web font. Desktop fonts do not contain the meta-data that associates a glyph name to its icon code. If glyph tooltips do not appear, please ensure that your font asset is a web font.","title":"Introduction"},{"location":"xamarin-forms/fonts/tooltips/#font-glyph-code-tooltips","text":"To access font glyph tooltips, hover over a font glyph code in XAML:","title":"Font Glyph Code Tooltips"},{"location":"xamarin-forms/fonts/tooltips/#xstatic-constant-tooltips","text":"If you are using a font named constants class to reference font icons, MFractor can also preview these as tooltips. To access, hover over an x:Static expression that references a font character code:","title":"x:Static Constant tooltips"},{"location":"xamarin-forms/grids/adornments/","text":"Easily see the row/column index of a grid alongside its declaration Introduction Grids are a powerful layout provided by Xamarin.Forms that enables developers to build complex, overlapping layouts. When we work with Grids in XAML, we use row and column definitions to define our the grid should layout our elements. These rows/columns are then referenced by index like so: Grid.Row=\"0\" This introduces a problem; we now need to know the index of each row and column in order to place our elements in the right position. This means we either need to count the rows/column and/or maintain a comment for each row/column that indicates it index. To address this problem, MFractor injects the index of the row/column alongside its declaration. This allows use to instantly see the index for a given row or column. Row And Column Adornments Grid row and column adornments are automatically added to the start of row or column defintion. RowDefinitions ColumnDefinitions Click To Copy Grid Row/Column To quickly get the XAML code to reference a given row or column, simply click on the adornment and MFractor will place the code into your clipboard. Disabling Grid Adornments If you notice adverse performance impacts when editing XAML files, please try disabling grid adornments. To do so, open MFractors preferences menu and under Settings -> Feature Flags , disable the Grid Adornments option. After changing this setting, please close and reopen any XAML files for the change to take affect.","title":"Adornments"},{"location":"xamarin-forms/grids/adornments/#introduction","text":"Grids are a powerful layout provided by Xamarin.Forms that enables developers to build complex, overlapping layouts. When we work with Grids in XAML, we use row and column definitions to define our the grid should layout our elements. These rows/columns are then referenced by index like so: Grid.Row=\"0\" This introduces a problem; we now need to know the index of each row and column in order to place our elements in the right position. This means we either need to count the rows/column and/or maintain a comment for each row/column that indicates it index. To address this problem, MFractor injects the index of the row/column alongside its declaration. This allows use to instantly see the index for a given row or column.","title":"Introduction"},{"location":"xamarin-forms/grids/adornments/#row-and-column-adornments","text":"Grid row and column adornments are automatically added to the start of row or column defintion. RowDefinitions ColumnDefinitions","title":"Row And Column Adornments"},{"location":"xamarin-forms/grids/adornments/#click-to-copy-grid-rowcolumn","text":"To quickly get the XAML code to reference a given row or column, simply click on the adornment and MFractor will place the code into your clipboard.","title":"Click To Copy Grid Row/Column"},{"location":"xamarin-forms/grids/adornments/#disabling-grid-adornments","text":"If you notice adverse performance impacts when editing XAML files, please try disabling grid adornments. To do so, open MFractors preferences menu and under Settings -> Feature Flags , disable the Grid Adornments option. After changing this setting, please close and reopen any XAML files for the change to take affect.","title":"Disabling Grid Adornments"},{"location":"xamarin-forms/grids/analysis/","text":"Inspects XAML Grid child elements to identify if positioning or span is out of boundarys. Introduction Grids are one of the most versatile and used layouts provided by Xamarin.Forms. Despite being easy to use, it sometimes hard to keep track of its child elements. MFractor introduces a few Grid Code Analysis to aid on composing your layouts. Row and Column Analysis Those Code Analysis are applied to the Grid.Row and Grid.Column attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element position to check if it's within it's defined bounds. Row Outside Grid Boundary If a Grid.Row definition is beyond the Rows Definitions of the parent Grid, MFractor will show a warning for the faulty location: Column Outside Grid Boundary If a Grid.Column definition is beyond the Columns Definitions of the parent Grid, MFractor will show a warning for the faulty location: Row and Column Span Analysis Those Code Analysis are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element that declares spans to check if they doesn't go beyond the defined bounds. Row Span Outside Grid Boundary If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size: Column Span Outside Grid Boundary If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size:","title":"Grid Analysis"},{"location":"xamarin-forms/grids/analysis/#introduction","text":"Grids are one of the most versatile and used layouts provided by Xamarin.Forms. Despite being easy to use, it sometimes hard to keep track of its child elements. MFractor introduces a few Grid Code Analysis to aid on composing your layouts.","title":"Introduction"},{"location":"xamarin-forms/grids/analysis/#row-and-column-analysis","text":"Those Code Analysis are applied to the Grid.Row and Grid.Column attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element position to check if it's within it's defined bounds.","title":"Row and Column Analysis"},{"location":"xamarin-forms/grids/analysis/#row-outside-grid-boundary","text":"If a Grid.Row definition is beyond the Rows Definitions of the parent Grid, MFractor will show a warning for the faulty location:","title":"Row Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#column-outside-grid-boundary","text":"If a Grid.Column definition is beyond the Columns Definitions of the parent Grid, MFractor will show a warning for the faulty location:","title":"Column Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#row-and-column-span-analysis","text":"Those Code Analysis are applied to the Grid.RowSpan and Grid.ColumnSpan attached properties applied to the child element of a Grid. MFractor inspects the rows and columns definitions of the Grid and check each child element that declares spans to check if they doesn't go beyond the defined bounds.","title":"Row and Column Span Analysis"},{"location":"xamarin-forms/grids/analysis/#row-span-outside-grid-boundary","text":"If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size:","title":"Row Span Outside Grid Boundary"},{"location":"xamarin-forms/grids/analysis/#column-span-outside-grid-boundary","text":"If a Grid.RowSpan definition goes beyond the Rows Definitions from the current Row where the element is placed, MFractor will show a warning for the faulty span size:","title":"Column Span Outside Grid Boundary"},{"location":"xamarin-forms/grids/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/","text":"Quickly convert a StackLayout to a Grid for refactoring and expanding your layout. Introduction StackLayout is one of the basic layouts provided by Xamarin.Forms and is a common starting point when composing a new view, being fast and easy to use. But it's common to transform a StackLayout into a Grid when the layout starts to become complex, or you need to rethink it to have new column or row. MFractor makes easy to convert an existing StackLayout into a Grid with the adequate rows and columns definitions and its elements in place. Using the Converter The Convert StackLayout to Grid tool is presented as a XAML Code Action. The option becomes available to the Refactor menu on the Context Menu of a StackLayout element. Consider a layout for reporting progress to the user. It's composed of an ActivityIndicator , a Label and Button stacked vertically: <StackLayout> <ActivityIndicator IsRunning= \"True\" /> <Label HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button HorizontalOptions= \"Center\" Text= \"Cancel\" /> </StackLayout> We may want to transform it into a Grid , so we can add a second column to add new button button to right of the current one. Right-click on the StackLayout element and on the context menu you should find the option Convert StackLayout to Grid on the Refactor menu: In Visual Studio for Windows this code action will appear in the quick fix menu, the little screwdriver icon that appears to the left of the current line being edited. If you place the cursor under a StackLayout declaration and click on the icon or use the Ctrl + . keyboard shortcut, the option will appear o the menu: Note The current verison of MFractor for Visual Studio Mac doe not support quick fix actions in XAML, however, this feature should be available in a future version. By applying this code action, your StackLayout declaration will be transformed into an equivalent Grid declaration, just like below: <Grid HorizontalOptions= \"Center\" VerticalOptions= \"Center\" Padding= \"12\" > <Grid.RowDefinitions> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> </Grid.RowDefinitions> <ActivityIndicator Grid.Row= \"0\" IsRunning= \"True\" /> <Label Grid.Row= \"1\" HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button Grid.Row= \"2\" HorizontalOptions= \"Center\" Text= \"Cancel\" /> </Grid> The conversion to Grid will keep all the properties previously applied to the StackLayout on the trasformed grid declaration. Depending on the Orientation property, the ColumnsDefinitions or RowDefinitions will be created to match the number of elements in the stack. For Vertical (the default) stacks row definitions will be created and for Horizontal column definitions will be created. The conversion will also add the correspondent Grid.Column or Grid.Row properties on the child elements. The conversion will also verify the VerticalOptions (for vertical stacks) or HorizontalOptions (for horizontal stacks) Exapnsion option of each child element to determine the column width or row height of its corresponding position: For elements that Expand , the row or column defitinion will apply the * size For elements that doesn't declare the Expand, the row or column defiition will apply the Auto size Note There's no reverse operation of StackLayout to Grid conversion. If you need to revert the operation you should use the Undo command of the editor. We recommend that you keep a history of your source code so you can track back after the conversion if you need.","title":"Convert StackLayout to Grid"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/#introduction","text":"StackLayout is one of the basic layouts provided by Xamarin.Forms and is a common starting point when composing a new view, being fast and easy to use. But it's common to transform a StackLayout into a Grid when the layout starts to become complex, or you need to rethink it to have new column or row. MFractor makes easy to convert an existing StackLayout into a Grid with the adequate rows and columns definitions and its elements in place.","title":"Introduction"},{"location":"xamarin-forms/grids/convert-stacklayout-to-grid/#using-the-converter","text":"The Convert StackLayout to Grid tool is presented as a XAML Code Action. The option becomes available to the Refactor menu on the Context Menu of a StackLayout element. Consider a layout for reporting progress to the user. It's composed of an ActivityIndicator , a Label and Button stacked vertically: <StackLayout> <ActivityIndicator IsRunning= \"True\" /> <Label HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button HorizontalOptions= \"Center\" Text= \"Cancel\" /> </StackLayout> We may want to transform it into a Grid , so we can add a second column to add new button button to right of the current one. Right-click on the StackLayout element and on the context menu you should find the option Convert StackLayout to Grid on the Refactor menu: In Visual Studio for Windows this code action will appear in the quick fix menu, the little screwdriver icon that appears to the left of the current line being edited. If you place the cursor under a StackLayout declaration and click on the icon or use the Ctrl + . keyboard shortcut, the option will appear o the menu: Note The current verison of MFractor for Visual Studio Mac doe not support quick fix actions in XAML, however, this feature should be available in a future version. By applying this code action, your StackLayout declaration will be transformed into an equivalent Grid declaration, just like below: <Grid HorizontalOptions= \"Center\" VerticalOptions= \"Center\" Padding= \"12\" > <Grid.RowDefinitions> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> <RowDefinition Height= \"Auto\" /> </Grid.RowDefinitions> <ActivityIndicator Grid.Row= \"0\" IsRunning= \"True\" /> <Label Grid.Row= \"1\" HorizontalTextAlignment= \"Center\" Text= \"Processing...\" /> <Button Grid.Row= \"2\" HorizontalOptions= \"Center\" Text= \"Cancel\" /> </Grid> The conversion to Grid will keep all the properties previously applied to the StackLayout on the trasformed grid declaration. Depending on the Orientation property, the ColumnsDefinitions or RowDefinitions will be created to match the number of elements in the stack. For Vertical (the default) stacks row definitions will be created and for Horizontal column definitions will be created. The conversion will also add the correspondent Grid.Column or Grid.Row properties on the child elements. The conversion will also verify the VerticalOptions (for vertical stacks) or HorizontalOptions (for horizontal stacks) Exapnsion option of each child element to determine the column width or row height of its corresponding position: For elements that Expand , the row or column defitinion will apply the * size For elements that doesn't declare the Expand, the row or column defiition will apply the Auto size Note There's no reverse operation of StackLayout to Grid conversion. If you need to revert the operation you should use the Undo command of the editor. We recommend that you keep a history of your source code so you can track back after the conversion if you need.","title":"Using the Converter"},{"location":"xamarin-forms/grids/delete-row-columns/","text":"Insert a new row or column and update all indices and spans Introduction","title":"Delete row columns"},{"location":"xamarin-forms/grids/delete-row-columns/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/grids/insert-row-columns/","text":"Insert a new row or column and update all indices and spans Introduction When working with Grids, it is a common workflow to add a new row or column and then update the row/column indices and spans. This workflow is Inserting A New Row Insert before Inser Inserting A Column","title":"Insert row columns"},{"location":"xamarin-forms/grids/insert-row-columns/#introduction","text":"When working with Grids, it is a common workflow to add a new row or column and then update the row/column indices and spans. This workflow is","title":"Introduction"},{"location":"xamarin-forms/grids/insert-row-columns/#inserting-a-new-row","text":"","title":"Inserting A New Row"},{"location":"xamarin-forms/grids/insert-row-columns/#insert-before","text":"","title":"Insert before"},{"location":"xamarin-forms/grids/insert-row-columns/#inser","text":"","title":"Inser"},{"location":"xamarin-forms/grids/insert-row-columns/#inserting-a-column","text":"","title":"Inserting A Column"},{"location":"xamarin-forms/grids/intellisense/","text":"Quickly declare grids with its boilerplate code and manage its rows and columns declarations and child positioning Introduction MFractor introduces several intellisense commands to aid on writing Xamarin.Forms layouts using the Grid component. Those commands allows you to: Declare a new Grid element including its boilerplate code Declare Row or Column definitions for auto and star widht/height Declare the Row or Column or the Span of child elements of a grid Using the Grid Intellisense Features The Grid intellisense appears on the appropriate contexts when editing XAML files. On the next sections we will build a login form in an XAML Page using the Grid layout. This layout will have 3 rows and two columns, where the first column will have the labels and the second column the entries, and the third row will span among the columns to add the login button. The result will look as below: Declaring a Grid with Boilerplate Code To start our login form we will declare a new Grid inside a Frame element in a ContentPage . The frame itself will be inside a root grid element. This allows to produce a login form that looks like a floating card on the screen. Start with the following XAML code for the page: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.GridSamplesPage\" > <Grid> <Frame> </Frame> </Grid> </ContentPage> Place the cursor inside the blank line on the Frame element (row number 7) and type an opening angle bracket ( < ) to declare a new XML element. The Intellisense suggestions will appear: When the Intellisense suggestions is open you can start typing to filter what you need. Hit the G and r keys, and the suggestion for Grid (Boilerplate) should appear at the end of the list: The intellisense tooltip provides a little preview of what will be generated to you. Select the option with either the cursor keys or the mouse and type Enter or Tab to apply the suggestion. The editor will add the declaration of a Grid with the boilerplate for declaring its Rows and Column definitions like the snippet below: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid> Declare Rows and Columns Definitions Next we need to declare the Columns and Rows definitions of our grid. This tells the Xamarin.Forms Grid engine how it will apply the available space to it's children elements. Row and Column definitions declares their width or height based on one of the 3 unit types: Auto , Proportional (also know as star, declared with the * char) or Absolute . Tip For more information about the Grid Rows and Columns declaration see the Official Xamarin.Forms docs for the Grid . With the MFractor Intellisense completions for Grid you can quickly declare rows and columns definitions. First lets declare our Column Definitions. There will be two Columns, the first will by automatically sized and the second will be proportional. Start a new line on the Grid.ColumDefinitions element and typpe an opening angle bracket to start a new element declaration. Intellisense appears and you should immediatly see the * and Auto options available to the list: Both are completions provided by MFractor. For the first column, select the Auto option and type Enter or Tab to apply the completion. MFractor will add a new ColumDefinition entry like below: <ColumnDefinition Width= \"Auto\" /> Repeat the steps to add a new proportional column definition by selecting the * option in the list. It will add the following definition: <ColumnDefinition Width= \"*\" /> Note You can still type to filter the options even when they already appear on the list. This would save some keystrokes or having to move the mouse to the wanted element. Next repeat the same process to add 3 new Row Definitions, all of the proportional height. The end result of your grid definition should be as follows: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width= \"Auto\" /> <ColumnDefinition Width= \"*\" /> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> </Grid.RowDefinitions> </Grid> Declare the Child Elements The last step for our login form is to declare its containing elements. We will declare two Label elements, two Entry elements and a Button element. We'll be using the MFractor intellisense grid location suggestion to easily define where our elements should be put in the available rows and columns of the grid. First, let's declare the labels. Inside the Grid we declared before add a new Label declaration. When you hit space to start adding attributes to the element, intellisense will list suggested properties of the label. Type G then r to filter the list and you should see the suggestions for the available columns and rows of the Grid: Those are the suggestions provided by the MFractor Grid Intellisense location feature. Notice that when you select a suggestion and wait a second a tooltip appears showing details about the width or height of the column or row in question. Important The grid location intellisense completion only appears for Grid elements that declares rows or columns definitions. A plain Grid element will not suggest any completion, because MFractor is unable to infer how may rows and columns the grid may contain. If you don't find those suggestions check the rows and columns definitions. For this first label we want to add it to the first row and the first column of the grid, so use the completions to quickly add the attached properties to the label. Its final declaration should be like below: <Label Grid.Column= \"0\" Grid.Row= \"0\" VerticalOptions= \"Center\" Text= \"Username\" /> Repeat the steps to create a new label, but change the Grid.Row property to 1 and the Text property to Password . Next add the declarations for the Entry elements, the code rest of the code for this part of the form is as follows: <Label Grid.Column= \"0\" Grid.Row= \"1\" VerticalOptions= \"Center\" Text= \"Password\" /> <Entry Grid.Column= \"1\" Grid.Row= \"0\" Placeholder= \"Your username\" /> <Entry Grid.Column= \"1\" Grid.Row= \"1\" IsPassword= \"True\" Placeholder= \"Your password\" /> Use the intellisense completions to easily fill the row and column information of each element. The last part is to add the login button. It will take the entire third row of the grid, so we should add a column span to allow it use the entire width of the grid. First you should add the declaration of the button adding its row and column locations. As in the preview iterations, hit a new line to add a new attribute for the column span and start typing G and r , the suggestions for either column and row span should appear wiht intellisense: The final button declaration should be as follow: <Button Grid.Column= \"0\" Grid.Row= \"2\" Grid.ColumnSpan= \"2\" Text= \"Login\" /> Note For the span completions to appear you should declare both the Grid.Row and Grid.Column for that element, so MFractor can calculate the available span options for each direction. Summary On this tutorial document we've checked how to use the MFractor Grid Intellisense features to quickly produce a new Grid layout for a login forms in Xamarin.Forms. The complete source code for this tutorial is available at GitHub on our samples repository. Check the official Grid documentation on the Xamarin.Forms docs for further information about how to use the Grid layout component.","title":"Grid Intellisense Commands"},{"location":"xamarin-forms/grids/intellisense/#introduction","text":"MFractor introduces several intellisense commands to aid on writing Xamarin.Forms layouts using the Grid component. Those commands allows you to: Declare a new Grid element including its boilerplate code Declare Row or Column definitions for auto and star widht/height Declare the Row or Column or the Span of child elements of a grid","title":"Introduction"},{"location":"xamarin-forms/grids/intellisense/#using-the-grid-intellisense-features","text":"The Grid intellisense appears on the appropriate contexts when editing XAML files. On the next sections we will build a login form in an XAML Page using the Grid layout. This layout will have 3 rows and two columns, where the first column will have the labels and the second column the entries, and the third row will span among the columns to add the login button. The result will look as below:","title":"Using the Grid Intellisense Features"},{"location":"xamarin-forms/grids/intellisense/#declaring-a-grid-with-boilerplate-code","text":"To start our login form we will declare a new Grid inside a Frame element in a ContentPage . The frame itself will be inside a root grid element. This allows to produce a login form that looks like a floating card on the screen. Start with the following XAML code for the page: <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class= \"MFractor.Samples.Pages.GridSamplesPage\" > <Grid> <Frame> </Frame> </Grid> </ContentPage> Place the cursor inside the blank line on the Frame element (row number 7) and type an opening angle bracket ( < ) to declare a new XML element. The Intellisense suggestions will appear: When the Intellisense suggestions is open you can start typing to filter what you need. Hit the G and r keys, and the suggestion for Grid (Boilerplate) should appear at the end of the list: The intellisense tooltip provides a little preview of what will be generated to you. Select the option with either the cursor keys or the mouse and type Enter or Tab to apply the suggestion. The editor will add the declaration of a Grid with the boilerplate for declaring its Rows and Column definitions like the snippet below: <Grid> <Grid.ColumnDefinitions> </Grid.ColumnDefinitions> <Grid.RowDefinitions> </Grid.RowDefinitions> </Grid>","title":"Declaring a Grid with Boilerplate Code"},{"location":"xamarin-forms/grids/intellisense/#declare-rows-and-columns-definitions","text":"Next we need to declare the Columns and Rows definitions of our grid. This tells the Xamarin.Forms Grid engine how it will apply the available space to it's children elements. Row and Column definitions declares their width or height based on one of the 3 unit types: Auto , Proportional (also know as star, declared with the * char) or Absolute . Tip For more information about the Grid Rows and Columns declaration see the Official Xamarin.Forms docs for the Grid . With the MFractor Intellisense completions for Grid you can quickly declare rows and columns definitions. First lets declare our Column Definitions. There will be two Columns, the first will by automatically sized and the second will be proportional. Start a new line on the Grid.ColumDefinitions element and typpe an opening angle bracket to start a new element declaration. Intellisense appears and you should immediatly see the * and Auto options available to the list: Both are completions provided by MFractor. For the first column, select the Auto option and type Enter or Tab to apply the completion. MFractor will add a new ColumDefinition entry like below: <ColumnDefinition Width= \"Auto\" /> Repeat the steps to add a new proportional column definition by selecting the * option in the list. It will add the following definition: <ColumnDefinition Width= \"*\" /> Note You can still type to filter the options even when they already appear on the list. This would save some keystrokes or having to move the mouse to the wanted element. Next repeat the same process to add 3 new Row Definitions, all of the proportional height. The end result of your grid definition should be as follows: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width= \"Auto\" /> <ColumnDefinition Width= \"*\" /> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> <RowDefinition Height= \"*\" /> </Grid.RowDefinitions> </Grid>","title":"Declare Rows and Columns Definitions"},{"location":"xamarin-forms/grids/intellisense/#declare-the-child-elements","text":"The last step for our login form is to declare its containing elements. We will declare two Label elements, two Entry elements and a Button element. We'll be using the MFractor intellisense grid location suggestion to easily define where our elements should be put in the available rows and columns of the grid. First, let's declare the labels. Inside the Grid we declared before add a new Label declaration. When you hit space to start adding attributes to the element, intellisense will list suggested properties of the label. Type G then r to filter the list and you should see the suggestions for the available columns and rows of the Grid: Those are the suggestions provided by the MFractor Grid Intellisense location feature. Notice that when you select a suggestion and wait a second a tooltip appears showing details about the width or height of the column or row in question. Important The grid location intellisense completion only appears for Grid elements that declares rows or columns definitions. A plain Grid element will not suggest any completion, because MFractor is unable to infer how may rows and columns the grid may contain. If you don't find those suggestions check the rows and columns definitions. For this first label we want to add it to the first row and the first column of the grid, so use the completions to quickly add the attached properties to the label. Its final declaration should be like below: <Label Grid.Column= \"0\" Grid.Row= \"0\" VerticalOptions= \"Center\" Text= \"Username\" /> Repeat the steps to create a new label, but change the Grid.Row property to 1 and the Text property to Password . Next add the declarations for the Entry elements, the code rest of the code for this part of the form is as follows: <Label Grid.Column= \"0\" Grid.Row= \"1\" VerticalOptions= \"Center\" Text= \"Password\" /> <Entry Grid.Column= \"1\" Grid.Row= \"0\" Placeholder= \"Your username\" /> <Entry Grid.Column= \"1\" Grid.Row= \"1\" IsPassword= \"True\" Placeholder= \"Your password\" /> Use the intellisense completions to easily fill the row and column information of each element. The last part is to add the login button. It will take the entire third row of the grid, so we should add a column span to allow it use the entire width of the grid. First you should add the declaration of the button adding its row and column locations. As in the preview iterations, hit a new line to add a new attribute for the column span and start typing G and r , the suggestions for either column and row span should appear wiht intellisense: The final button declaration should be as follow: <Button Grid.Column= \"0\" Grid.Row= \"2\" Grid.ColumnSpan= \"2\" Text= \"Login\" /> Note For the span completions to appear you should declare both the Grid.Row and Grid.Column for that element, so MFractor can calculate the available span options for each direction.","title":"Declare the Child Elements"},{"location":"xamarin-forms/grids/intellisense/#summary","text":"On this tutorial document we've checked how to use the MFractor Grid Intellisense features to quickly produce a new Grid layout for a login forms in Xamarin.Forms. The complete source code for this tutorial is available at GitHub on our samples repository. Check the official Grid documentation on the Xamarin.Forms docs for further information about how to use the Grid layout component.","title":"Summary"},{"location":"xamarin-forms/grids/tooltips/","text":"Previewing the referenced grid row or columns Introduction When working with Grids in XAML, we often need to understand the layout behaviour of a row or column. While we can refer to the row or column definition, MFractor provides tooltips that display the width or height behaviour for a given row or column. Grid.Row Tooltips To view the row information of an element, hover your mouse over the Grid.Row attribute on the element. MFractor will provide a short preview of the layout behaviour of that row. Grid.RowSpan Tooltips To view the details of each row within a row span, hover your cursor over the Grid.RowSpan attribute. MFractor will provide a short preview for each row that the row span covers. Grid.Column Tooltips To view the column information of an element, hover your mouse over the Grid.Column attribute on the element. MFractor will provide a short preview of the layout behaviour of that column. Grid.ColumnSpan Tooltips To view the details of each column within a column span, hover your cursor over the Grid.ColumnSpan attribute. MFractor will provide a short preview for each column that the column span covers.","title":"Tooltips"},{"location":"xamarin-forms/grids/tooltips/#introduction","text":"When working with Grids in XAML, we often need to understand the layout behaviour of a row or column. While we can refer to the row or column definition, MFractor provides tooltips that display the width or height behaviour for a given row or column.","title":"Introduction"},{"location":"xamarin-forms/grids/tooltips/#gridrow-tooltips","text":"To view the row information of an element, hover your mouse over the Grid.Row attribute on the element. MFractor will provide a short preview of the layout behaviour of that row.","title":"Grid.Row Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridrowspan-tooltips","text":"To view the details of each row within a row span, hover your cursor over the Grid.RowSpan attribute. MFractor will provide a short preview for each row that the row span covers.","title":"Grid.RowSpan Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridcolumn-tooltips","text":"To view the column information of an element, hover your mouse over the Grid.Column attribute on the element. MFractor will provide a short preview of the layout behaviour of that column.","title":"Grid.Column Tooltips"},{"location":"xamarin-forms/grids/tooltips/#gridcolumnspan-tooltips","text":"To view the details of each column within a column span, hover your cursor over the Grid.ColumnSpan attribute. MFractor will provide a short preview for each column that the column span covers.","title":"Grid.ColumnSpan Tooltips"},{"location":"xamarin-forms/search/automationid-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Automationid search"},{"location":"xamarin-forms/search/automationid-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/automationid-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/dynamic-resource-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Dynamic resource search"},{"location":"xamarin-forms/search/dynamic-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/dynamic-resource-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/static-resource-search/","text":"Search your solution for static resources Introduction Dynamic Resource Overview Declaraing Dynamic Resources Using Dynamic Resources Using Dynamic Resource Search","title":"Static resource search"},{"location":"xamarin-forms/search/static-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/static-resource-search/#dynamic-resource-overview","text":"","title":"Dynamic Resource Overview"},{"location":"xamarin-forms/search/static-resource-search/#declaraing-dynamic-resources","text":"","title":"Declaraing Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resources","text":"","title":"Using Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resource-search","text":"","title":"Using Dynamic Resource Search"},{"location":"xamarin-forms/static-resources/analysis/","text":"Inspections that verify static resource declarations and expressions Introduction This documentation article outlines the XAML analysers and code fixes that are available for static resource expressions and declarations. Missing Static Resource When referencing a resource using a StaticResource expression, MFractor will validate that the given resource key is available in the current Using A Nearly Named Resource When MFractor detects that key provided to a StaticResource expression is unresolved, however, it closely matches another the name of another available resource name, MFractor suggests that resource and provides a code-fix to Static Resource Return Type Mismatch When a static resource expression returns a type that does not match the expected type of the targeted attribute, it will warn of a type mismatch between the expected type of that attribute and the expressions return type. If the property type has a TypeConverterAttribute applied to it (EG: to enable converting a string value into a LayoutOptions), MFractor will not analyse the type flow. Ambiguous Static Resource When two or more resources are defined using the same name but in different scopes, the final result of a StaticResource expression is ambiguous. For example, if a page defines a resource named primaryColor and the App.xaml also defined a resource named primaryColor , we now have two resources with the same name available to the page. It is ambiguous which one we are referencing when we use the expression {StaticResource primaryColor} . The Ambiguous Static Resource analyser detects when an expressions resource key resolves to more than one available resource and provides a warning that the referenced resource is ambiguous. No Key Provided For Static Resource When declaring a new resource inside a ResourceDictionary , we include an x:Key attribute to define the key that is used to lookup the resource with a StaticResource expression. Unless the element is a style, all resources must include a resource key. To fix this issue, hover over the code issue and in the tooltip, click on the Generate a key for this resource fix. Resource Key Conflict When declaring a new resource for a page or control, it is common to accidentally use the same key multiple times (either in the same page or ) This analyser inspects the x:Key attribute of each resource definition and verifies that it is unique within the current scope. OnPlatform Return Type Mismatch When a static resource expression returns an OnPlatform element, MFractor will verify that the type specified by the x:TypeArguments is compatible with the expected type of the attribute.","title":"Analysis"},{"location":"xamarin-forms/static-resources/analysis/#introduction","text":"This documentation article outlines the XAML analysers and code fixes that are available for static resource expressions and declarations.","title":"Introduction"},{"location":"xamarin-forms/static-resources/analysis/#missing-static-resource","text":"When referencing a resource using a StaticResource expression, MFractor will validate that the given resource key is available in the current","title":"Missing Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#using-a-nearly-named-resource","text":"When MFractor detects that key provided to a StaticResource expression is unresolved, however, it closely matches another the name of another available resource name, MFractor suggests that resource and provides a code-fix to","title":"Using A Nearly Named Resource"},{"location":"xamarin-forms/static-resources/analysis/#static-resource-return-type-mismatch","text":"When a static resource expression returns a type that does not match the expected type of the targeted attribute, it will warn of a type mismatch between the expected type of that attribute and the expressions return type. If the property type has a TypeConverterAttribute applied to it (EG: to enable converting a string value into a LayoutOptions), MFractor will not analyse the type flow.","title":"Static Resource Return Type Mismatch"},{"location":"xamarin-forms/static-resources/analysis/#ambiguous-static-resource","text":"When two or more resources are defined using the same name but in different scopes, the final result of a StaticResource expression is ambiguous. For example, if a page defines a resource named primaryColor and the App.xaml also defined a resource named primaryColor , we now have two resources with the same name available to the page. It is ambiguous which one we are referencing when we use the expression {StaticResource primaryColor} . The Ambiguous Static Resource analyser detects when an expressions resource key resolves to more than one available resource and provides a warning that the referenced resource is ambiguous.","title":"Ambiguous Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#no-key-provided-for-static-resource","text":"When declaring a new resource inside a ResourceDictionary , we include an x:Key attribute to define the key that is used to lookup the resource with a StaticResource expression. Unless the element is a style, all resources must include a resource key. To fix this issue, hover over the code issue and in the tooltip, click on the Generate a key for this resource fix.","title":"No Key Provided For Static Resource"},{"location":"xamarin-forms/static-resources/analysis/#resource-key-conflict","text":"When declaring a new resource for a page or control, it is common to accidentally use the same key multiple times (either in the same page or ) This analyser inspects the x:Key attribute of each resource definition and verifies that it is unique within the current scope.","title":"Resource Key Conflict"},{"location":"xamarin-forms/static-resources/analysis/#onplatform-return-type-mismatch","text":"When a static resource expression returns an OnPlatform element, MFractor will verify that the type specified by the x:TypeArguments is compatible with the expected type of the attribute.","title":"OnPlatform Return Type Mismatch"},{"location":"xamarin-forms/static-resources/refactoring/","text":"Move and refactor your applications XAML resources Introduction This documentation article outlines the XAML resource refactorings provided by MFractor. Extracting Values Into Resources The Extract value into local resource refactoring enables you to extract an attributes value into a local or global resource, replacing the Extracting the value into a local resource Extracting the value into the App.xaml Moving Resources Up To The App.xaml The Move Resource To App.xaml refactoring allows you to move a local resource to your App.xaml so that it can be used globally. Tip After a resource is moved into the App.xaml, any resource analysers that target that resource kind will take affect across your entire project. For example, you can move a local color resource into your app.xaml and MFractor will then start to globally match any duplicate inline color values to that color. This allows you to keep your code clean and tidy. Generating Resource Code Behind Lookup The Generating Resource Code Behind Lookup refactoring creates a C# statement in the XAML code-behind that retrieves the resource via a property. This code action enables you to expose XAML resources to your code behind class.","title":"Refactoring"},{"location":"xamarin-forms/static-resources/refactoring/#introduction","text":"This documentation article outlines the XAML resource refactorings provided by MFractor.","title":"Introduction"},{"location":"xamarin-forms/static-resources/refactoring/#extracting-values-into-resources","text":"The Extract value into local resource refactoring enables you to extract an attributes value into a local or global resource, replacing the Extracting the value into a local resource Extracting the value into the App.xaml","title":"Extracting Values Into Resources"},{"location":"xamarin-forms/static-resources/refactoring/#moving-resources-up-to-the-appxaml","text":"The Move Resource To App.xaml refactoring allows you to move a local resource to your App.xaml so that it can be used globally. Tip After a resource is moved into the App.xaml, any resource analysers that target that resource kind will take affect across your entire project. For example, you can move a local color resource into your app.xaml and MFractor will then start to globally match any duplicate inline color values to that color. This allows you to keep your code clean and tidy.","title":"Moving Resources Up To The App.xaml"},{"location":"xamarin-forms/static-resources/refactoring/#generating-resource-code-behind-lookup","text":"The Generating Resource Code Behind Lookup refactoring creates a C# statement in the XAML code-behind that retrieves the resource via a property. This code action enables you to expose XAML resources to your code behind class.","title":"Generating Resource Code Behind Lookup"},{"location":"xamarin-forms/static-resources/tooltips/","text":"Preview the result of a static resource expression Introduction Previewing General Resources When you hover over a static resource expression, MFractor will render an XML preview of that static resource. Static resource tooltips will work for all resource expressions that can be resolved. Previewing Colors When you hover over a static resource expression that returns a Color , MFractor will render a preview of the color: Color resource tooltips are useful as they allow you to visually preview what a color Previewing Styles If you hover over a static resource expression that returns a Style , MFractor will render an XML preview of that style: Style tooltips will include the following information: Each Setter included in the style. The x:Key of that style. If the style has a parent, this inheritance is also included.","title":"Tooltips"},{"location":"xamarin-forms/static-resources/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-general-resources","text":"When you hover over a static resource expression, MFractor will render an XML preview of that static resource. Static resource tooltips will work for all resource expressions that can be resolved.","title":"Previewing General Resources"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-colors","text":"When you hover over a static resource expression that returns a Color , MFractor will render a preview of the color: Color resource tooltips are useful as they allow you to visually preview what a color","title":"Previewing Colors"},{"location":"xamarin-forms/static-resources/tooltips/#previewing-styles","text":"If you hover over a static resource expression that returns a Style , MFractor will render an XML preview of that style: Style tooltips will include the following information: Each Setter included in the style. The x:Key of that style. If the style has a parent, this inheritance is also included.","title":"Previewing Styles"},{"location":"xamarin-forms/thicknesses/analysis/","text":"Code inspections to spot various common issues in thickness usage Introduction Thickness Value Is Invalid Thickness Can Be Simplified Thickness Matches Existing Static Resource Thickness Can Be Consolidated Thickness Can Be Simplified","title":"Analysis"},{"location":"xamarin-forms/thicknesses/analysis/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/thicknesses/analysis/#thickness-value-is-invalid","text":"","title":"Thickness Value Is Invalid"},{"location":"xamarin-forms/thicknesses/analysis/#thickness-can-be-simplified","text":"","title":"Thickness Can Be Simplified"},{"location":"xamarin-forms/thicknesses/analysis/#thickness-matches-existing-static-resource","text":"","title":"Thickness Matches Existing Static Resource"},{"location":"xamarin-forms/thicknesses/analysis/#thickness-can-be-consolidated","text":"","title":"Thickness Can Be Consolidated"},{"location":"xamarin-forms/thicknesses/analysis/#thickness-can-be-simplified_1","text":"","title":"Thickness Can Be Simplified"},{"location":"xamarin-forms/thicknesses/intellisense/","text":"Quickly and easily create a new MVVM Component Introduction Using the MVVM Wizard","title":"Intellisense"},{"location":"xamarin-forms/thicknesses/intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/thicknesses/intellisense/#using-the-mvvm-wizard","text":"","title":"Using the MVVM Wizard"},{"location":"xamarin-forms/value-converters/value-converter-analysis/","text":"","title":"Value converter analysis"},{"location":"xamarin-forms/value-converters/value-converter-wizard/","text":"Quickly create a Value Converter and reference it on your XAML code Introduction Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic. Using the Wizard The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows: Name and Location Parameters Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters . Type Parameters Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object . Input Type Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method. Output Type Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned. Parameter Type Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: <Label Text= \"{Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'}\" /> The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type. Optional XML Entry Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: <ResourceDictionary> <converters:BoolNegationConverter x:Key= \"boolNegationConverter\" /> </ResourceDictionary> MFractor will also take care of adding the required namespace imports to the file. Default Code Snippet This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Value Converter Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#introduction","text":"Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic.","title":"Introduction"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#using-the-wizard","text":"The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows:","title":"Using the Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#name-and-location-parameters","text":"Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters .","title":"Name and Location Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#type-parameters","text":"Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object .","title":"Type Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#input-type","text":"Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method.","title":"Input Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#output-type","text":"Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned.","title":"Output Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#parameter-type","text":"Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: <Label Text= \"{Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'}\" /> The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type.","title":"Parameter Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#optional-xml-entry","text":"Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: <ResourceDictionary> <converters:BoolNegationConverter x:Key= \"boolNegationConverter\" /> </ResourceDictionary> MFractor will also take care of adding the required namespace imports to the file.","title":"Optional XML Entry"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#default-code-snippet","text":"This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Default Code Snippet"},{"location":"xamarin-forms/working-with-styles/extracting-styles/","text":"A rich toolbox for quickly extract and organize XAML styles. Introduction Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply. How to Extract a style The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style. Configuring the Style Extraction The extraction dialog offer several options to control how the extraction will be done. Name The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element. TargetType The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes. Target Type Xmlns This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: <Style x:Key= \"[styleName]\" TargetType= \"views:Label\" > <!-- The rest of the style declaration --> </Style> File The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application. Parent The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey=\"[ParentResourceKey]\" For a BasedOn parent type, the output will be: BasedOn=\"{StaticResource [ParentResourceKey]}\" If you leave the parent resource key field blank the parent declaration will be supressed. Properties The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style. Previewing the new Style The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: <Style x:Key= \"[styleName]\" TargetType= \"[TargetType]\" BaseResourceKey= \"[ParentResouceKey]\" BasedOn= \"{StaticResource [ParentResourceKey]}\" > <Setter Property= \"[PropertyName]\" Value= \"[PropertyValue]\" /> <!-- Repeats for each property set in the dialog... --> </Style> Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section. Extracting the Style By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: <Label Style= \"{StaticResource defaultLabel}\" /> Summary The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Extracting Styles"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#introduction","text":"Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#how-to-extract-a-style","text":"The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: <Label HorizontalTextAlignment= \"Center\" FontFamily= \"{StaticResource OpenSans}\" FontSize= \"Large\" Text= \"Welcome to MFractor Docs!\" /> If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style.","title":"How to Extract a style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#configuring-the-style-extraction","text":"The extraction dialog offer several options to control how the extraction will be done.","title":"Configuring the Style Extraction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#name","text":"The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element.","title":"Name"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#targettype","text":"The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes.","title":"TargetType"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#target-type-xmlns","text":"This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: <Style x:Key= \"[styleName]\" TargetType= \"views:Label\" > <!-- The rest of the style declaration --> </Style>","title":"Target Type Xmlns"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#file","text":"The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application.","title":"File"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#parent","text":"The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey=\"[ParentResourceKey]\" For a BasedOn parent type, the output will be: BasedOn=\"{StaticResource [ParentResourceKey]}\" If you leave the parent resource key field blank the parent declaration will be supressed.","title":"Parent"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#properties","text":"The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style.","title":"Properties"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#previewing-the-new-style","text":"The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: <Style x:Key= \"[styleName]\" TargetType= \"[TargetType]\" BaseResourceKey= \"[ParentResouceKey]\" BasedOn= \"{StaticResource [ParentResourceKey]}\" > <Setter Property= \"[PropertyName]\" Value= \"[PropertyValue]\" /> <!-- Repeats for each property set in the dialog... --> </Style> Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section.","title":"Previewing the new Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#extracting-the-style","text":"By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: <Label Style= \"{StaticResource defaultLabel}\" />","title":"Extracting the Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#summary","text":"The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Summary"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/","text":"Inspects XAML elements that do not have a style applied and, if possible, matches them to an available style that targets the element type and also applies the same properties. Introduction Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties. Matching Style Detection The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element. Applying A Matching style When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style. Disabling this Code Analysis The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Matching Style Analysis"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#introduction","text":"Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#matching-style-detection","text":"The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element.","title":"Matching Style Detection"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#applying-a-matching-style","text":"When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style.","title":"Applying A Matching style"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#disabling-this-code-analysis","text":"The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Disabling this Code Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Data Binding Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/","text":"Introduction Using Data-Binding IntelliSense","title":"Data Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#using-data-binding-intellisense","text":"","title":"Using Data-Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/generating-properties-and-commands/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Generating Properties/Commands"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/","text":"Quickly and easily create a new MVVM Component This feature is available in MFractor Professional Introduction When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file. Using the MVVM Wizard The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented. Wizard Options The Wizard is pretty simple and only asks you about two pieces of information: Target Project A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created. Name The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings . Previewing the files The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code. Wizard Settings As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard. Wizard Settings Options The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options. View Project A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. View Suffix Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page View Folder Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages View Base Class and XML Namespace This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to <namespace:ClassName> to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages Binding Context Initialisation In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers. Initialise BindingContext in Code-Behind This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel => BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } } Initialise BindingContext in XAML This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: <ContentPage xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns= \"http://xamarin.com/schemas/2014/forms\" x:Class= \"MFractor.Samples.Pages.Page\" xmlns:viewModels= \"clr-namespace:MFractor.Samples.ViewModels\" > <ContentPage.BindingContext> <viewModels:ViewModel x:Key= \"ViewModel\" /> </ContentPage.BindingContext> </ContentPage> Register Withing Application.RegisterTypes Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation < Pages . HomePage , ViewModels . HomeViewModel >(); } ViewModel Project A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. ViewModel Suffix Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel ViewModel Folder Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels ViewModel Base Class Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix . Reseting Settings If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#introduction","text":"When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#using-the-mvvm-wizard","text":"The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented.","title":"Using the MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-options","text":"The Wizard is pretty simple and only asks you about two pieces of information:","title":"Wizard Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#target-project","text":"A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created.","title":"Target Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#name","text":"The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings .","title":"Name"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#previewing-the-files","text":"The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code.","title":"Previewing the files"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings","text":"As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard.","title":"Wizard Settings"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings-options","text":"The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options.","title":"Wizard Settings Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-project","text":"A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"View Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-suffix","text":"Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page","title":"View Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-folder","text":"Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages","title":"View Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-base-class-and-xml-namespace","text":"This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to <namespace:ClassName> to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages","title":"View Base Class and XML Namespace"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#binding-context-initialisation","text":"In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers.","title":"Binding Context Initialisation"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-code-behind","text":"This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel => BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } }","title":"Initialise BindingContext in Code-Behind"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-xaml","text":"This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: <ContentPage xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns= \"http://xamarin.com/schemas/2014/forms\" x:Class= \"MFractor.Samples.Pages.Page\" xmlns:viewModels= \"clr-namespace:MFractor.Samples.ViewModels\" > <ContentPage.BindingContext> <viewModels:ViewModel x:Key= \"ViewModel\" /> </ContentPage.BindingContext> </ContentPage>","title":"Initialise BindingContext in XAML"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#register-withing-applicationregistertypes","text":"Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation < Pages . HomePage , ViewModels . HomeViewModel >(); }","title":"Register Withing Application.RegisterTypes"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-project","text":"A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"ViewModel Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-suffix","text":"Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel","title":"ViewModel Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-folder","text":"Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels","title":"ViewModel Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-base-class","text":"Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix .","title":"ViewModel Base Class"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#reseting-settings","text":"If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"Reseting Settings"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/","text":"Quickly switch among the three core components of the MVVM pattern Introduction The MVVM (Model-View-ViewModel) Pattern is one of the most common architectural patterns of a Xamarin.Forms application. By convention, the MVVM pattern is composed by three files: The XAML View file ( .xaml ) It's code-behind file ( .xaml.cs ) A View Model that will provide the features of the view (a C# class contained on its own .cs file). The first two files are kept together, the later is usually kept on a ViewModels folders, where all the View Models are declared. Sometimes this makes hard to navigate between those files. Important Please read the Binding Context Resolution documentation to understand how MFractor associates view models with XAML views. Navigating to a View Keyboard Shortcuts Mac: Command+Shift+3 Windows: Alt+3 Navigating to a ViewModel Keyboard Shortcuts Mac: Command+Shift+1 Windows: Alt+1 Highlight shortcut is Command+Shift+1 Navigating to a Code Behind Keyboard Shortcuts Mac: Command+Shift+2 Windows: Alt+2","title":"View-ViewModel Navigation"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#introduction","text":"The MVVM (Model-View-ViewModel) Pattern is one of the most common architectural patterns of a Xamarin.Forms application. By convention, the MVVM pattern is composed by three files: The XAML View file ( .xaml ) It's code-behind file ( .xaml.cs ) A View Model that will provide the features of the view (a C# class contained on its own .cs file). The first two files are kept together, the later is usually kept on a ViewModels folders, where all the View Models are declared. Sometimes this makes hard to navigate between those files. Important Please read the Binding Context Resolution documentation to understand how MFractor associates view models with XAML views.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-view","text":"Keyboard Shortcuts Mac: Command+Shift+3 Windows: Alt+3","title":"Navigating to a View"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-viewmodel","text":"Keyboard Shortcuts Mac: Command+Shift+1 Windows: Alt+1 Highlight shortcut is Command+Shift+1","title":"Navigating to a ViewModel"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-code-behind","text":"Keyboard Shortcuts Mac: Command+Shift+2 Windows: Alt+2","title":"Navigating to a Code Behind"}]}