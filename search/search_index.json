{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to the documentation for MFractor, a powerful productivity tool for Visual Studio Windows and Mac to streamline the development of Xamarin applications. Getting Started To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac Help And Support To get help using MFractor, please see our Support article. Licensing MFractor's licensing levels and end user license can be found in our Licensing article. Release Notes MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Home"},{"location":"#welcome","text":"Welcome to the documentation for MFractor, a powerful productivity tool for Visual Studio Windows and Mac to streamline the development of Xamarin applications.","title":"Welcome"},{"location":"#getting-started","text":"To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac","title":"Getting Started"},{"location":"#help-and-support","text":"To get help using MFractor, please see our Support article.","title":"Help And Support"},{"location":"#licensing","text":"MFractor's licensing levels and end user license can be found in our Licensing article.","title":"Licensing"},{"location":"#release-notes","text":"MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Release Notes"},{"location":"code-actions/","text":"Enhance your developer productivity with contextual refactorings, code generation and utilities Introduction Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code. Using the Code Actions MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documetation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied. Code Actions for C# Code The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu: Code Actions for XAML Code The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to referece it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action. List of MFractor Code Actions Warning The complete list of MFractor is still being compiled. Here we show only the currently documented ones. C# Code Actions Language Code Actions Generate Interface Imlementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String Xamarin.Forms Code Actions Create Bindable Property Create Attached Property XAML Code Actions Extract XAML Style Extract Custom Control Generate a new View Model for XAML view","title":"Code Actions"},{"location":"code-actions/#introduction","text":"Code Actions enhance developer productivity by providing tools that allows you to quickly refactor and generate new code from your existing code. MFractor constantly inspects your code and shows suggestions of the most common operations done from the code of code you're writing at that time. Important MFractor Code Inspector works entirely locally and doesn't track any of your code.","title":"Introduction"},{"location":"code-actions/#using-the-code-actions","text":"MFractor ships with tons of Code Actions to enhance common .NET and Xamarin development tasks and aids you to avoid writing boilerplate code. They are context sensitive, so it will only be presented in places where it made sense to be applied. Code Actions are available to either C# and XAML code. Info The section below presents general guidance on how to invoke the Code Actions for different types of source files. Check the documetation of the MFractor Code Action you're interested to use to understand the specific contexts where they can be applied.","title":"Using the Code Actions"},{"location":"code-actions/#code-actions-for-c-code","text":"The C# Code Actions provides refactorings, code generation wizards and utilities to code written in C#. They are context sensitive and there are several ways they can be invoked. From instance, let's take as an example the Generate Interface Implementation Code Action , that allows you to quickly create a new class that implement the interface you're working with. This Code Action appears when you are editing any C# Interface Code File. Leave the cursor over the name of the Interface for half a second. Visual Studio will present a little screwdriver icon to the left of the editor, which indicates to the user that there are Code Actions available related to this part of your code. Click the icon and the suggestions will appear: Tip The suggestions menu presented from the screwdriver icon is called Quick Fix and can be opened with the ALT + Enter keyboard shortcut. This shortcut can also be customized from the Key Bindinds section of Visual Studio Preferences. The Code Actions can also be invoked from the context menu when you right click over a symbol in the code. Given the previous example right click over the same interface name the action will appear under the Generate sub-menu:","title":"Code Actions for C# Code"},{"location":"code-actions/#code-actions-for-xaml-code","text":"The XAML Code Actions provide refactorings and code generation wizards and utilities to Xamarin.Forms XAML source files. They are context sensitive, but unlike the C# Code Actions, they aren't easily discoverable since the Quick Fix menu isn't available on the current stable of the new XAML Code Editor on Visual Studio for Mac. For this reason, they are only accessible from the context menu. For instance, let's take the Extract XAML Style Code Action , which allows you to extract property declarations on element to style and refactor that element to referece it. If you right-click over an element declaration that contains one or more property declarations, the Extract XAML Style will be available under the Refactor sub-menu: In the example above, the Generate a new View Model for XAML view Code Action would also be available under the Generate sub-menu, because the context also applies for this action.","title":"Code Actions for XAML Code"},{"location":"code-actions/#list-of-mfractor-code-actions","text":"Warning The complete list of MFractor is still being compiled. Here we show only the currently documented ones.","title":"List of MFractor Code Actions"},{"location":"code-actions/#c-code-actions","text":"","title":"C# Code Actions"},{"location":"code-actions/#language-code-actions","text":"Generate Interface Imlementation Simplify Qualified Types Locate in Solution Explorer Create Lazy Field Property Convert to Interpolated String","title":"Language Code Actions"},{"location":"code-actions/#xamarinforms-code-actions","text":"Create Bindable Property Create Attached Property","title":"Xamarin.Forms Code Actions"},{"location":"code-actions/#xaml-code-actions","text":"Extract XAML Style Extract Custom Control Generate a new View Model for XAML view","title":"XAML Code Actions"},{"location":"faq/","text":"Answers to some commonly asked questions What is MFractor Professional? MFractor Professional is our paid version of MFractor. Our terms: A Professional license if valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. What is MFractor Lite? MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available for MFractor for Visual Studio Windows. Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. How do I get a refund? Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d Do you offer company licenses? Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing. I require an invoice or quote to purchase MFractor, can you provide one? Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order. How do I report a bug? To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug. I've got a great feature idea, how do I request it? Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality. I'd like to try MFractor Professional, how do I get a trial? To request an MFractor Professional trial, please email matthew@mfractor.com. How do I recover my MFractor Professional license? To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license. Where can I find MFracor's release notes? MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes Where do I find the latest version of MFractor? Visual Studio Macs The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300 Visual Studio Windows The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS What version of Visual Studio does MFractor support? Visual Studio Mac MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release. Visual Studio Window MFractor for Visual Studio Windows supports Visual Studio 2019 and higher. Does MFractor support the Preview versions of Visual Studio? No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk. Help! MFractor is not visible in Visual Studio Macs Extension Manager. MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ; I'd like to write a blog about MFractor. Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding. What is the .mfractor folder? The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it. Should I check .mfractor into source control? No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : * . mfractor / The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default. Can you help me make a Visual Studio extension? Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call. Are you available for hire to develop Xamarin applications? Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with. Are you available for hire to develop Visual Studio extension? Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor. What is the licensing agreement? Please see our End User License . What is your privacy policy? Please see our Privacy Policy .","title":"FAQ"},{"location":"faq/#what-is-mfractor-professional","text":"MFractor Professional is our paid version of MFractor. Our terms: A Professional license if valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"What is MFractor Professional?"},{"location":"faq/#what-is-mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available for MFractor for Visual Studio Windows.","title":"What is MFractor Lite?"},{"location":"faq/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"faq/#how-do-i-get-a-refund","text":"Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d","title":"How do I get a refund?"},{"location":"faq/#do-you-offer-company-licenses","text":"Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing.","title":"Do you offer company licenses?"},{"location":"faq/#i-require-an-invoice-or-quote-to-purchase-mfractor-can-you-provide-one","text":"Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order.","title":"I require an invoice or quote to purchase MFractor, can you provide one?"},{"location":"faq/#how-do-i-report-a-bug","text":"To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug.","title":"How do I report a bug?"},{"location":"faq/#ive-got-a-great-feature-idea-how-do-i-request-it","text":"Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality.","title":"I've got a great feature idea, how do I request it?"},{"location":"faq/#id-like-to-try-mfractor-professional-how-do-i-get-a-trial","text":"To request an MFractor Professional trial, please email matthew@mfractor.com.","title":"I'd like to try MFractor Professional, how do I get a trial?"},{"location":"faq/#how-do-i-recover-my-mfractor-professional-license","text":"To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license.","title":"How do I recover my MFractor Professional license?"},{"location":"faq/#where-can-i-find-mfracors-release-notes","text":"MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes","title":"Where can I find MFracor's release notes?"},{"location":"faq/#where-do-i-find-the-latest-version-of-mfractor","text":"","title":"Where do I find the latest version of MFractor?"},{"location":"faq/#visual-studio-macs","text":"The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300","title":"Visual Studio Macs"},{"location":"faq/#visual-studio-windows","text":"The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS","title":"Visual Studio Windows"},{"location":"faq/#what-version-of-visual-studio-does-mfractor-support","text":"","title":"What version of Visual Studio does MFractor support?"},{"location":"faq/#visual-studio-mac","text":"MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release.","title":"Visual Studio Mac"},{"location":"faq/#visual-studio-window","text":"MFractor for Visual Studio Windows supports Visual Studio 2019 and higher.","title":"Visual Studio Window"},{"location":"faq/#does-mfractor-support-the-preview-versions-of-visual-studio","text":"No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk.","title":"Does MFractor support the Preview versions of Visual Studio?"},{"location":"faq/#help-mfractor-is-not-visible-in-visual-studio-macs-extension-manager","text":"MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ;","title":"Help! MFractor is not visible in Visual Studio Macs Extension Manager."},{"location":"faq/#id-like-to-write-a-blog-about-mfractor","text":"Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding.","title":"I'd like to write a blog about MFractor."},{"location":"faq/#what-is-the-mfractor-folder","text":"The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it.","title":"What is the .mfractor folder?"},{"location":"faq/#should-i-check-mfractor-into-source-control","text":"No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : * . mfractor / The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default.","title":"Should I check .mfractor into source control?"},{"location":"faq/#can-you-help-me-make-a-visual-studio-extension","text":"Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call.","title":"Can you help me make a Visual Studio extension?"},{"location":"faq/#are-you-available-for-hire-to-develop-xamarin-applications","text":"Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with.","title":"Are you available for hire to develop Xamarin applications?"},{"location":"faq/#are-you-available-for-hire-to-develop-visual-studio-extension","text":"Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor.","title":"Are you available for hire to develop Visual Studio extension?"},{"location":"faq/#what-is-the-licensing-agreement","text":"Please see our End User License .","title":"What is the licensing agreement?"},{"location":"faq/#what-is-your-privacy-policy","text":"Please see our Privacy Policy .","title":"What is your privacy policy?"},{"location":"installation-and-setup/","text":"Installing, activating and updating MFractor. Introduction This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows. Visual Studio Mac Installation (Marketplace) MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version. Uninstallation MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor. Release Note The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article. Visual Studio Windows Installation (Marketplace) MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019 Uninstallation MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor. Release Notes The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Installation And Setup"},{"location":"installation-and-setup/#introduction","text":"This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows.","title":"Introduction"},{"location":"installation-and-setup/#visual-studio-mac","text":"","title":"Visual Studio Mac"},{"location":"installation-and-setup/#installation-marketplace","text":"MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file","text":"Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation.","title":"Installation (File)"},{"location":"installation-and-setup/#activation","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades","text":"MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version.","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation","text":"MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-note","text":"The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article.","title":"Release Note"},{"location":"installation-and-setup/#visual-studio-windows","text":"","title":"Visual Studio Windows"},{"location":"installation-and-setup/#installation-marketplace_1","text":"MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file_1","text":"Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows.","title":"Installation (File)"},{"location":"installation-and-setup/#activation_1","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license_1","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades_1","text":"Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation_1","text":"MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-notes","text":"The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Release Notes"},{"location":"licensing/","text":"Information about MFractor's licensing and terms of use Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. MFractor Lite MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows. End User License Please find our End User License here. Privacy policy Please find our Private Policy here.","title":"Licensing"},{"location":"licensing/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"licensing/#mfractor-lite","text":"","title":"MFractor Lite"},{"location":"licensing/#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"MFractor Professional"},{"location":"licensing/#mfractor-lite_1","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows.","title":"MFractor Lite"},{"location":"licensing/#end-user-license","text":"Please find our End User License here.","title":"End User License"},{"location":"licensing/#privacy-policy","text":"Please find our Private Policy here.","title":"Privacy policy"},{"location":"quickstart-mac/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Mac documentation. Main Menu Overview When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Mac"},{"location":"quickstart-mac/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-mac/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Mac documentation.","title":"Setup And Maintenance"},{"location":"quickstart-mac/#main-menu-overview","text":"When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-mac/#feature-overview","text":"MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-mac/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-mac/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-mac/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-mac/#formatting","text":"","title":"Formatting"},{"location":"quickstart-windows/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Windows documentation. Main Menu Overview When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Windows"},{"location":"quickstart-windows/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-windows/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Windows documentation.","title":"Setup And Maintenance"},{"location":"quickstart-windows/#main-menu-overview","text":"When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-windows/#feature-overview","text":"MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-windows/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-windows/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-windows/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-windows/#formatting","text":"","title":"Formatting"},{"location":"support/","text":"How to get support or report issues for MFractor Reporting a Bug We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE. Visual Studio Mac To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log . Visual Studio Windows To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback . Support Channels In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support"},{"location":"support/#reporting-a-bug","text":"We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE.","title":"Reporting a Bug"},{"location":"support/#visual-studio-mac","text":"To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log .","title":"Visual Studio Mac"},{"location":"support/#visual-studio-windows","text":"To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback .","title":"Visual Studio Windows"},{"location":"support/#support-channels","text":"In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support Channels"},{"location":"analysis/disabling-analysers/","text":"How to disable unwanted code analysers Introduction Disabling A Code Analyser","title":"Disabling analysers"},{"location":"analysis/disabling-analysers/#introduction","text":"","title":"Introduction"},{"location":"analysis/disabling-analysers/#disabling-a-code-analyser","text":"","title":"Disabling A Code Analyser"},{"location":"analysis/overview/","text":"Detect errors, improvements and maintainability suggestions with Introduction","title":"Overview"},{"location":"analysis/overview/#introduction","text":"","title":"Introduction"},{"location":"analysis/solution-analysis/","text":"Scan your mobile solution for a wide range of errors, improvements and maintainability suggestions","title":"Solution analysis"},{"location":"configuration/overview/","text":"**","title":"Overview"},{"location":"csharp/localisation/","text":"","title":"Localisation"},{"location":"csharp/code-actions/convert-to-interpolated-string/","text":"Quickly convert a string literal to a interpolated string Introduction When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string. Using Convert To Interpolated String To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Convert To Interpolated String"},{"location":"csharp/code-actions/convert-to-interpolated-string/#introduction","text":"When working with strings in C#, it's common to replace string literal with interpolated strings to simplify string concatenation. To speed this up, MFractor includes the To Interpolated String code action that transforms a string literal into an interpolated string.","title":"Introduction"},{"location":"csharp/code-actions/convert-to-interpolated-string/#using-convert-to-interpolated-string","text":"To use the Convert To Interpolated String code action, place the cursor over a string literal and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose To Interpolated String . MFractor will transform the string literal into an interpolated string, placing a $ before the string literal.","title":"Using Convert To Interpolated String"},{"location":"csharp/code-actions/create-lazy-field-property/","text":"Create a property to access the inner value of a Lazy field Introduction In .NET, the System.Lazy T class can be used to provide lazy initialisation . That is, System.Lazy T defers the creation cost of something until the first time it's used. Please refer to the System.Lazy documentation for more in-depth documentation. Each time we use Lazy T , we use the .Value property to retrieve the underlying object. When the Lazy T is a field, it's common to create a property that accesses the value. For example: readonly Lazy IIconService iconService ; public IIconService IconService = iconService . Value ; We would then use IIconService like so: IconService . MyMethod (); // Equates to iconService . Value . MyMethod (). Accessor properties for lazy fields cleanup our code, making it easier to maintain and read as each time we use IIconService we . However, we now need to create a property each time we use a lazy field to ensure our code remains clean. To simplify this, MFractor includes the Create Lazy Field Property code action to generate this code for us. Using Create Lazy Field Property To use the code action, locate then name of a field whose type is Lazy T and press Alt+Return or right click and choose Quick Fix on the name. In the context menu that opens, choose Create a property that access this lazy fields value : After confirming the code action, MFractor will generate a property to access the fields value:","title":"Create Lazy Field Property"},{"location":"csharp/code-actions/create-lazy-field-property/#introduction","text":"In .NET, the System.Lazy T class can be used to provide lazy initialisation . That is, System.Lazy T defers the creation cost of something until the first time it's used. Please refer to the System.Lazy documentation for more in-depth documentation. Each time we use Lazy T , we use the .Value property to retrieve the underlying object. When the Lazy T is a field, it's common to create a property that accesses the value. For example: readonly Lazy IIconService iconService ; public IIconService IconService = iconService . Value ; We would then use IIconService like so: IconService . MyMethod (); // Equates to iconService . Value . MyMethod (). Accessor properties for lazy fields cleanup our code, making it easier to maintain and read as each time we use IIconService we . However, we now need to create a property each time we use a lazy field to ensure our code remains clean. To simplify this, MFractor includes the Create Lazy Field Property code action to generate this code for us.","title":"Introduction"},{"location":"csharp/code-actions/create-lazy-field-property/#using-create-lazy-field-property","text":"To use the code action, locate then name of a field whose type is Lazy T and press Alt+Return or right click and choose Quick Fix on the name. In the context menu that opens, choose Create a property that access this lazy fields value : After confirming the code action, MFractor will generate a property to access the fields value:","title":"Using Create Lazy Field Property"},{"location":"csharp/code-actions/generate-interface-implementation/","text":"Quickly generate a class stub implementation for an interface Introduction The Generate Implementation for Interface code action allows you to quickly generate a class implementing stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation. Using the Code Action This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. For this code action, it can be invoked from the interface declaration file when the cusor is over the interface name or it's body, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the Intellisense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened on the code editor.","title":"Generate Interface Implementation"},{"location":"csharp/code-actions/generate-interface-implementation/#introduction","text":"The Generate Implementation for Interface code action allows you to quickly generate a class implementing stubs for the members of an interface in a convenient and quick way, avoiding the hurdle of having to create a file from the standard interface and having to type the class implementation.","title":"Introduction"},{"location":"csharp/code-actions/generate-interface-implementation/#using-the-code-action","text":"This code action appears on the context menu of Visual Studio code editor when the cursor are placed where the action may take. For this code action, it can be invoked from the interface declaration file when the cusor is over the interface name or it's body, except when you are over a method name or other symbol. There are several ways you can invoke the code action, you can use the Intellisense Suggestions or the Option/Alt + Enter keyboard shortcut: Or using the context menu from the right click of the mouse: Either way will display the Generate Interface Implementation dialog, that allows you to setup a few options and see a preview of the code that will be generated: The available options on this dialog are: Name : the name of the class that will implement the interface. Defaults to the name of the interface without the I prefix, in case this convention is used, or empty if the name omits the prefix. Project : you can select the destination project where the implementation will be created from the project where the interface is declared itself or any project that references this one. Folder : the folder in the destination project where the class will be created. Defaults to the same folder where the interface resides. You can type sub-folders separated by slash / . In the right-side you can preview the code implementation. The tool will generate stubs depending on the type of interface element being implemented: Methods : provide an empty method with a single throw new NotImplementedException() call stub. Properties : provide an auto-property implementation including get and/or set declarations. Events : provides the default event implementation. When clicking on the Generate button the new class will be generated and automatically opened on the code editor.","title":"Using the Code Action"},{"location":"csharp/code-actions/generate-readonly-constructor/","text":"","title":"Generate readonly constructor"},{"location":"csharp/code-actions/locate-in-solution-explorer/","text":"Locate the project file in the solution pad for a given type declaration Introduction When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration. Using Locate In Solution Explorer To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Locate In Solution Explorer"},{"location":"csharp/code-actions/locate-in-solution-explorer/#introduction","text":"When browsing a code base in Visual Studio, it's common to need to select the current project file in the solution explorer to use the right click context actions. However, if we have been working for a while, it's likely the current project file is hidden from view and locating it requires us to manually find it. To make solve this problem, MFractor includes the Locate in solution explorer code action to locate the project file for a class, struct or interface declaration.","title":"Introduction"},{"location":"csharp/code-actions/locate-in-solution-explorer/#using-locate-in-solution-explorer","text":"To use the code action, locate a type declaration (such as a class or interface) and press Alt+Return or right click and select Quick Fix . In the menu that opens, choose Locate declaration in solution explorer . MFractor will then locate the project file that owns that type declaration in the solution explorer and expands the project tree to reveal the file. The Locate declaration in solution explorer supports locating the following syntax elements: Classes Structs Interfaces","title":"Using Locate In Solution Explorer"},{"location":"csharp/code-actions/simplify-qualified-types/","text":"Generate a new using statement from a qualified type usage Introduction In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System . IO . FileInfo fileInfo ; // Qualified type is System.IO.FileInfo var myTask = System . Threading . Tasks . Task . Run (); // Qualified type is System.Threading.Tasks.Task To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System . IO ; using System . Threading . Tasks ; FileInfo fileInfo ; var myTask = Task . Run (); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings. Using the Code Action To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name: The Simplify Types Wizard In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"Simplifying Qualified Types"},{"location":"csharp/code-actions/simplify-qualified-types/#introduction","text":"In C#, a qualified type refers to the usage of a type (such as a class or interface) that also includes the namespace. For example, the following type usages are all qualified types: System . IO . FileInfo fileInfo ; // Qualified type is System.IO.FileInfo var myTask = System . Threading . Tasks . Task . Run (); // Qualified type is System.Threading.Tasks.Task To simplify this code, we might introduce using statement to import the namespaces System.IO and System.Threading.Tasks . This means we can refer to each type in it's smallest format: using System . IO ; using System . Threading . Tasks ; FileInfo fileInfo ; var myTask = Task . Run (); By adding using statements to import the namespaces, our code becomes simpler as each type usage no longer needs to be fully qualified. This makes our code easier to read and maintain! When writing code, it's likely we'll need to convert a qualified type into it's simplier format and add a using statement to import the namespace that contains that type. To help accomplish this, we can use MFractors simplify qualified types refactorings.","title":"Introduction"},{"location":"csharp/code-actions/simplify-qualified-types/#using-the-code-action","text":"To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify qualified type and introduce usings . This will introduce a using statement to import the types namespace and simplify the existing type reference to just its name:","title":"Using the Code Action"},{"location":"csharp/code-actions/simplify-qualified-types/#the-simplify-types-wizard","text":"In addition to the Simplify Qualified Type code action, you can use the Simplify All Qualified Types In File code action to simplify all qualified types in the current file. This code action converts all qualified types to their simplest forms and introduces usings for all required namespaces. To use the Simplify Qualified Type code action, locate a qualified type reference in C# and press Alt+Return or right click and choose Quick Fix . In the context menu that opens, select Simplify all qualified types in this file . This will launch the Simplify Types dialog, showing you what the simplified file will look like: To apply the simplified code, press the Apply button.","title":"The Simplify Types Wizard"},{"location":"fonts/fontfamily-xaml-entry/","text":"Inject the Font Family XAML entry for a font asset the Resource Dictionary of a Xamarin.Forms App Introduction Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: ResourceDictionary OnPlatform x:TypeArguments= x:String x:Key= OpenSans On Platform= iOS Value= OpenSans / On Platform= Android Value= OpenSans-Regular.ttf#Regular / /OnPlatform !-- Other dictionary resources -- /ResourceDictionary The Font Importer tool add this declaration to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customized the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: ContentPage xmlns= http://xamarin.com/schemas/2014/forms xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml x:Class= MFractor.Samples.Pages.CustomFontPage StackLayout VerticalOptions= Center Label HorizontalTextAlignment= Center FontFamily= {StaticResource OpenSans} FontSize= Large Text= Welcome to MFractor Docs! / /StackLayout /ContentPage References Fonts in Xamarin.Forms","title":"FontFamily XAML Entry"},{"location":"fonts/fontfamily-xaml-entry/#introduction","text":"Xamarin.Forms projects allows declaring font references as Resources in Resource Dictionaries, which can be set on Font property of most of the Forms components that has some form of text (such as Labels and Buttons ). Fonts references in Xamarin.Forms are declared as plain strings, but each platform expects the string in a different format. For this reason we use the OnPlatform element to reference the font in the expected way for each platform. The code snippet below shows an example of this is done: ResourceDictionary OnPlatform x:TypeArguments= x:String x:Key= OpenSans On Platform= iOS Value= OpenSans / On Platform= Android Value= OpenSans-Regular.ttf#Regular / /OnPlatform !-- Other dictionary resources -- /ResourceDictionary The Font Importer tool add this declaration to the App.xaml file, which makes the font reference available to any XAML file in the project, but it can also be added to the Resources Dictionary of a specific file. To customized the font of a component based on this entry, you should use the StaticResource markup extension of XAML. As an example, suppose a Page where we have a label that we want to apply the custom font: ContentPage xmlns= http://xamarin.com/schemas/2014/forms xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml x:Class= MFractor.Samples.Pages.CustomFontPage StackLayout VerticalOptions= Center Label HorizontalTextAlignment= Center FontFamily= {StaticResource OpenSans} FontSize= Large Text= Welcome to MFractor Docs! / /StackLayout /ContentPage","title":"Introduction"},{"location":"fonts/fontfamily-xaml-entry/#references","text":"Fonts in Xamarin.Forms","title":"References"},{"location":"fonts/importing-fonts/","text":"Add new assets into your Android and iOS applications Introduction The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way. Using the Font Importer The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Importing Fonts"},{"location":"fonts/importing-fonts/#introduction","text":"The Font Importer utilities allows you to import custom fonts into the Android and iOS projects of your solution, while adding required boilerplate code to make it available through Xamarin.Forms in a unified way.","title":"Introduction"},{"location":"fonts/importing-fonts/#using-the-font-importer","text":"The font importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straighforward way is from the MFractor main menu: The MFractor Font Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Font : The Font Importer tool dialog window allows you to select a single font file of TTF or OTF types (the ones currently supported by the mobile plaforms) and to set several options for the import processing. The first step is to select the desired font to import. After selecting the font, MFractor will try to infer most of the options and use conventions. The following options are available to the importer: Projects : this section of the dialog lists the projects in the solution that is compatible with the font importer tool, which are Xamarin.iOS and Xamarin.Android projects. In the list you can use the checkbox on the Include Font? column to select the targets to which you want to import the font. Other columns are: Project Name : the name of the project. Result : displays where the font will be imported in the project structure. By convention fonts are imported based on the project type: iOS projects import to the Resources folder. Android projects import to the Assets folder. FontFamily XAML : if your solution contains a Xamarin.Forms project, the Font Importer tool will suggest adding a XAML Font Declaratio to the App.xaml of the projects. This allows referencing the font from components that allows custom fonts, such as Labels and Button . This section provides the following options: Resource Key : this is the name to use as the Resource Key in the App Resources Dictionary, and will be used to reference the font on the components you may wish to customize it. Defaults to the name of the font file. If the font is of the regular style, the tool will automatically supress the style suffix. Add Font Declaration : this section lists the App.xaml files that are found to the current solution, and allows checking to include the font declaration. Font Declaration : this section provides a preview of the code that will be added to the files selected in the previous pane. Note the Font Importer tool currently doesn't support importing font as Android Resources. This is planned for future releases. By clicking on the Import Font the tool will process your import based on the options you've set. This processing includes adding required references to the projects such as the UIAppFonts entry in the Info.plist of a project, and optionally adding the Font Family reference resource in a Xamarin.Forms project. For specific information about those topics read on their sections linked above.","title":"Using the Font Importer"},{"location":"fonts/uiappfonts-plist-entry/","text":"Inject the UIAppFonts entry for a font asset into the info.plist Introduction When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: key UIAppFonts /key array string OpenSans-Regular.ttf /string /array You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button . Example of using custom font in UIKit","title":"UIAppFonts Entry"},{"location":"fonts/uiappfonts-plist-entry/#introduction","text":"When a font is imported to an iOS project, MFractor automatically takes care of adding it's declaration to the Info.plist file of the project. This is required by the UIKit framework, as stated on Apple Official Documentation on how to add custom fonts to native iOS project . The code snippet for the entry is as follows: key UIAppFonts /key array string OpenSans-Regular.ttf /string /array You can also check if the entry was added correctly from the Source view of the Info.plist file on Visual Studio: With this settings in place you can start using the imported font in UIKit components that allows font customization, such as UILabel , UIButton and UITextField , and also on a Xamarin.Forms app for components that declare the FontFamily property, such as Label or Button .","title":"Introduction"},{"location":"fonts/uiappfonts-plist-entry/#example-of-using-custom-font-in-uikit","text":"","title":"Example of using custom font in UIKit"},{"location":"image-management/deleting-image-assets/","text":"Remove all traces of image assets from your Android and iOS projects Introduction The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Identifying Image Assets Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view. Android When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable / logo . xml drawable - ldpi / logo . png drawable - mdpi / logo . png drawable - hdpi / logo . png drawable - night - mdpi / logo . png ( dark mode version ) drawable - landscape - hdpi / logo . png ( landscape version ) mipmap - de - ldpi / logo . png ( Deutsch translation ) mipmap - ldpi / logo . png mipmap - mdpi / logo . png mipmap - hdpi / logo1 . png MFractor would delete the following assets: drawable - ldpi / logo . png drawable - night - mdpi / logo . png drawable - landscape - hdpi / logo . png mipmap - de - ldpi / logo . png mipmap - ldpi / logo . png mipmap - mdpi / logo . png MFractor would ignore the following assets: drawable / logo . xml ( Excluded as it s an xml drawable ) mipmap - hdpi / logo1 . png ( Excluded as logo1 is not a match with logo ). iOS The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog. Deleting stand-alone images MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png Resources / logo1 @2 x . png Resources / logo2 @3 x . png The deletion tool will track and delete the following files as the image set of the logo asset: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png MFractor will ignore the following files: Resources / logo1 @2 x . png ( Excluded as logo1 is not a match with logo ) Resources / logo2 @3 x . png ( Excluded as logo2 is not a match with logo ) Deleting images from Asset Catalogs For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / other . png Assets . xcassets / logo . imageset / other @2 x . png Assets . xcassets / logo . imageset / Contents . json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { images : [ { filename : logo.png , scale : 1x , idiom : universal }, { filename : logo@2x.png , scale : 2x , idiom : universal }, { filename : logo@3x.png , scale : 3x , idiom : universal }, { filename : sample.png , appearances : [ { appearance : luminosity , value : dark } ], scale : 1x , idiom : universal }, { filename : sample@3x.png , appearances : [ { appearance : luminosity , value : dark } ], scale : 3x , idiom : universal } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / Contents . json ( metadata file is also deleted because its part of the asset definition ) MFractor will ignore the following files: Assets . xcassets / logo . imageset / other . png ( Not listed in the Contents . json file ) Assets . xcassets / logo . imageset / other @2 x . png ( Not listed in the Contents . json file ) Launching The Deletion Tool Solution Explorer The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option. Image Asset Manager The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane. Using The Deletion Tool After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Deleting Image Assets"},{"location":"image-management/deleting-image-assets/#introduction","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently.","title":"Introduction"},{"location":"image-management/deleting-image-assets/#identifying-image-assets","text":"Image assets are tracked differently on Android and iOS projects. The following sections describes how MFractor will identify images that are part of the same image set that forms an asset. Info An image asset is a single image that is used inside an app. This asset may have variations in size and style to adapt the image to different contexts, such as screen pixel density, light and dark modes and localizations. An image set is the set the of files that compose a single asset. When we develop an app we don't reference the individual files of an image set directly, but we of that as a single entity, the image asset. Note Image Assets are Considered Unique Among Projects . An image asset with the same name on iOS and Android projects that are of the same solution will be treated as single Image Asset of that application, considering they are different platform implementations of the same app, thus sharing the same set of assets among them. The rules below describes how MFractor identifies image assets in specific projects, but the tool will scan through all the projects of the solution and provides a unified view.","title":"Identifying Image Assets"},{"location":"image-management/deleting-image-assets/#android","text":"When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap folders. For example, let's consider an image asset named logo with the following files project structure: drawable / logo . xml drawable - ldpi / logo . png drawable - mdpi / logo . png drawable - hdpi / logo . png drawable - night - mdpi / logo . png ( dark mode version ) drawable - landscape - hdpi / logo . png ( landscape version ) mipmap - de - ldpi / logo . png ( Deutsch translation ) mipmap - ldpi / logo . png mipmap - mdpi / logo . png mipmap - hdpi / logo1 . png MFractor would delete the following assets: drawable - ldpi / logo . png drawable - night - mdpi / logo . png drawable - landscape - hdpi / logo . png mipmap - de - ldpi / logo . png mipmap - ldpi / logo . png mipmap - mdpi / logo . png MFractor would ignore the following assets: drawable / logo . xml ( Excluded as it s an xml drawable ) mipmap - hdpi / logo1 . png ( Excluded as logo1 is not a match with logo ).","title":"Android"},{"location":"image-management/deleting-image-assets/#ios","text":"The iOS projects can contain image assets into Image Asset Catalogs or any regular folder. The iOS SDK doesn't enforce any specific place where to put images, but by convention they're generally added to the Resources folder. The image deletion tool track assets differentely weather they are standalone files in folder or assets in a Asset Catalog.","title":"iOS"},{"location":"image-management/deleting-image-assets/#deleting-stand-alone-images","text":"MFractor will identify stand-alone images as an image-set based on its name and density suffix. Images may three primary densities for iOS projects: 1x, 2x and 3x. The former one doesn't add any suffix to the image file name (in practice unused since there are no more supported devices with 1x density screens). The later 2 adds the suffixes as @2x and @3x respectively. For example, considering an image asset named logo with the following files in the project structure: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png Resources / logo1 @2 x . png Resources / logo2 @3 x . png The deletion tool will track and delete the following files as the image set of the logo asset: Resources / logo . png Resources / logo @2 x . png Resources / logo @3 x . png MFractor will ignore the following files: Resources / logo1 @2 x . png ( Excluded as logo1 is not a match with logo ) Resources / logo2 @3 x . png ( Excluded as logo2 is not a match with logo )","title":"Deleting stand-alone images"},{"location":"image-management/deleting-image-assets/#deleting-images-from-asset-catalogs","text":"For images in Asset Catalogs MFractor will track them a little differently. Image sets in catalogs are tracked through a metadata file called Contents.json , in the same folder of an image set. The images that compose a set in an asset catalog may contain different names because by default Visual Studio and Xcode preserve the original filenames when importing then using the Asset Catalog tool. For this reason MFractor relies on the metadata file to track the files that compose a set. For example, considering again an image asset named logo with the following files in the project structure: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / other . png Assets . xcassets / logo . imageset / other @2 x . png Assets . xcassets / logo . imageset / Contents . json From the files in the project structure we can't define for sure what ones compose the image set. For this reason MFractor will check this information on the Contents.json metadata file. Here we have a simplified snippet of this file: { images : [ { filename : logo.png , scale : 1x , idiom : universal }, { filename : logo@2x.png , scale : 2x , idiom : universal }, { filename : logo@3x.png , scale : 3x , idiom : universal }, { filename : sample.png , appearances : [ { appearance : luminosity , value : dark } ], scale : 1x , idiom : universal }, { filename : sample@3x.png , appearances : [ { appearance : luminosity , value : dark } ], scale : 3x , idiom : universal } ] } From the metadata we can verify that sample.png and sample@3x.png are the dark mode variant of the same image asset, so the deletion tool will delete the following files: Assets . xcassets / logo . imageset / logo . png Assets . xcassets / logo . imageset / logo @2 x . png Assets . xcassets / logo . imageset / logo @3 x . png Assets . xcassets / logo . imageset / sample . png Assets . xcassets / logo . imageset / sample @3 x . png Assets . xcassets / logo . imageset / Contents . json ( metadata file is also deleted because its part of the asset definition ) MFractor will ignore the following files: Assets . xcassets / logo . imageset / other . png ( Not listed in the Contents . json file ) Assets . xcassets / logo . imageset / other @2 x . png ( Not listed in the Contents . json file )","title":"Deleting images from Asset Catalogs"},{"location":"image-management/deleting-image-assets/#launching-the-deletion-tool","text":"","title":"Launching The Deletion Tool"},{"location":"image-management/deleting-image-assets/#solution-explorer","text":"The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image file. Choosing the Delete Image Asset menu option.","title":"Solution Explorer"},{"location":"image-management/deleting-image-assets/#image-asset-manager","text":"The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete OR click on the Delete [image name] button on the bottom of the pane.","title":"Image Asset Manager"},{"location":"image-management/deleting-image-assets/#using-the-deletion-tool","text":"After launching the image deletion tool, you will be presented with the dialog that summaries information about the deletion operation on the selected asset. The dialog is straighforward and present information in two panes: The left pane shows a list of files identified as part of the image set that composes the selected asset. This files are identified following the rules presented on previous sections of this document. The right pane shows a preview of the image asset being deleted. This tool allows you to review the image deletion procedure and check if anything is missing or incorrectly added. By clicking on the Delete Images button the delete operation will be done by MFractor.","title":"Using The Deletion Tool"},{"location":"image-management/image-importer/","text":"Add new image assets into your Android and iOS applications Introduction The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets. Using the Image Importer The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next. Target Projects MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images. Setting the Image Size The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image. Import Image When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Importing Images"},{"location":"image-management/image-importer/#introduction","text":"The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets.","title":"Introduction"},{"location":"image-management/image-importer/#using-the-image-importer","text":"The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be invoked from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next.","title":"Using the Image Importer"},{"location":"image-management/image-importer/#target-projects","text":"MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images.","title":"Target Projects"},{"location":"image-management/image-importer/#setting-the-image-size","text":"The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image.","title":"Setting the Image Size"},{"location":"image-management/image-importer/#import-image","text":"When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Import Image"},{"location":"image-management/managing-image-assets/","text":"A centralised location to easily manage the image assets in your mobile solution Introduction The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Opening The Image Manager The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden: Top Menu By acessing the top menu selecting the Manage Image Assets options. Solution Pad You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list. Overview Filtering Image assets Importing Image Assets Deleting Image Assets Optimising Image Assets Searching For Image Usages Visual Studio Mac Only Drag And Drop The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ; Context Actions In both the image asset list and the image density list, you may right click on any item to launch a context Delete Please see Deleting Image Assets Reveal In Finder/Explorer The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image. Reveal In Project Pad The Reveal Project Pad action will locate the image file in the solution pad. Copy Name To Clipboard The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard. Copy File Path To Clipboard The Copy File Path To Clipboard action copies the file path of that image file to the clipboard. Optimise Please see Optimising Image Assets Open Image The Open action opens the selected image file in the operating systems default image viewer. Search For Usages Please see Searching For Image Usages","title":"Managing Images Assets"},{"location":"image-management/managing-image-assets/#introduction","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location.","title":"Introduction"},{"location":"image-management/managing-image-assets/#opening-the-image-manager","text":"The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden:","title":"Opening The Image Manager"},{"location":"image-management/managing-image-assets/#top-menu","text":"By acessing the top menu selecting the Manage Image Assets options.","title":"Top Menu"},{"location":"image-management/managing-image-assets/#solution-pad","text":"You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list.","title":"Solution Pad"},{"location":"image-management/managing-image-assets/#overview","text":"","title":"Overview"},{"location":"image-management/managing-image-assets/#filtering-image-assets","text":"","title":"Filtering Image assets"},{"location":"image-management/managing-image-assets/#importing-image-assets","text":"","title":"Importing Image Assets"},{"location":"image-management/managing-image-assets/#deleting-image-assets","text":"","title":"Deleting Image Assets"},{"location":"image-management/managing-image-assets/#optimising-image-assets","text":"","title":"Optimising Image Assets"},{"location":"image-management/managing-image-assets/#searching-for-image-usages","text":"Visual Studio Mac Only","title":"Searching For Image Usages"},{"location":"image-management/managing-image-assets/#drag-and-drop","text":"The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ;","title":"Drag And Drop"},{"location":"image-management/managing-image-assets/#context-actions","text":"In both the image asset list and the image density list, you may right click on any item to launch a context","title":"Context Actions"},{"location":"image-management/managing-image-assets/#delete","text":"Please see Deleting Image Assets","title":"Delete"},{"location":"image-management/managing-image-assets/#reveal-in-finderexplorer","text":"The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image.","title":"Reveal In Finder/Explorer"},{"location":"image-management/managing-image-assets/#reveal-in-project-pad","text":"The Reveal Project Pad action will locate the image file in the solution pad.","title":"Reveal In Project Pad"},{"location":"image-management/managing-image-assets/#copy-name-to-clipboard","text":"The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard.","title":"Copy Name To Clipboard"},{"location":"image-management/managing-image-assets/#copy-file-path-to-clipboard","text":"The Copy File Path To Clipboard action copies the file path of that image file to the clipboard.","title":"Copy File Path To Clipboard"},{"location":"image-management/managing-image-assets/#optimise","text":"Please see Optimising Image Assets","title":"Optimise"},{"location":"image-management/managing-image-assets/#open-image","text":"The Open action opens the selected image file in the operating systems default image viewer.","title":"Open Image"},{"location":"image-management/managing-image-assets/#search-for-usages","text":"Please see Searching For Image Usages","title":"Search For Usages"},{"location":"image-management/optimising-image-assets/","text":"Reducing the size your image assets using the image optimiser Introduction MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries. Configuring TinyPNG API Key MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key. Launching The Optimiser The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution. To optimise a single image file Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise To optimise all files of an asset Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise To optimise all images To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user. Processing the files Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Optimising Image Assets"},{"location":"image-management/optimising-image-assets/#introduction","text":"MFractor has a built-in tool that allows automatic compression of the image assets of your projects using the TinyPNG service. This automated optimisation tool allows you to quickly reduce the size of your assets and produce smaller application binaries.","title":"Introduction"},{"location":"image-management/optimising-image-assets/#configuring-tinypng-api-key","text":"MFractor relies on TinyPNG for optimizing the image sizes, an industry standard online image optimization service. For the optimization tool to work you should configure a API Key on the MFractor settings page. Creating an API is quick and straighforward. Head to developer API Page of TinyPNG service: All you need to is provide your full name and email. A link will be sent to your address with a link to your Dashboard, where you will be able to copy your key and check the service usage. Note The TinyPNG offers a free tier that allows processing 500 images per month. After passing this limit you'll have to wait until the month to close or subscribe for a paid plan. Copy the API Key from your Dashboard. Back to Visual Studio open the Preferences and go to the MFractor Settings pane. The last option on this page presents a field where you can copy your TinyPNG key.","title":"Configuring TinyPNG API Key"},{"location":"image-management/optimising-image-assets/#launching-the-optimiser","text":"The optimiser tool is avaiable through the Image Asset Manager pad/toolwindow. There you can invoke the optimiser on a single file, an entire asset or all the image files in the current solution.","title":"Launching The Optimiser"},{"location":"image-management/optimising-image-assets/#to-optimise-a-single-image-file","text":"Follow the steps to optimise a single image file: On the left-pane of the Image Asset Manager select the asset where the file you want to optimise On the right-pane below the preview, select the project where the file resides In the list below the project selection drop-down, select the file you want to optimise Right click on the file and select Optimise","title":"To optimise a single image file"},{"location":"image-management/optimising-image-assets/#to-optimise-all-files-of-an-asset","text":"Follow the steps to optimise all files that compose the image set of a single asset: On the left-pane of the Image Asset Manager select the asset you want to optimise Right click on the file and select Optimise","title":"To optimise all files of an asset"},{"location":"image-management/optimising-image-assets/#to-optimise-all-images","text":"To optimise all image files in the solution, open the Image Asset Manager and click Optimise All Images button, in the bottom part of the left-pane. MFractor will scan all images and present a dialog showing how many optimisation operations will be run for your project: Track your TinyPNG API Usage Always check if your TinyPNG service account has enough compressions credits left for the operations you're about to run. MFractor doesn't check service availability, so the compressions will run until your account run out of credits. If you're using a paid plan, always check your usage before running compressions. TinyPNG bills monthly based on the usage that exceeds the free 500 compressions. MFractor doesn't provide any tool for managing usage or limiting the utilization so this should be managed directly by the end user.","title":"To optimise all images"},{"location":"image-management/optimising-image-assets/#processing-the-files","text":"Weather you select a single file, an asset or all images, the processing is reported through a dialog: When the processing is completed, MFractor will display the summary of the optimisation, where you can check how much space has been saved by running the optimisation.","title":"Processing the files"},{"location":"image-management/overview/","text":"Use MFractors image management suite to import, delete, optimise and manage the image assets in your iOS and Android apps Image Management Tool Suite Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features: Image Asset Manager The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets . Image Importer The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets . Image Deletion Tool The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets . Image Optimiser The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Overview"},{"location":"image-management/overview/#image-management-tool-suite","text":"Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features:","title":"Image Management Tool Suite"},{"location":"image-management/overview/#image-asset-manager","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets .","title":"Image Asset Manager"},{"location":"image-management/overview/#image-importer","text":"The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets .","title":"Image Importer"},{"location":"image-management/overview/#image-deletion-tool","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets .","title":"Image Deletion Tool"},{"location":"image-management/overview/#image-optimiser","text":"The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Image Optimiser"},{"location":"linker/excluding-symbols-from-linker/","text":"Exclude assemblies, classes or members from the Xamarin linker Introduction Linker 101 Define what the linker is? Why do we use it? Using Exclude From Linker Excluding Assemblies Excluding Types Exclude Members","title":"Excluding symbols from linker"},{"location":"linker/excluding-symbols-from-linker/#introduction","text":"","title":"Introduction"},{"location":"linker/excluding-symbols-from-linker/#linker-101","text":"Define what the linker is? Why do we use it?","title":"Linker 101"},{"location":"linker/excluding-symbols-from-linker/#using-exclude-from-linker","text":"","title":"Using Exclude From Linker"},{"location":"linker/excluding-symbols-from-linker/#excluding-assemblies","text":"","title":"Excluding Assemblies"},{"location":"linker/excluding-symbols-from-linker/#excluding-types","text":"","title":"Excluding Types"},{"location":"linker/excluding-symbols-from-linker/#exclude-members","text":"","title":"Exclude Members"},{"location":"linker/linker-intellisense/","text":"Use linker.xml IntelliSense to exclude assemblies, classes or members from the Xamarin linker Introduction Linker IntelliSense","title":"Linker intellisense"},{"location":"linker/linker-intellisense/#introduction","text":"","title":"Introduction"},{"location":"linker/linker-intellisense/#linker-intellisense","text":"","title":"Linker IntelliSense"},{"location":"release-notes/known-issues/","text":"A list of currently known issues in our Visual Studio Windows and Mac products Known Issues Please see our issue tracker for a list of active issues . To submit a new issue, please see our Support documentation.","title":"Known Issues"},{"location":"release-notes/known-issues/#known-issues","text":"Please see our issue tracker for a list of active issues . To submit a new issue, please see our Support documentation.","title":"Known Issues"},{"location":"release-notes/mac/current/","text":"Current Release The current version of MFractor for Visual Studio Mac is v3.9.8. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9 Releases (v3.9) v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bug. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance.","title":"Current Release"},{"location":"release-notes/mac/current/#current-release","text":"The current version of MFractor for Visual Studio Mac is v3.9.8. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Current Release"},{"location":"release-notes/mac/current/#releases-v39","text":"v3.9.8 - Released on January 14th 2020 - Enables image and color tooltips in XAML plus refactorings to move attribute values into static resources. v3.9.7 - Released on January 10th 2020 - Adds product tips that show once per week. v3.9.6 - Released on January 9th 2020 - Support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. v3.9.5 - Released on December 31st 2019 - Fixes several data-binding and style analysis bugs. v3.9.4 - Released on December 23rd 2019 - Hotfix for a localisation wizard issue and activation dialog bug. v3.9.3 - Released on December 11th 2019 - Hotfix to address attribute values not being suggested sometimes during a completion session and several XAML IntelliSense upgrades. v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bug. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance.","title":"Releases (v3.9)"},{"location":"release-notes/mac/v3/v3.10/","text":"v3.10.0 Released on TBD The v3.10 release adds a several refactorings for static resources, localisation tooling, a bulk image deletion tool and fixes several bugs. Features: Localisation Tooling: iOS Bundled Image to ImageSet migration tool. Bulk delete images tool. Enhancements: The Product Tip window will show once per week to help you to learn more about MFractor. We now su Issues Fixed:","title":"V3.10"},{"location":"release-notes/mac/v3/v3.10/#v3100","text":"Released on TBD The v3.10 release adds a several refactorings for static resources, localisation tooling, a bulk image deletion tool and fixes several bugs. Features: Localisation Tooling: iOS Bundled Image to ImageSet migration tool. Bulk delete images tool. Enhancements: The Product Tip window will show once per week to help you to learn more about MFractor. We now su Issues Fixed:","title":"v3.10.0"},{"location":"release-notes/mac/v3/v3.9/","text":"v3.9.8 Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. v3.9.7 Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176 v3.9.6 Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements. v3.9.5 Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 . v3.9.4 Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation. v3.9.3 Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix - Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.2 Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac. v3.9.1 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.0 Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9"},{"location":"release-notes/mac/v3/v3.9/#v398","text":"Released on January 14th 2020 The v3.9.8 release adds color and image tooltips, plus Enhancements: Color Tooltips in XAML. Hover over a color value to preview the color. When MFractor suggests color values via IntelliSense, it also provides a preview as a tooltip. Image tooltips in XAML and C#. Hover over an image name to preview the image. When MFractor suggests image assets values via IntelliSense, it will present a preview of that image. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml.","title":"v3.9.8"},{"location":"release-notes/mac/v3/v3.9/#v397","text":"Released on January 10th 2020 The v3.9.7 release adds a weekly product tip window to help you learn more about MFractor. Enhancements: Color Tooltips in XAML. Image tooltips in XAML. The Product Tip window will show once per week to help you to learn more about MFractor. Static Resource refactorings: Use the Move to App.xaml refactoring to shift a resource from a page or control into the app.xaml file. Use the Refactor into static resource code action to shift an attributes value into a resource entry in the current file or in the App.xaml. Issues Fixed: Fixed: Weird issue with MFractor dialog not being dismissed. #170 Fixed: MFractor VS for Mac Licensing Dialog Issue. #176","title":"v3.9.7"},{"location":"release-notes/mac/v3/v3.9/#v396","text":"Released on January 9th 2020 The v3.9.6 release adds support for Visual Studio Mac 8.4 and introduces the Simplify Types wizard. Enhancements: Support for Visual Studio Mac 8.4. The Simplify Types wizard can be used to convert all qualified types in a file into using statements.","title":"v3.9.6"},{"location":"release-notes/mac/v3/v3.9/#v395","text":"Released on December 31st 2019 The v3.9.5 release fixes several data-binding and style analysis bugs. Issues Fixed: Binding validation error for static source references. #163 MFractor incorrectly reports a style target type mismatch. #173 The MVVM wizard generates invalided code when creating a new view model that uses INotifyPropertyChanged as its base class. #173 .","title":"v3.9.5"},{"location":"release-notes/mac/v3/v3.9/#v394","text":"Released on December 23rd 2019 The 3.9.4 release is a patch release to hotfix a localisation wizard issue and activation dialog bug. Issues Fixed: Localization seems to be incomplete. #175 The activation dialog would not show upon a fresh installation.","title":"v3.9.4"},{"location":"release-notes/mac/v3/v3.9/#v393","text":"Released on December 11th 2019 The 3.9.3 release contains a hot-fix to address attribute values not being suggested sometimes during a completion session. This release also adds multiple IntelliSense items for XAML, a code analyser to inspecting x:FieldModifier and a fix to apply a matching style onto a XAML element. Features: IntelliSense: When editing inside a resource dictionary, we now suggest the available font assets in your mobile solution and generate the font family XAML code for you. The new RepeaterView completion creates a stack layout with the necessary infrastructure for creating a repeater view. FieldModifier value completions. When editing a Thickness, we now suggest the Left, Right, Top and Bottom properties. Code Analysis: We now inspect the value provided to an x:FieldModifier attribute and validate it matches the expected keywords. We\u2019ve added a code-fix to apply a matching style and remove redundant attributes. Access this by right clicking on the issue and choosing Fix - Apply style \u2018styleName\u2019 We\u2019ve added a refresh button to the image manager so that you can force the image manager to reload. Issues Fixed: Fixed: When I press \"Control+Space\" to activate IntelliSense inside an empty attribute, no intellisense items are provided. #169 Fixed: Delete Output Folders Preferences Behave strangely if you have a solution and a project with the same name. #168 Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.3"},{"location":"release-notes/mac/v3/v3.9/#v392","text":"Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac.","title":"v3.9.2"},{"location":"release-notes/mac/v3/v3.9/#v391","text":"Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.1"},{"location":"release-notes/mac/v3/v3.9/#v390","text":"Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9.0"},{"location":"release-notes/windows/current/","text":"The current version of MFractor for Visual Studio Windows is v0.2.0 Releases (v0.2) v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows.","title":"Current Release"},{"location":"release-notes/windows/current/#releases-v02","text":"v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows.","title":"Releases (v0.2)"},{"location":"release-notes/windows/v0/v0.1/","text":"v0.1.1 Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1"},{"location":"release-notes/windows/v0/v0.1/#v011","text":"Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1.1"},{"location":"release-notes/windows/v0/v0.2/","text":"v0.2.0 Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accesibile through Extensions - MFractor - Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2"},{"location":"release-notes/windows/v0/v0.2/#v020","text":"Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accesibile through Extensions - MFractor - Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2.0"},{"location":"utilities/clean-and-compress/","text":"Quickly create a zip archive for solution or projects Introduction The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac. Archiving Solutions To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop. Archiving Projects To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop. Example","title":"Clean And Compress"},{"location":"utilities/clean-and-compress/#introduction","text":"The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/clean-and-compress/#archiving-solutions","text":"To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop.","title":"Archiving Solutions"},{"location":"utilities/clean-and-compress/#archiving-projects","text":"To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop.","title":"Archiving Projects"},{"location":"utilities/clean-and-compress/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/","text":"Remove the working and output folders for a solution or project Introduction The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac. Using Delete Output Folders To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system. Example Configuring Delete Output Folders The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Delete Output Folders"},{"location":"utilities/delete-output-folders/#introduction","text":"The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/delete-output-folders/#using-delete-output-folders","text":"To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system.","title":"Using Delete Output Folders"},{"location":"utilities/delete-output-folders/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/#configuring-delete-output-folders","text":"The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Configuring Delete Output Folders"},{"location":"utilities/edit-shared-project-items/","text":"Edit the msbuild for a shared project Introduction One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to. Editing Shared Project Items Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Edit Shared Project Items"},{"location":"utilities/edit-shared-project-items/#introduction","text":"One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to.","title":"Introduction"},{"location":"utilities/edit-shared-project-items/#editing-shared-project-items","text":"Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Editing Shared Project Items"},{"location":"xamarin-forms/overview/","text":"Introduction MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite. Xamarin.Forms Features XAML Editor XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation. MVVM Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard. Search Static resource global search. Dynamic resource global search. AutomationID global search. Localisation Generating localisation infrastructure. Localising XAML files. Custom Renderers Finding custom renderers. Creating custom renderers. Custom Controls Creating bindable properties . Extracting XAML controls . Styles Extracting XAML styles. Style analysis. Value Converters Value converter wizard. Value converter analysis.","title":"Overview"},{"location":"xamarin-forms/overview/#introduction","text":"MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite.","title":"Introduction"},{"location":"xamarin-forms/overview/#xamarinforms-features","text":"","title":"Xamarin.Forms Features"},{"location":"xamarin-forms/overview/#xaml-editor","text":"XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation.","title":"XAML Editor"},{"location":"xamarin-forms/overview/#mvvm","text":"Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard.","title":"MVVM"},{"location":"xamarin-forms/overview/#search","text":"Static resource global search. Dynamic resource global search. AutomationID global search.","title":"Search"},{"location":"xamarin-forms/overview/#localisation","text":"Generating localisation infrastructure. Localising XAML files.","title":"Localisation"},{"location":"xamarin-forms/overview/#custom-renderers","text":"Finding custom renderers. Creating custom renderers.","title":"Custom Renderers"},{"location":"xamarin-forms/overview/#custom-controls","text":"Creating bindable properties . Extracting XAML controls .","title":"Custom Controls"},{"location":"xamarin-forms/overview/#styles","text":"Extracting XAML styles. Style analysis.","title":"Styles"},{"location":"xamarin-forms/overview/#value-converters","text":"Value converter wizard. Value converter analysis.","title":"Value Converters"},{"location":"xamarin-forms/tooltips/","text":"Introduction XAML Tooltips Grids Colors Thicknesses","title":"Tooltips"},{"location":"xamarin-forms/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/tooltips/#xaml-tooltips","text":"","title":"XAML Tooltips"},{"location":"xamarin-forms/tooltips/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/tooltips/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/tooltips/#thicknesses","text":"","title":"Thicknesses"},{"location":"xamarin-forms/xaml-intellisense/","text":"TODO: An overview of MFractors XAML intellisense integration. Introduction IntelliSense Features Data-Binding Grids Static Resources Dynamic Resources Images Colors DataTriggers Setter's StackLayout's","title":"Xaml intellisense"},{"location":"xamarin-forms/xaml-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/xaml-intellisense/#intellisense-features","text":"","title":"IntelliSense Features"},{"location":"xamarin-forms/xaml-intellisense/#data-binding","text":"","title":"Data-Binding"},{"location":"xamarin-forms/xaml-intellisense/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/xaml-intellisense/#static-resources","text":"","title":"Static Resources"},{"location":"xamarin-forms/xaml-intellisense/#dynamic-resources","text":"","title":"Dynamic Resources"},{"location":"xamarin-forms/xaml-intellisense/#images","text":"","title":"Images"},{"location":"xamarin-forms/xaml-intellisense/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/xaml-intellisense/#datatriggers","text":"","title":"DataTriggers"},{"location":"xamarin-forms/xaml-intellisense/#setters","text":"","title":"Setter's"},{"location":"xamarin-forms/xaml-intellisense/#stacklayouts","text":"","title":"StackLayout's"},{"location":"xamarin-forms/analysis/overview/","text":"","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/automatic-viewmodel-detection/","text":"MFractor uses automatic ViewModel resolution to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention. Let's consider the following files: LoginPage.xaml - The XAML view. LoginPage.xaml.cs - The code behind for the XAML view. LoginViewModel - The a C# class that is the view model for the LoginPage view. Because these pages share the prefix Login and each has a distinct file extension or suffix, MFractor assumes the following relationships: The .xaml extension denotes that LoginPage.xaml is a xaml view. The .xaml.cs extension and the LoginPage component denotes that LoginPage.xaml.cs is the code behind implementation LoginPage view. The ViewModel suffix implies that LoginViewModel is a view model. When ViewModel is removed from LoginViewModel and Page is removed from LoginPage, the Login component implies that the LoginViewModel is related to the LoginPage XAML view and it's code behind file. MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that LoginViewModel will probably be the BindingContext for LoginPage. The Page - ViewModel naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM. The following suffixes are supported for XAML views: Page: EG LoginPage.xaml - LoginViewModel View: EG LoginView.xaml - LoginViewModel The following suffixes are supported for View Models. ViewModel: LoginPage.xaml - LoginViewModel PageModel: LoginView.xaml - LoginPageModel PageViewModel: LoginView.xaml - LoginPageViewModel Model: LoginView.xaml - LoginModel VM: LoginView.xaml - LoginVM PageVM: LoginView.xaml - LoginPageVM","title":"Automatic ViewModel Detection"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/","text":"Binding Context Evaluation In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: Entry BindingContext = {x:Static local:MyStaticClass.MyStaticProperty} / This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel (); } } LoginPage.xaml ContentPage xmlns : local = clr-namespace:MyApp;assembly=MyApp BindingContext = {x:Static local:ViewModelLocator.LoginViewModel} / When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: Switch x : Name = mySwitch / Label BindingContext = {x:Reference mySwitch} IsVisible = {Binding IsToggled} / When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"BindingContext Evaluation"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/#binding-context-evaluation","text":"In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: Entry BindingContext = {x:Static local:MyStaticClass.MyStaticProperty} / This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel (); } } LoginPage.xaml ContentPage xmlns : local = clr-namespace:MyApp;assembly=MyApp BindingContext = {x:Static local:ViewModelLocator.LoginViewModel} / When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: Switch x : Name = mySwitch / Label BindingContext = {x:Reference mySwitch} IsVisible = {Binding IsToggled} / When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"Binding Context Evaluation"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/","text":"Cross Project Binding Context Resolution If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewModelsProjectName value= TODO: Insert the name of your view models project as it appears in the solution explorer / /configure /mfractor In the project that contains your view models, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewsProjectName value= TODO: Insert the name of your views project as it appears in the solution explorer / /configure /mfractor","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/#cross-project-binding-context-resolution","text":"If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewModelsProjectName value= TODO: Insert the name of your view models project as it appears in the solution explorer / /configure /mfractor In the project that contains your view models, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewsProjectName value= TODO: Insert the name of your views project as it appears in the solution explorer / /configure /mfractor","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/","text":"Data Template Binding Context Resolution Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: ListView ItemsSource= {Binding Contacts} ListView.ItemTemplate DataTemplate TextCell Text= {Binding DisplayName} / /DataTemplate /ListView.ItemTemplate /ListView The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"DataTemplate Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/#data-template-binding-context-resolution","text":"Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: ListView ItemsSource= {Binding Contacts} ListView.ItemTemplate DataTemplate TextCell Text= {Binding DisplayName} / /DataTemplate /ListView.ItemTemplate /ListView The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"Data Template Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/","text":"It's also possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To get started, add the following code file to your project: DesignTimeBindingContextAttribute.cs using System ; namespace MyApp . Attributes { /// summary /// Apply the design time binding context attribute to your code - behind class to inform tools of your intended runtime binding context . /// / summary [ AttributeUsage ( AttributeTargets . Class , AllowMultiple = false ) ] public class DesignTimeBindingContextAttribute : Attribute { /// summary /// Specifies the design time binding context using a fully qualified type name . /// /// For example : MyApp . ViewModels . LoginViewModel . /// / summary /// param name = typeName The fully qualified type name for the design time binding context . / param public DesignTimeBindingContextAttribute ( string typeName ) { } /// summary /// Specifies the design time binding context using typeof () . /// /// For example : typeof ( LoginViewModel ) /// / summary /// param name = type The see cref = System.Type / for the design time binding context , using typeof () . / param public DesignTimeBindingContextAttribute ( Type type ) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/overview/","text":"Binding Context Resolution MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article. Resolution Methods MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/overview/#binding-context-resolution","text":"MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article.","title":"Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/overview/#resolution-methods","text":"MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Resolution Methods"},{"location":"xamarin-forms/code-actions/overview/","text":"","title":"Overview"},{"location":"xamarin-forms/colors/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/colors/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/","text":"Generate the C# code to declare a new attached property declaration Introduction In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty . CreateAttached ( HasShadow , typeof ( bool ) , typeof ( MyClass ) , default ( bool )) ; public static bool GetHasShadow ( BindableObject target ) { return ( bool ) target . GetValue ( HasShadowProperty ) ; } public static void SetHasShadow ( BindableObject target , bool value ) { target . SetValue ( HasShadowProperty , value ) ; } Usage Example Label local : MyClass . HasShadow = true / One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Attached Property Wizard To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#introduction","text":"In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty . CreateAttached ( HasShadow , typeof ( bool ) , typeof ( MyClass ) , default ( bool )) ; public static bool GetHasShadow ( BindableObject target ) { return ( bool ) target . GetValue ( HasShadowProperty ) ; } public static void SetHasShadow ( BindableObject target , bool value ) { target . SetValue ( HasShadowProperty , value ) ; } Usage Example Label local : MyClass . HasShadow = true / One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#using-the-attached-property-wizard","text":"To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#automatic-type-inference","text":"The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/","text":"Generate the C# code to declare a new bindable property for a custom control Introduction When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get = (bool)GetValue(HasShadowProperty); set = SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Bindable Property Wizard To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#introduction","text":"When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get = (bool)GetValue(HasShadowProperty); set = SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#using-the-bindable-property-wizard","text":"To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#automatic-type-inference","text":"One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/","text":"Move a XAML layout usage into its own reusable custom control Introduction When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control. Using The Extract Control Refactoring To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Extracting Custom Controls"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#introduction","text":"When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#using-the-extract-control-refactoring","text":"To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Using The Extract Control Refactoring"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/","text":"Coming soon TODO: Discuss how to use the Find Custom Renderers feature.","title":"Find custom renderers"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/","text":"","title":"Generate custom renderers"},{"location":"xamarin-forms/dynamic-resources/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/dynamic-resources/navigation/","text":"","title":"Navigation"},{"location":"xamarin-forms/dynamic-resources/search/","text":"","title":"Search"},{"location":"xamarin-forms/dynamic-resources/tooltips/","text":"","title":"Tooltips"},{"location":"xamarin-forms/grids/analysis/","text":"","title":"Analysis"},{"location":"xamarin-forms/grids/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/grids/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/grids/tooltips/","text":"","title":"Tooltips"},{"location":"xamarin-forms/search/automationid-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Automationid search"},{"location":"xamarin-forms/search/automationid-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/automationid-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/dynamic-resource-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Dynamic resource search"},{"location":"xamarin-forms/search/dynamic-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/dynamic-resource-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/static-resource-search/","text":"Search your solution for static resources Introduction Dynamic Resource Overview Declaraing Dynamic Resources Using Dynamic Resources Using Dynamic Resource Search","title":"Static resource search"},{"location":"xamarin-forms/search/static-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/static-resource-search/#dynamic-resource-overview","text":"","title":"Dynamic Resource Overview"},{"location":"xamarin-forms/search/static-resource-search/#declaraing-dynamic-resources","text":"","title":"Declaraing Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resources","text":"","title":"Using Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resource-search","text":"","title":"Using Dynamic Resource Search"},{"location":"xamarin-forms/value-converters/value-converter-analysis/","text":"","title":"Value converter analysis"},{"location":"xamarin-forms/value-converters/value-converter-wizard/","text":"Quickly create a Value Converter and reference it on your XAML code Introduction Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic. Using the Wizard The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows: Name and Location Parameters Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters . Type Parameters Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object . Input Type Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method. Output Type Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned. Parameter Type Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: Label Text= {Binding Text, Converter={StaticResource converterReference}, ConverterParameter= parameter data } / The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type. Optional XML Entry Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: ResourceDictionary converters:BoolNegationConverter x:Key= boolNegationConverter / /ResourceDictionary MFractor will also take care of adding the required namespace imports to the file. Default Code Snippet This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Value Converter Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#introduction","text":"Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic.","title":"Introduction"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#using-the-wizard","text":"The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows:","title":"Using the Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#name-and-location-parameters","text":"Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters .","title":"Name and Location Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#type-parameters","text":"Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object .","title":"Type Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#input-type","text":"Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method.","title":"Input Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#output-type","text":"Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned.","title":"Output Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#parameter-type","text":"Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: Label Text= {Binding Text, Converter={StaticResource converterReference}, ConverterParameter= parameter data } / The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type.","title":"Parameter Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#optional-xml-entry","text":"Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: ResourceDictionary converters:BoolNegationConverter x:Key= boolNegationConverter / /ResourceDictionary MFractor will also take care of adding the required namespace imports to the file.","title":"Optional XML Entry"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#default-code-snippet","text":"This is the default code snippet of a Value Converter file. using System ; using System.Globalization ; using Xamarin.Forms ; namespace [ DefaultProjectNamespace ]. Converters { [ValueConversion(typeof(object), typeof(object))] public class $ name $ : IValueConverter { public object Convert ( object value , Type targetType , object parameter , CultureInfo culture ) { if ( value is object == false ) { return default ( object ); } var input = ( object ) value ; var param = ( object ) parameter ; // TODO: Put your value conversion logic here. return default ( object ); } public object ConvertBack ( object value , Type targetType , object parameter , CultureInfo culture ) { throw new NotImplementedException (); } } }","title":"Default Code Snippet"},{"location":"xamarin-forms/working-with-styles/extracting-styles/","text":"A rich toolbox for quickly extract and organize XAML styles. Introduction Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply. How to Extract a style The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: Label HorizontalTextAlignment= Center FontFamily= {StaticResource OpenSans} FontSize= Large Text= Welcome to MFractor Docs! / If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style. Configuring the Style Extraction The extraction dialog offer several options to control how the extraction will be done. Name The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element. TargetType The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes. Target Type Xmlns This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: Style x:Key= [styleName] TargetType= views:Label !-- The rest of the style declaration -- /Style File The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application. Parent The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey= [ParentResourceKey] For a BasedOn parent type, the output will be: BasedOn= {StaticResource [ParentResourceKey]} If you leave the parent resource key field blank the parent declaration will be supressed. Properties The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style. Previewing the new Style The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: Style x:Key= [styleName] TargetType= [TargetType] BaseResourceKey= [ParentResouceKey] BasedOn= {StaticResource [ParentResourceKey]} Setter Property= [PropertyName] Value= [PropertyValue] / !-- Repeats for each property set in the dialog... -- /Style Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section. Extracting the Style By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: Label Style= {StaticResource defaultLabel} / Summary The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Extracting Styles"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#introduction","text":"Styles are a basic construction block for UI components that allows configuring a set of common properties that we may want to apply to several views. They're very useful, but also, very hard to manage. With MFractor XAML Style toolset, which includes the Style Extraction Tool and the Matching Style Code Analysis, you can quickly create styles from existing views and identify ones which a existing style may apply.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#how-to-extract-a-style","text":"The XAML Style extraction tool is presented as a Code Action in the XAML editor. The option becomes available to the context menu when the cursor is placed over any XAML element. For example, considering you have the declaration of a Label with some properties set: Label HorizontalTextAlignment= Center FontFamily= {StaticResource OpenSans} FontSize= Large Text= Welcome to MFractor Docs! / If you right-click on the Label declaration, the extraction tool will be available as option on the Refactor menu: Selecting this option will present the XAML Style Editor dialog, that allows you to extract the properties currently set for the select element (or any additional properties you wish) into a new style, and substitute the properties declaration with the newly created style.","title":"How to Extract a style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#configuring-the-style-extraction","text":"The extraction dialog offer several options to control how the extraction will be done.","title":"Configuring the Style Extraction"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#name","text":"The name of the new style. This will be used as the key for the Resource Dictionary entry of the style declaration, and is the key to reference on the Style property of a XAML element.","title":"Name"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#targettype","text":"The TargetType is the .NET Fully Qualified Name of the type to which the new style is intended to be applied. In the example above, we are extracting a style from a Label component, which is a native Xamarin.Forms component represented by the Xamarin.Forms.Label type. The value you set here will be used on the TargetType property of the style declaration in XAML, and defines the type of components to which the style can be applied. By default MFractor will fill in with the type from where you\u00b4ve invoked the Code Action, but you can change to any type you wish. The more specific is the type you set as the Target of your style, the more properties of this type becomes available to the setters of the style, but you can also create more generic styles by referencing a common ancestor of the XAML elements, like View or VisualElement . A style with one of those target types may be applied both to a Button or a Label , as to any component that derives from those base classes.","title":"TargetType"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#target-type-xmlns","text":"This is a second field related to the Target Type declaration. This one is used when you're extracting a style that you may wish to apply to non-standard Xamarin.Forms components, such as custom XAML Views or Third-Party components. Here you specify the single name of the XML namespace you want to declare to reference the type. Adding this information will impact how the Target Type field is rendered on the code of the new style. For example, if you set this field views , the output code will be: Style x:Key= [styleName] TargetType= views:Label !-- The rest of the style declaration -- /Style","title":"Target Type Xmlns"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#file","text":"The File field is a drop-down that you can select where to add the new style that will be created. Defaults to the current XAML from where you've invoked the code action, but you can also add the style to the App.xaml file of the project (if exists) and make the new style shared among the whole application.","title":"File"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#parent","text":"The XAML Styles framework allows the creation of a hierarchy of styles, much like you can do with Cascading Style Sheets (CSS, which are also available to Xamarin.Forms components but currently not supported by the MFractor tooling). This means that you can create more generic styles that can be used as the base or template of a new style. When you create a hierarchy of styles, every property set on a parent style is propagated to the child ones, unless a property is explicitly overriden by being declared on this child. Note There are several ways of organizing styles into hierarchies but this topic is beyond the scope of this documentation. Parenting also has implications on dynamic styles, that allows it to be dynamically changed during the runtime of the application, typically for applying different themes, such as light and dark variations of the app visuals. The XAML Style Extraction tool allows you to specify the parent of the new style. There are two fields to this section: Parent Type : a drop-down that allows selecting between BaseResourceKey and BasedOn properties to specify the parent resolution. Resource Key : the text field below the parent type where you can type the resource key of the style that should be parent of this one. Combined, this two fields controls how the declaration of the parent will be added to the new style that will be generated. For a BaseResourceKey parent type, the output will be: BaseResourceKey= [ParentResourceKey] For a BasedOn parent type, the output will be: BasedOn= {StaticResource [ParentResourceKey]} If you leave the parent resource key field blank the parent declaration will be supressed.","title":"Parent"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#properties","text":"The Properties section presents a grid that allows you to define which properties you want to include to the new style. MFractor will automatically load all the properties it find from the element declaration in the XAML. This tool allows you to: Check/Uncheck a single property entry to be added or excluded from the new style Change value of a property By clicking on the checkbox to Show All Properties , MFractor will load every property from the specified target type, allowing you to include properties that wasn't initially declared on the component from where you've invoked the code action: In the field above the list you can type for searching for specific properties: This tool allow for fine-grained tuning of the new style you want to create and is a powerful editor to avoid having to type all the setters on the XAML style.","title":"Properties"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#previewing-the-new-style","text":"The right pane of the Extraction dialog presents a preview of the style that will be generated, based on the properties previously set. This allows you to review your settings before executing the extraction. The default snippet for the style generation is: Style x:Key= [styleName] TargetType= [TargetType] BaseResourceKey= [ParentResouceKey] BasedOn= {StaticResource [ParentResourceKey]} Setter Property= [PropertyName] Value= [PropertyValue] / !-- Repeats for each property set in the dialog... -- /Style Notice that BaseResourceKey and BasedOn are mutually excludent based on the selection you make from the Parent options, like mentioned in the Parent section.","title":"Previewing the new Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#extracting-the-style","text":"By clicking on the Extract Styles button the extraction will be processed accordingly to the options you've set. The newly created style will be applied to the element where you have invoked the tool and all the properties selected to be included in the new style will be removed from its declaration. Following on our previous example, if we create a new style with the name defaultLabel and include all the properties previously set to the component this is the end result: Label Style= {StaticResource defaultLabel} /","title":"Extracting the Style"},{"location":"xamarin-forms/working-with-styles/extracting-styles/#summary","text":"The extraction XAML Style tool allows you to quickly extract common properties that you may want to set on several controls into a XAML Style. MFractor also provides the Matching Style Code Analysis that helps identify places where existing styles can be applied. Check its documentation for further details.","title":"Summary"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/","text":"Inspects XAML elements that do not have a style applied and, if possible, matches them to an available style that targets the element type and also applies the same properties. Introduction Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties. Matching style detection The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element. Applying a matching style When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style. Disabling this Code Analysis The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Matching Style Analysis"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#introduction","text":"Styles are a core building block of complex UI applications in Xamarin.Forms. They allow the creation of specifications that can be easily applied to common visual components. Although being very useful and simple to use, styles can become hard to track and manage overtime. This code analysis aids in managing the complexity of styles by inspecting elements that do not have a style applied and, if possible, matching them to an available style that targets the element type and also applying the same properties.","title":"Introduction"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#matching-style-detection","text":"The steps to find a matching style are: Check if the element has any attributes declared Check if an exising style attribute hasn't been declared If both predicates are true, MFractor will load a list of the styles declared locally or globally that can be applied to that Target Type, which includes not just the type itself, but any of it's ancestor types. Then, for each of the styles, MFractor will check if the declared attributes matches the setters of the style, and also if the values matches. In that case the style is identified as a match, and the code analysis presents a warning to indicate the user an available style that can be applied to that element.","title":"Matching style detection"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#applying-a-matching-style","text":"When MFractor Code Analysis identify an element that may be simplified by replacing the property declarations with an existing style, it will add yellow squiggles on the bottom of the component to indicate the available refactoring. Right-click on the element and on the Fix menu an option should appear as Apply style 'styleName' : Applying the fix will replace all the attributes declared in the property to a single attribute Style referecing the matching style.","title":"Applying a matching style"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/#disabling-this-code-analysis","text":"The matching style code analysis can be disabled on MFractor settings. Open the Visual Studio Preferences and on the Code Analysis on the MFractor section of the preferences pages, search for MF1082 : This is code of the analyzer that implements this feature, and is identified by the Element Can Use Available Styler (MF1082) name. Click on the checkbox to enable or disable it.","title":"Disabling this Code Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Data Binding Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/","text":"Introduction Using Data-Binding IntelliSense","title":"Data Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#using-data-binding-intellisense","text":"","title":"Using Data-Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/generating-properties-and-commands/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Generating Properties/Commands"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/","text":"Quickly and easily create a new MVVM Component This feature is available to MFractor Professional Introduction When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file. Using the MVVM Wizard The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented. Wizard Options The Wizard is pretty simple and only asks you about two pieces of information: Target Project A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created. Name The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings . Previewing the files The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code. Wizard Settings As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard. Wizard Settings Options The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options. View Project A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. View Suffix Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page View Folder Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages View Base Class and XML Namespace This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to namespace:ClassName to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages Binding Context Initialisation In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers. Initialise BindingContext in Code-Behind This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel = BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } } Initialise BindingContext in XAML This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: ContentPage xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml xmlns= http://xamarin.com/schemas/2014/forms x:Class= MFractor.Samples.Pages.Page xmlns:viewModels= clr-namespace:MFractor.Samples.ViewModels ContentPage.BindingContext viewModels:ViewModel x:Key= ViewModel / /ContentPage.BindingContext /ContentPage Register Withing Application.RegisterTypes Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation Pages . HomePage , ViewModels . HomeViewModel (); } ViewModel Project A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files. ViewModel Suffix Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel ViewModel Folder Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels ViewModel Base Class Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix . Reseting Settings If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#introduction","text":"When working on Xamarin.Forms projects and applying the MVVM pattern, most of the time you will be creating a XAML Page or View alongside with it's View Model. This is normally a two step process where you need to create the Page/View and then a new class file for it's View Model. Also, you'll probably need to setup the View Model that usually derives from a base class, and you may also wish to change the Page/View to derive from a different class the default templates. Those are recurring time-consuming, error prone and boring tasks. Enters the MVVM Wizard . This is a simple tool to allow you to quickly and easly create a new MVVM Component based on the standards and conventions you set once for the solution you're working on. Info A MVVM Component is considered the set of files that compose a Xamarin.Forms Page or View component with its corresponding View Model: the XAML file, its code-behind and the View Model class file.","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#using-the-mvvm-wizard","text":"The MVVM Wizard is presented as a dialog that can be invoked from MFractor Top Level Wizards menu: This option becomes visible when you're working on a solution with at least one Xamarin.Forms project. By selecting it the Wizard dialog will be presented.","title":"Using the MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-options","text":"The Wizard is pretty simple and only asks you about two pieces of information:","title":"Wizard Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#target-project","text":"A drop-down allowing the selection of the project where the pieces of the MVVM Components will be created.","title":"Target Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#name","text":"The name of the MVVM Component you're going to create. You should provide the base name without any suffixes. They'll be added to the file/class names accordingly to the standard conventions: View files will append the Page suffix View Model files will append the ViewModel suffix. You can change this behavior on the Wizard Settings .","title":"Name"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#previewing-the-files","text":"The MVVM Wizard allows you to preview the files that will be generated. In the middle section you'll find two panes: The left pane allows you to preview the files of the View , either the XAML and its code-behind file. You can switch between then using the drop-down. The right pane allows to preview the View Model file. Note Even though the preview panes allows for editing its contents, the changes won't be persisted on the generated code.","title":"Previewing the files"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings","text":"As we've seen in the previous section, the usage of the Wizard is very straightforward, as it is made to be quick and simple to use. By default it will use the most common conventions we've captured from the Xamarin community. Yet, the wizard is powerful enough to allow for further customization of those conventions. By clicking on the Settings button of the dialog by the right side of the Name field, you will be presented with the Project MVVM Settings , which allows will to customize every aspect of the wizard.","title":"Wizard Settings"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#wizard-settings-options","text":"The Project MVVM Settings dialog allows configuring several aspects of the MVVM Component generation. This section provides an in-depth description of each of this options.","title":"Wizard Settings Options"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-project","text":"A drop-down field allowing you to select the project where the View (xaml and code-behind) part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"View Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-suffix","text":"Allows you to specify the suffix that will be added to the file name of the View. This affects the files and class names for that View. Defaults to Page","title":"View Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-folder","text":"Allows you to specify in which folder inside the View Project you want the View files (XAML and the code-behind) to be created. You may specify sub-folders by using slash separator / . Defaults to Pages","title":"View Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#view-base-class-and-xml-namespace","text":"This is a pair of related fields and allows you to specify the base class for the View component being created. Most Xamarin.Forms projects implements a custom base Page or View class for shared logic. You should provide the FQN (Fully Qualified Name) of the type to be used as base class. This settings affects the behavior of the wizard in the following ways: In the XAML File : a XML namespace will be added to the root element to import the namespace where the class is declared. The root element will be changed to namespace:ClassName to reference the base class in the XAML code. In the Code-Behind File : the class will derive from the typed base class. View Base Class defaults to Xamarin.Forms.ContentPage View Base Class XML Namespace defaults to pages","title":"View Base Class and XML Namespace"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#binding-context-initialisation","text":"In the MVVM Pattern the BindingContext property of the View part is usually initialized with an instance of the View Model. This may be done in several ways, depending on the conventions or additional frameworks you may use for your project. The MVVM Wizard can add initialization code to the new MVVM Component and you can choose the initialization strategy from 3 templates. Info The first two options for BindingContext initialization relies on the View Model class having a parameterless constructor. If your implementation of the View Model relies on custom initialization, such as relying on dependency injection, you should avoid using those initializers.","title":"Binding Context Initialisation"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-code-behind","text":"This option will append initialization code in the code-behind class of the View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a public automatic property named ViewModel of the type of the View Model class. This property resolves to casting the BindingContext property to the type of the View Model class. Initializes the BindingContext with a new instance of the View Model class. This code snippet examples the additions to the code-behind code: using System ; namespace MFractor.Samples.Pages { public partial class Page : Xamarin . Forms . ContentPage { public MFractor . Samples . ViewModels . ViewModel ViewModel = BindingContext as MFractor . Samples . ViewModels . ViewModel ; public Page () { BindingContext = new MFractor . Samples . ViewModels . ViewModel (); InitializeComponent (); } } }","title":"Initialise BindingContext in Code-Behind"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#initialise-bindingcontext-in-xaml","text":"This option will append initialization code in the XAML View file, and affects the behavior of the MVVM Wizard in the following ways: Adds a XML Namespace declaration named viewModels to reference the namespace of the View Model class file. Adds a declaration of the View Model object to the BindingContext property below the root View element. This code snippet examples the additions to the View code: ContentPage xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml xmlns= http://xamarin.com/schemas/2014/forms x:Class= MFractor.Samples.Pages.Page xmlns:viewModels= clr-namespace:MFractor.Samples.ViewModels ContentPage.BindingContext viewModels:ViewModel x:Key= ViewModel / /ContentPage.BindingContext /ContentPage","title":"Initialise BindingContext in XAML"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#register-withing-applicationregistertypes","text":"Prism is a framework for easing the development of XAML applications, and is becoming a popular choice for Xamarin.Forms apps. It can automatically binds the View Model with its View, which also allows for View Model navigation, one of the most popular features of the framework. To take advantage of this feature you must register your Views and View Models at the application Startup. MFractor allows for automatically adding this registration for the new MVVM Component being created. When you select this binding initialization method the MVVM Wizard will add the registration of the View and View Model parts being created to the RegisterTypes method in the App class file. This code snippet examples the code that is added to the files: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // // Previous container registrations containerRegistry . RegisterForNavigation Pages . HomePage , ViewModels . HomeViewModel (); }","title":"Register Withing Application.RegisterTypes"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-project","text":"A drop-down field allowing you to select the project where the View Model part of the MVVM Component should be created. This allows fine-grained tuning on solutions where you may have separate projects for hosting View and View Model files.","title":"ViewModel Project"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-suffix","text":"Allows you to specify the suffix that will be added to the class name of the View Model. Defaults to ViewModel","title":"ViewModel Suffix"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-folder","text":"Allows you to specify in which folder inside the View Model Project you want the View Model file to be created. You may specify sub-folders by using slash separator / . Defaults to ViewModels","title":"ViewModel Folder"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#viewmodel-base-class","text":"Allows you to specify the class to which the View Model class will derive when the MVVM Component is created. You should provide a .NET Fully Qualified Name of the type to be used as base class. Setting a value for this field affects the wizard so it will add the using statement for the namespace of the class and add the inheritance declaration. If this field is left blank, MFractor will supress the declaration of a base class for the View Model. Defaults to empty. MFractor can aid you in finding the most likely View Model base class based on your project existing View Models. With this feature all the existing View Model classes will be inspected and the mostly used base class among the the files will be suggested as the base class setting. To use this feature click on the wand button on the right side of the ViewModel Base Class field: MFractor will consider a class as a View Model based on all the previous settings from this dialog. So for the defaults settings, it will scan the files the View Model Project , inside the View Model Folder whose the class names end with the View Model Suffix .","title":"ViewModel Base Class"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/#reseting-settings","text":"If you want to restore the settings for the default conventions, just click the Reset Settings buttons and they will be set to its defaults. You need to click the Save button to persist this changes.","title":"Reseting Settings"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28 Quickly switch among the three core components of the MVVM pattern Introduction The MVVM (Model-View-ViewModel) Pattern is considered one if core architectural patterns of a Xamarin.Forms application. By convention, a single View is composed by three files: The XAML View file ( .xaml ) It's code-behind file ( .xaml.cs ) The View Model that will provide the features of the view (a C# class contained on its own .cs file) The first two files are kept together, the later is usually kept on a ViewModels folders, where all the View Models are declared. Sometimes this makes hard to navigate between those files. Enters the MVVM Navigation feature of MFractor. The convention for this pattern is to keep each part contained on it's on file where Views are kept on it's XAML file, What is a view? What is a view model? What is their relationship? Navigating Between MVVM Components To facilitate navigating among these components, MFractor adds shortcuts to a few places in the Visual Studio IDE, so you can quickly access the counterparts of the current file you're working. They appear in the context menu of the active document and Navigating to a View Highlight shortcut is Command+Shift+3 Navigating to a ViewModel Highlight shortcut is Command+Shift+1 Navigating to a Code Behind Highlight shortcut is Command+Shift+2 MVVM File Group Detection MFractor will detect the View Model of a View/Code-Behind using the following convention:","title":"View-ViewModel Navigation"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#introduction","text":"The MVVM (Model-View-ViewModel) Pattern is considered one if core architectural patterns of a Xamarin.Forms application. By convention, a single View is composed by three files: The XAML View file ( .xaml ) It's code-behind file ( .xaml.cs ) The View Model that will provide the features of the view (a C# class contained on its own .cs file) The first two files are kept together, the later is usually kept on a ViewModels folders, where all the View Models are declared. Sometimes this makes hard to navigate between those files. Enters the MVVM Navigation feature of MFractor. The convention for this pattern is to keep each part contained on it's on file where Views are kept on it's XAML file, What is a view? What is a view model? What is their relationship?","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-between-mvvm-components","text":"To facilitate navigating among these components, MFractor adds shortcuts to a few places in the Visual Studio IDE, so you can quickly access the counterparts of the current file you're working. They appear in the context menu of the active document and","title":"Navigating Between MVVM Components"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-view","text":"Highlight shortcut is Command+Shift+3","title":"Navigating to a View"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-viewmodel","text":"Highlight shortcut is Command+Shift+1","title":"Navigating to a ViewModel"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#navigating-to-a-code-behind","text":"Highlight shortcut is Command+Shift+2","title":"Navigating to a Code Behind"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/#mvvm-file-group-detection","text":"MFractor will detect the View Model of a View/Code-Behind using the following convention:","title":"MVVM File Group Detection"}]}