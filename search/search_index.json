{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to the documentation for MFractor, a powerful productivity tool for Visual Studio Windows and Mac to streamline the development of Xamarin applications. Getting Started To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac Help And Support To get help using MFractor, please see our Support article. Licensing MFractor's licensing levels and end user license can be found in our Licensing article. Release Notes MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Home"},{"location":"#welcome","text":"Welcome to the documentation for MFractor, a powerful productivity tool for Visual Studio Windows and Mac to streamline the development of Xamarin applications.","title":"Welcome"},{"location":"#getting-started","text":"To get started using MFractor, please read our getting started guides: Quickstart - Visual Studio Windows Quickstart - Visual Studio Mac","title":"Getting Started"},{"location":"#help-and-support","text":"To get help using MFractor, please see our Support article.","title":"Help And Support"},{"location":"#licensing","text":"MFractor's licensing levels and end user license can be found in our Licensing article.","title":"Licensing"},{"location":"#release-notes","text":"MFractors release notes can be found at: Visual Studio Mac Visual Studio Windows","title":"Release Notes"},{"location":"faq/","text":"Answers to some commonly asked questions What is MFractor Professional? MFractor Professional is our paid version of MFractor. Our terms: A Professional license if valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. What is MFractor Lite? MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available for MFractor for Visual Studio Windows. Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. How do I get a refund? Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d Do you offer company licenses? Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing. I require an invoice or quote to purchase MFractor, can you provide one? Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order. How do I report a bug? To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug. I've got a great feature idea, how do I request it? Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality. I'd like to try MFractor Professional, how do I get a trial? To request an MFractor Professional trial, please email matthew@mfractor.com. How do I recover my MFractor Professional license? To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license. Where can I find MFracor's release notes? MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes Where do I find the latest version of MFractor? Visual Studio Macs The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300 Visual Studio Windows The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS What version of Visual Studio does MFractor support? Visual Studio Mac MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release. Visual Studio Window MFractor for Visual Studio Windows supports Visual Studio 2019 and higher. Does MFractor support the Preview versions of Visual Studio? No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk. Help! MFractor is not visible in Visual Studio Macs Extension Manager. MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ; I'd like to write a blog about MFractor. Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding. What is the .mfractor folder? The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it. Should I check .mfractor into source control? No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default. Can you help me make a Visual Studio extension? Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call. Are you available for hire to develop Xamarin applications? Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with. Are you available for hire to develop Visual Studio extension? Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor. What is the licensing agreement? Please see our End User License . What is your privacy policy? Please see our Privacy Policy .","title":"FAQ"},{"location":"faq/#what-is-mfractor-professional","text":"MFractor Professional is our paid version of MFractor. Our terms: A Professional license if valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"What is MFractor Professional?"},{"location":"faq/#what-is-mfractor-lite","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available for MFractor for Visual Studio Windows.","title":"What is MFractor Lite?"},{"location":"faq/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"faq/#how-do-i-get-a-refund","text":"Please email matthew@mfractor.com and request a refund within 30 days of purchase. But, boy oh boy, we are sad to see your go! \ud83d\ude2d","title":"How do I get a refund?"},{"location":"faq/#do-you-offer-company-licenses","text":"Yes! We can issue your company a license for any number of seats. To get a company license, please purchase your license at www.mfractor.com/buy . Alternatively, please email matthew@mfractor.com requesting an invoice for purchasing.","title":"Do you offer company licenses?"},{"location":"faq/#i-require-an-invoice-or-quote-to-purchase-mfractor-can-you-provide-one","text":"Yes, we offer payment and purchasing of MFractor licenses through invoice (fulfilled via Paypal payments). We can also provide quotes on the cost of an MFractor License purchase should you require one for your purchase order.","title":"I require an invoice or quote to purchase MFractor, can you provide one?"},{"location":"faq/#how-do-i-report-a-bug","text":"To report a bug, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues Please see our Support documentation for detailed information on reporting a bug.","title":"How do I report a bug?"},{"location":"faq/#ive-got-a-great-feature-idea-how-do-i-request-it","text":"Fantastic! We'd love to hear it and make it a reality. Firstly, please file an issue on our GitHub issues tracker at https://github.com/mfractor/mfractor-feedback/issues with a brief description of the feature and how it would work. Matthew or Rafael will then get in touch and request a feedback call so that we can flesh out the idea and make it a reality.","title":"I've got a great feature idea, how do I request it?"},{"location":"faq/#id-like-to-try-mfractor-professional-how-do-i-get-a-trial","text":"To request an MFractor Professional trial, please email matthew@mfractor.com.","title":"I'd like to try MFractor Professional, how do I get a trial?"},{"location":"faq/#how-do-i-recover-my-mfractor-professional-license","text":"To recover your MFractor Professional license, please email matthew@mfractor.com requesting your license.","title":"How do I recover my MFractor Professional license?"},{"location":"faq/#where-can-i-find-mfracors-release-notes","text":"MFractors release notes can be found here: MFractor for Visual Studio Mac Release Notes MFractor for Visual Studio Windows Release Notes","title":"Where can I find MFracor's release notes?"},{"location":"faq/#where-do-i-find-the-latest-version-of-mfractor","text":"","title":"Where do I find the latest version of MFractor?"},{"location":"faq/#visual-studio-macs","text":"The latest version of MFractor for Visual Studio Mac can be found at: http://addins.monodevelop.com/Project/Index/300","title":"Visual Studio Macs"},{"location":"faq/#visual-studio-windows","text":"The latest version of MFractor for Visual Studio Windows can be found in the Visual Studio Marketplace: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS","title":"Visual Studio Windows"},{"location":"faq/#what-version-of-visual-studio-does-mfractor-support","text":"","title":"What version of Visual Studio does MFractor support?"},{"location":"faq/#visual-studio-mac","text":"MFractor for Visual Studio Mac supports Visual Studio 2019 and higher. We always track the latest stable release.","title":"Visual Studio Mac"},{"location":"faq/#visual-studio-window","text":"MFractor for Visual Studio Windows supports Visual Studio 2019 and higher.","title":"Visual Studio Window"},{"location":"faq/#does-mfractor-support-the-preview-versions-of-visual-studio","text":"No, we do not officially support the preview versions of Visual Studio Mac or Windows. The extension may work if installed from file, however, we do not officially target or support any form of the Visual Studio previews. Install and use MFractor within the preview versions of Visual Studio at your own risk.","title":"Does MFractor support the Preview versions of Visual Studio?"},{"location":"faq/#help-mfractor-is-not-visible-in-visual-studio-macs-extension-manager","text":"MFractor is usually found in the Gallery tab of the Extension Manager under IDE Extensions ; you can use the top right search bar to locate If you are unable to see MFractor in the Extension Manager, firstly, please check that you are on the stable channel of Visual Studio Mac. If you are on the stable channel and are unable to locate MFractor, please download a suitable release from the Extensions Site and then install from file ;","title":"Help! MFractor is not visible in Visual Studio Macs Extension Manager."},{"location":"faq/#id-like-to-write-a-blog-about-mfractor","text":"Great! We love people blogging about our product and sharing the love. Please email matthew@mfractor.com and we will set you up with: A 30-day trial license to explore the software. A call to run you through the software. Logos and design assets for MFractor's branding.","title":"I'd like to write a blog about MFractor."},{"location":"faq/#what-is-the-mfractor-folder","text":"The .mfractor folder is MFractors working directory for your solution. This directory contains several SQLite database that are generated when MFractor indexes your projects. These databases are essential for many of MFractors features and are constantly regenerated. It is safe to delete whenever you want however some features won't work correctly without it.","title":"What is the .mfractor folder?"},{"location":"faq/#should-i-check-mfractor-into-source-control","text":"No, you should not check the .mfractor folder into source control. If you are using git, append the following text to the end of your .gitignore to exclude .mfractor : *.mfractor/ The VisualStudio .gitignore that is available on www.github.com ignores the .mfractor folder by default.","title":"Should I check .mfractor into source control?"},{"location":"faq/#can-you-help-me-make-a-visual-studio-extension","text":"Sure thing, we are happy to help the community get started creating Visual Studio extensions for both Mac and Windows. Please email matthew@mfractor.com requesting assistance and he'll get in touch to organise a call.","title":"Can you help me make a Visual Studio extension?"},{"location":"faq/#are-you-available-for-hire-to-develop-xamarin-applications","text":"Yes, we are. As tools developers, we are very skilled at building Xamarin applications. Please make a services enquiry to Matthew Robbins at matthew@mfractor. If we are unable to develop your app, we have a network trusted development partners in the United States, Europe, Australia and Singapore who can also develop your app that we will put you in touch with.","title":"Are you available for hire to develop Xamarin applications?"},{"location":"faq/#are-you-available-for-hire-to-develop-visual-studio-extension","text":"Yes, we are. Please make a services enquiry to Matthew Robbins at matthew@mfractor.","title":"Are you available for hire to develop Visual Studio extension?"},{"location":"faq/#what-is-the-licensing-agreement","text":"Please see our End User License .","title":"What is the licensing agreement?"},{"location":"faq/#what-is-your-privacy-policy","text":"Please see our Privacy Policy .","title":"What is your privacy policy?"},{"location":"installation-and-setup/","text":"Installing, activating and updating MFractor. Introduction This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows. Visual Studio Mac Installation (Marketplace) MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version. Uninstallation MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor. Release Note The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article. Visual Studio Windows Installation (Marketplace) MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation. Installation (File) Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows. Activation MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license. Importing Professional License To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features. Upgrades Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019 Uninstallation MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor. Release Notes The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Installation And Setup"},{"location":"installation-and-setup/#introduction","text":"This document outlines how to install, activate and upgrade MFractor for Visual Studio Mac and Windows.","title":"Introduction"},{"location":"installation-and-setup/#visual-studio-mac","text":"","title":"Visual Studio Mac"},{"location":"installation-and-setup/#installation-marketplace","text":"MFractor for Visual Studio Mac can be installed using Visual Studio Macs Extension Manager . This is the repository of extensions that are available for Visual Studio Mac. To install MFractor: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . Click on the Gallery tab and under IDE Extensions choose MFractor. In the right panel, select Install After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file","text":"Visual Studio Mac extensions are bundled and distributed as .mpack files. The latest version of MFractor for Visual Studio Mac can be found here: http://addins.monodevelop.com/Project/Index/300 To install MFractor from file: Start Visual Studio for Mac. Navigate to the top Visual Studio menu item and select Extensions . In the Extension Manager, click on the Install from file... . Browse to the location of the MFractor .mpack file and select it. After installation finishes, restart Visual Studio to complete installation.","title":"Installation (File)"},{"location":"installation-and-setup/#activation","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Mac and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose MFractor . Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades","text":"MFractor is distributed by Visual Studio Mac and, as such, you be automatically updated when an update is available. You can also check for updates at any time by opening the Visual Studio Mac main menu and selecting Check for Updates... Visual Studio Mac will check it's extension server for updates and prompt you to update if there is a new version.","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation","text":"MFractor for Visual Studio Mac can be uninstalled using the Extension Manager . To uninstall: Select the Visual Studio Mac main menu item and then click on Extensions... . Under the Gallery tab, locate the IDE extensions category and expand it. Select the MFractor item from the extensions list and then click Uninstall . You will be prompted to uninstall the extension, confirm uninstallation by clicking Uninstall . Restart Visual Studio Mac to complete the uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-note","text":"The release notes for MFractor for Visual Studio Mac can be found in our MFractor for Visual Studio Mac - Current Release article.","title":"Release Note"},{"location":"installation-and-setup/#visual-studio-windows","text":"","title":"Visual Studio Windows"},{"location":"installation-and-setup/#installation-marketplace_1","text":"MFractor for Visual Studio Windows can be installed using Visual Studios Manage Extensions dialog. To install MFractor: Start Visual Studio Windows. Navigate to the top Visual Studio menu item, select Extensions and then Manage Extensions . Select the Online tab in the left hand panel. In the top right panel, seach for MFractor . When MFractor appears in the list, click on it and then select Download After installation finishes, restart Visual Studio to complete installation.","title":"Installation (Marketplace)"},{"location":"installation-and-setup/#installation-file_1","text":"Visual Studio Windows extensions are bundled and distributed as .vsix files. The latest version of MFractor for Visual Studio Mac can be found here: https://marketplace.visualstudio.com/items?itemName=MFractorPtyLtd.MFRACTOR-VS-WINDOWS To install MFractor from file: Close all open instances of Visual Studio. Locate the MFractor .vsix and double click on it. This will launch the VSIX Installer and then install MFractor for Visual Studio Windows.","title":"Installation (File)"},{"location":"installation-and-setup/#activation_1","text":"MFractor requires you to activate the software in order to use the extension. After installing MFractor for Visual Studio Windows and then launching the IDE, MFractor will automatically open the activation window. To activate MFractor, enter your name and email address and then press Activate MFractor . If you have purchased an MFractor Professional license, you press the Import License button to locate your license.lic file and import it. See the following section for more information on importing a Professional license.","title":"Activation"},{"location":"installation-and-setup/#importing-professional-license_1","text":"To activate your MFractor Professional license, you will need to import the license file. To import your license file: In the top menu, choose Extensions and then MFractor Select License Information . Press the Import License button and locate your license.lic file. Confirm the location of your license. MFractor will import the license and activate all Professional features.","title":"Importing Professional License"},{"location":"installation-and-setup/#upgrades_1","text":"Visual Studio Windows will automatically check for updates for MFractor and will update it for you. For further instructions on updating Visual Studio extensions, please see the official documentation: https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2019","title":"Upgrades"},{"location":"installation-and-setup/#uninstallation_1","text":"MFractor for Visual Studio Windows can be uninstalled using the Manage Extensions dialog. To uninstall: In the top menu bar, select the Extension main menu item and then click on Manage Extensions . Under the Installed tab, select MFractor . To quickly locate the MFractor extension, type MFractor enter the search bar in the extension managers search bar. Selecting MFractor , click on Uninstall . This will schedule MFractor to be uninstalled. Close Visual Studio Windows and then confirm to complete uninstallation of MFractor.","title":"Uninstallation"},{"location":"installation-and-setup/#release-notes","text":"The release notes for MFractor for Visual Studio Windows can be found in our MFractor for Visual Studio Windows - Current Release article.","title":"Release Notes"},{"location":"licensing/","text":"Information about MFractor's licensing and terms of use Do I need to buy a separate license for Mac for Windows? An MFractor license works in both MFractor for Windows and Mac. MFractor Lite MFractor Professional MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine. MFractor Lite MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows. End User License Please find our End User License here. Privacy policy Please find our Private Policy here.","title":"Licensing"},{"location":"licensing/#do-i-need-to-buy-a-separate-license-for-mac-for-windows","text":"An MFractor license works in both MFractor for Windows and Mac.","title":"Do I need to buy a separate license for Mac for Windows?"},{"location":"licensing/#mfractor-lite","text":"","title":"MFractor Lite"},{"location":"licensing/#mfractor-professional","text":"MFractor Professional is our paid version of MFractor that can be purchased at www.mfractor.com/buy . Our terms: A Professional license is valid for one developer only. Please purchase a license for each developer in your team. Licenses valid for 366 days from the date of purchase. A single license can be used on up to 3 developer machines. As cross-platform developers it is very likely we have a Windows machine, a Mac and a personal machine.","title":"MFractor Professional"},{"location":"licensing/#mfractor-lite_1","text":"MFractor Lite is our free-for-use version of MFractor that includes our full XAML feature suite for 4 XAML files per day. MFractor Lite: Does not allow usage of our C# features. Does not allow usage of our asset management features. Does not allow usage of our code generation wizards. Is not available in MFractor for Visual Studio Windows.","title":"MFractor Lite"},{"location":"licensing/#end-user-license","text":"Please find our End User License here.","title":"End User License"},{"location":"licensing/#privacy-policy","text":"Please find our Private Policy here.","title":"Privacy policy"},{"location":"quickstart-mac/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Mac documentation. Main Menu Overview When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Mac"},{"location":"quickstart-mac/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Mac. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-mac/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Mac documentation.","title":"Setup And Maintenance"},{"location":"quickstart-mac/#main-menu-overview","text":"When installed, the MFractor top level menu item can be used to access MFractors features. This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-mac/#feature-overview","text":"MFractor for Visual Studio Mac contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. XAML IntelliSense. Image management tools: Image importer. Image manager. Image deletion tool. Image optimiser. Font Importer. Localisation tooling: Localisation wizard for XAML. Localisation wizard for C#. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Global search: Static resources. Dynamic resources. ResX values. Automation IDs. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-mac/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-mac/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-mac/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-mac/#formatting","text":"","title":"Formatting"},{"location":"quickstart-windows/","text":"Getting started with MFractor for Visual Studio Windows Introduction This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation. Setup And Maintenance Please see the Installation And Setup - Visual Studio Windows documentation. Main Menu Overview When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor. Feature Overview MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress. Preferences MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences . Settings The Settings section contains Code Analysis Formatting","title":"Quickstart - Windows"},{"location":"quickstart-windows/#introduction","text":"This guide is outlines how to install, activate, maintain and use MFractor for Visual Studio Windows. To learn more about installation, licensing or a particular feature, please refer to the relevant linked documentation.","title":"Introduction"},{"location":"quickstart-windows/#setup-and-maintenance","text":"Please see the Installation And Setup - Visual Studio Windows documentation.","title":"Setup And Maintenance"},{"location":"quickstart-windows/#main-menu-overview","text":"When installed, MFractor's main menu can be found under the top level Extensions menu: This menu contains the following items: License Kind/Duration : Displays the current license kind and how long it has remaining. License Information : Opens MFractor's license information dialog that allows you to activate a professional license and view licensee information. Buy MFractor : Opens https://www.mfractor.com/buy . Preferences : Opens MFractors preferences panel. Manage Image Assets : Launches the Image Manager . Coming soon in MFractor for Visual Studio Windows. Wizards : MFractors code generation wizards. Import : Contains the image asset and font importer tools. Actions : MFractor utilities like resyncing its solution resources database. About : Information about MFractor like version information, terms of user, privacy policies and third party software. Support : Methods to get help and support for MFractor.","title":"Main Menu Overview"},{"location":"quickstart-windows/#feature-overview","text":"MFractor for Visual Studio Windows contains the following features to assist Xamarin/.NET developers: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"Feature Overview"},{"location":"quickstart-windows/#preferences","text":"MFractor behaviour and functionality can be changed using it's preferences. To access MFractors prefrences: Go to the top Extensions menu. Select MFractor . Select Preferences .","title":"Preferences"},{"location":"quickstart-windows/#settings","text":"The Settings section contains","title":"Settings"},{"location":"quickstart-windows/#code-analysis","text":"","title":"Code Analysis"},{"location":"quickstart-windows/#formatting","text":"","title":"Formatting"},{"location":"support/","text":"How to get support or report issues for MFractor Reporting a Bug We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE. Visual Studio Mac To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log . Visual Studio Windows To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback . Support Channels In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support"},{"location":"support/#reporting-a-bug","text":"We use GitHub issues to track bug reports and also to track user-requested features. Our issue tracker can be found at: https://github.com/mfractor/mfractor-feedback/ When reporting an issue, please include the following information: To simplify gathering this information, you can use our Submit Feedback menu shortcut. This shortcut will open our issue tracker in your browser and populate the new issue with the version and environment information of your IDE.","title":"Reporting a Bug"},{"location":"support/#visual-studio-mac","text":"To report a bug in MFractor for Visual Studio Mac: Go to the top menu bar and click on the MFractor menu item. Under the Help menu, select Submit Feedback . Additionally, attaching the last 5 log files for Visual Studio Mac will help us diagnose the issue. To get the last 5 log files: Go to the top menu bar and click on the Help menu item. Next, select Open Log Directory . When the log directory opens, please select the 5 latest files named Ide.[Date].log .","title":"Visual Studio Mac"},{"location":"support/#visual-studio-windows","text":"To obtain the log files for Visual Studio Windows: Go to the top menu bar and click on the Extensions menu item. Under Extensions , select MFractor then Help and finally Submit Feedback .","title":"Visual Studio Windows"},{"location":"support/#support-channels","text":"In addition to our issue tracker, you can also get support through the following channels: Twitter: @matthewrdev or @mfractor . Slack: MFractor Slack Channel . Gitter: MFractor Gitter Channel . Email: Please email matthew@mfractor.com or rafael@mfractor.com . OfficeHours: Please book Matthew Robbins (Founder) at https://officehours.io/people/matthewrdev","title":"Support Channels"},{"location":"_drafts/image-management/deleting-image-assets/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28 Introduction The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Android When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap files. For example, let's consider an image asset named logo with the following project structure: MyApp.Android drawable/ logo.xml drawable-ldpi/ logo.png drawable-mdpi/ logo.png drawable-hdpi/ logo.png mipmap-ldpi/ logo.png mipmap-mdpi/ logo.png mipmap-hdpi/ logo1.png MFractor would delete the following assets: drawable-ldpi/ logo.png drawable-night-mdpi/ logo.png drawable-landscape-hdpi/ logo.png mipmap-de-ldpi/ logo.png mipmap/ logo.png MFractor would ignore the following assets: drawable/ logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/ logo1.png (Excluded as logo1 is not a match with logo). iOS Launching The Deletion Tool Solution Explorer The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image asset. Choosing the Delete Image Asset menu option. Image Manager The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete Image Asset . Using The Deletion Tool After launching the image deletion tool, you will be presented","title":"Deleting image assets"},{"location":"_drafts/image-management/deleting-image-assets/#introduction","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently.","title":"Introduction"},{"location":"_drafts/image-management/deleting-image-assets/#android","text":"When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap files. For example, let's consider an image asset named logo with the following project structure: MyApp.Android drawable/ logo.xml drawable-ldpi/ logo.png drawable-mdpi/ logo.png drawable-hdpi/ logo.png mipmap-ldpi/ logo.png mipmap-mdpi/ logo.png mipmap-hdpi/ logo1.png MFractor would delete the following assets: drawable-ldpi/ logo.png drawable-night-mdpi/ logo.png drawable-landscape-hdpi/ logo.png mipmap-de-ldpi/ logo.png mipmap/ logo.png MFractor would ignore the following assets: drawable/ logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/ logo1.png (Excluded as logo1 is not a match with logo).","title":"Android"},{"location":"_drafts/image-management/deleting-image-assets/#ios","text":"","title":"iOS"},{"location":"_drafts/image-management/deleting-image-assets/#launching-the-deletion-tool","text":"","title":"Launching The Deletion Tool"},{"location":"_drafts/image-management/deleting-image-assets/#solution-explorer","text":"The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image asset. Choosing the Delete Image Asset menu option.","title":"Solution Explorer"},{"location":"_drafts/image-management/deleting-image-assets/#image-manager","text":"The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete Image Asset .","title":"Image Manager"},{"location":"_drafts/image-management/deleting-image-assets/#using-the-deletion-tool","text":"After launching the image deletion tool, you will be presented","title":"Using The Deletion Tool"},{"location":"_drafts/image-management/importing-image-assets/","text":"Generate all image densities for iOS and Android from a single source image. Introduction Xamarin applications The image importer generates Launching The Image Importer The image importer can be accessed in the following ways: Add Files Menu The image importer can be found under the Add solution pad menu in both Visual Studio Windows and Mac. To access it, right click on a solution or project in the solution explorer, choose Add and then Image Asset : The Image Asset option will only appear in iOS or Android projects, or solutions that contain an iOS or Android project Import Menu The image importer can be accessed by selecting the top MFractor menu, then choosing Import and then Image Asset . Image Manager When XAML IntelliSense When completing Add Missing Image Fix If MFractor detects that an image asset reference in XAML is missing in one or more projects in the solution, you can l Understanding Image Densities The image importer creates new lower density image assets using the Image Resource Types Asset Catalogs To better understand Bundle Resources Android When importing new image assets into Drawables Mipmap Import Dark Mode Assets Coming soon Preferences The image importer's can be configured under the **MF","title":"Importing image assets"},{"location":"_drafts/image-management/importing-image-assets/#introduction","text":"Xamarin applications The image importer generates","title":"Introduction"},{"location":"_drafts/image-management/importing-image-assets/#launching-the-image-importer","text":"The image importer can be accessed in the following ways:","title":"Launching The Image Importer"},{"location":"_drafts/image-management/importing-image-assets/#add-files-menu","text":"The image importer can be found under the Add solution pad menu in both Visual Studio Windows and Mac. To access it, right click on a solution or project in the solution explorer, choose Add and then Image Asset : The Image Asset option will only appear in iOS or Android projects, or solutions that contain an iOS or Android project","title":"Add Files Menu"},{"location":"_drafts/image-management/importing-image-assets/#import-menu","text":"The image importer can be accessed by selecting the top MFractor menu, then choosing Import and then Image Asset .","title":"Import Menu"},{"location":"_drafts/image-management/importing-image-assets/#image-manager","text":"When","title":"Image Manager"},{"location":"_drafts/image-management/importing-image-assets/#xaml-intellisense","text":"When completing","title":"XAML IntelliSense"},{"location":"_drafts/image-management/importing-image-assets/#add-missing-image-fix","text":"If MFractor detects that an image asset reference in XAML is missing in one or more projects in the solution, you can l","title":"Add Missing Image Fix"},{"location":"_drafts/image-management/importing-image-assets/#understanding-image-densities","text":"The image importer creates new lower density image assets using the","title":"Understanding Image Densities"},{"location":"_drafts/image-management/importing-image-assets/#image-resource-types","text":"","title":"Image Resource Types"},{"location":"_drafts/image-management/importing-image-assets/#asset-catalogs","text":"To better understand","title":"Asset Catalogs"},{"location":"_drafts/image-management/importing-image-assets/#bundle-resources","text":"","title":"Bundle Resources"},{"location":"_drafts/image-management/importing-image-assets/#android","text":"When importing new image assets into","title":"Android"},{"location":"_drafts/image-management/importing-image-assets/#drawables","text":"","title":"Drawables"},{"location":"_drafts/image-management/importing-image-assets/#mipmap","text":"","title":"Mipmap"},{"location":"_drafts/image-management/importing-image-assets/#import-dark-mode-assets","text":"Coming soon","title":"Import Dark Mode Assets"},{"location":"_drafts/image-management/importing-image-assets/#preferences","text":"The image importer's can be configured under the **MF","title":"Preferences"},{"location":"_drafts/image-management/optimising-image-assets/","text":"Reducing the size your image assets using the image optimiser Introduction Configuring TinyPNG API Key Launching The Optimiser","title":"Optimising image assets"},{"location":"_drafts/image-management/optimising-image-assets/#introduction","text":"","title":"Introduction"},{"location":"_drafts/image-management/optimising-image-assets/#configuring-tinypng-api-key","text":"","title":"Configuring TinyPNG API Key"},{"location":"_drafts/image-management/optimising-image-assets/#launching-the-optimiser","text":"","title":"Launching The Optimiser"},{"location":"_drafts/image-management/overview/","text":"Use MFractors image management suite to import, delete, optimise and manage the image assets in your iOS and Android apps Image Management Tool Suite Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features: Image Asset Manager Visual Studio Mac Only The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets . Image Importer The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets . Image Deletion Tool Visual Studio Mac Only The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets . Image Optimiser Visual Studio Mac Only The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Overview"},{"location":"_drafts/image-management/overview/#image-management-tool-suite","text":"Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features:","title":"Image Management Tool Suite"},{"location":"_drafts/image-management/overview/#image-asset-manager","text":"Visual Studio Mac Only The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets .","title":"Image Asset Manager"},{"location":"_drafts/image-management/overview/#image-importer","text":"The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets .","title":"Image Importer"},{"location":"_drafts/image-management/overview/#image-deletion-tool","text":"Visual Studio Mac Only The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets .","title":"Image Deletion Tool"},{"location":"_drafts/image-management/overview/#image-optimiser","text":"Visual Studio Mac Only The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Image Optimiser"},{"location":"analysis/disabling-analysers/","text":"How to disable unwanted code analysers Introduction Disabling A Code Analyser","title":"Disabling analysers"},{"location":"analysis/disabling-analysers/#introduction","text":"","title":"Introduction"},{"location":"analysis/disabling-analysers/#disabling-a-code-analyser","text":"","title":"Disabling A Code Analyser"},{"location":"analysis/overview/","text":"Detect errors, improvements and maintainability suggestions with Introduction","title":"Overview"},{"location":"analysis/overview/#introduction","text":"","title":"Introduction"},{"location":"analysis/solution-analysis/","text":"Scan your mobile solution for a wide range of errors, improvements and maintainability suggestions","title":"Solution analysis"},{"location":"configuration/overview/","text":"**","title":"Overview"},{"location":"csharp/localisation/","text":"","title":"Localisation"},{"location":"csharp/refactorings/convert-to-interpolated-string/","text":"","title":"Convert to interpolated string"},{"location":"csharp/refactorings/create-lazy-field-property/","text":"","title":"Create lazy field property"},{"location":"csharp/refactorings/generate-constructor/","text":"","title":"Generate constructor"},{"location":"csharp/refactorings/generate-interface/","text":"","title":"Generate interface"},{"location":"csharp/refactorings/locate-class-in-solution-pad/","text":"","title":"Locate class in solution pad"},{"location":"csharp/refactorings/simplified-qualified-types/","text":"","title":"Simplified qualified types"},{"location":"fonts/add-uiappfonts-plist-entry/","text":"Inject the UIAppFonts entry for a font asset into the info.plist Introduction Adding UIAppFontEntry","title":"Add UIAppFonts Entry"},{"location":"fonts/add-uiappfonts-plist-entry/#introduction","text":"","title":"Introduction"},{"location":"fonts/add-uiappfonts-plist-entry/#adding-uiappfontentry","text":"","title":"Adding UIAppFontEntry"},{"location":"fonts/generate-fontfamily-xaml/","text":"Create the FontFamily XAML for a font asset Introduction Generating FontFamily XAML","title":"Creating Font Xaml Code"},{"location":"fonts/generate-fontfamily-xaml/#introduction","text":"","title":"Introduction"},{"location":"fonts/generate-fontfamily-xaml/#generating-fontfamily-xaml","text":"","title":"Generating FontFamily XAML"},{"location":"fonts/importing-fonts/","text":"Add new assets into your Android and iOS applications Introduction Accessing The Font Importer Solution Explorer To launch the font importer through the solution explorer: In the solution explorer, right click on an Android or iOS project OR a solution containing an Android or iOS project. Navigate to the Add Files... menu. Select Font . Main Menu To launch the font importer through the main menu=: In the top menu, Navigate to the Add Files... menu. Select Font . Using The Font Importer When the FontFamily XAML UIAppFonts Entry","title":"Importing Fonts"},{"location":"fonts/importing-fonts/#introduction","text":"","title":"Introduction"},{"location":"fonts/importing-fonts/#accessing-the-font-importer","text":"","title":"Accessing The Font Importer"},{"location":"fonts/importing-fonts/#solution-explorer","text":"To launch the font importer through the solution explorer: In the solution explorer, right click on an Android or iOS project OR a solution containing an Android or iOS project. Navigate to the Add Files... menu. Select Font .","title":"Solution Explorer"},{"location":"fonts/importing-fonts/#main-menu","text":"To launch the font importer through the main menu=: In the top menu, Navigate to the Add Files... menu. Select Font .","title":"Main Menu"},{"location":"fonts/importing-fonts/#using-the-font-importer","text":"When the","title":"Using The Font Importer"},{"location":"fonts/importing-fonts/#fontfamily-xaml","text":"","title":"FontFamily XAML"},{"location":"fonts/importing-fonts/#uiappfonts-entry","text":"","title":"UIAppFonts Entry"},{"location":"image-management/deleting-image-assets/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28 Introduction The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently. Android When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap files. For example, let's consider an image asset named logo with the following project structure: MyApp.Android drawable/ logo.xml drawable-ldpi/ logo.png drawable-mdpi/ logo.png drawable-hdpi/ logo.png mipmap-ldpi/ logo.png mipmap-mdpi/ logo.png mipmap-hdpi/ logo1.png MFractor would delete the following assets: drawable-ldpi/ logo.png drawable-night-mdpi/ logo.png drawable-landscape-hdpi/ logo.png mipmap-de-ldpi/ logo.png mipmap/ logo.png MFractor would ignore the following assets: drawable/ logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/ logo1.png (Excluded as logo1 is not a match with logo). iOS Launching The Deletion Tool Solution Explorer The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image asset. Choosing the Delete Image Asset menu option. Image Manager The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete Image Asset . Using The Deletion Tool After launching the image deletion tool, you will be presented","title":"Deleting Image Assets"},{"location":"image-management/deleting-image-assets/#introduction","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurrences of an asset in one action instead of needing to track down and delete each density independently.","title":"Introduction"},{"location":"image-management/deleting-image-assets/#android","text":"When the image manager deletes an image asset in an Android project, it will remove all matching files in the drawable and mipmap files. For example, let's consider an image asset named logo with the following project structure: MyApp.Android drawable/ logo.xml drawable-ldpi/ logo.png drawable-mdpi/ logo.png drawable-hdpi/ logo.png mipmap-ldpi/ logo.png mipmap-mdpi/ logo.png mipmap-hdpi/ logo1.png MFractor would delete the following assets: drawable-ldpi/ logo.png drawable-night-mdpi/ logo.png drawable-landscape-hdpi/ logo.png mipmap-de-ldpi/ logo.png mipmap/ logo.png MFractor would ignore the following assets: drawable/ logo.xml (Excluded as it's an xml drawable) mipmap-hdpi/ logo1.png (Excluded as logo1 is not a match with logo).","title":"Android"},{"location":"image-management/deleting-image-assets/#ios","text":"","title":"iOS"},{"location":"image-management/deleting-image-assets/#launching-the-deletion-tool","text":"","title":"Launching The Deletion Tool"},{"location":"image-management/deleting-image-assets/#solution-explorer","text":"The image deletion can be launched from the solution explorer by: Right click on an Android or iOS image asset. Choosing the Delete Image Asset menu option.","title":"Solution Explorer"},{"location":"image-management/deleting-image-assets/#image-manager","text":"The image deletion tool can be launched from the image manager by: Right click on an image asset in the left hand summary list. Select the Delete Image Asset .","title":"Image Manager"},{"location":"image-management/deleting-image-assets/#using-the-deletion-tool","text":"After launching the image deletion tool, you will be presented","title":"Using The Deletion Tool"},{"location":"image-management/image-importer/","text":"Add new image assets into your Android and iOS applications Introduction The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets. Using the Image Importer The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be imported from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next. Target Projects MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images. Setting the Image Size The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image. Import Image When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Importing Images"},{"location":"image-management/image-importer/#introduction","text":"The Image Importer utilities allows you to import image assets into the Android and iOS projects of your solution from a single image file, that is then imported with the correct size and aspect ratios for the given density buckets.","title":"Introduction"},{"location":"image-management/image-importer/#using-the-image-importer","text":"The image importer tool is presented as a dialog that can be invoked from several places in Visual Studio IDE. The more straightforward is from the MFractor main menu: The MFractor Image Importer tool menu option will only be available if the solution has at least one Xamarin.Android or Xamarin.iOS project. The tool can also be imported from the context menu of an Android or iOS project, in the Add submenu you should find the option for Image Asset : The Image Importer Tool dialog Window allows you to load a single image that you want to import to the project and then you can set the parameters for your import operation. First select the file you want to import, this will load it in the Preview panes: Now you can customize how the import operation will execute. We will inspect the available options up next.","title":"Using the Image Importer"},{"location":"image-management/image-importer/#target-projects","text":"MFractor identifies the projects of type Xamarin.Android and Xamarin.iOS that can be import targets. By checking the Include box the image assets will be copied to the selected projects. There are several options that can be set for each of these targets: Image Type : depending on the Target Project you can select how the image will be imported: Android Projects can choose from Drawable or MipMap . Drawables are the default option and MipMaps are commonly used for application icons. In both cases the tool will import images to the corresponding density bucket folder. iOS projects can choose from Asset Catalogs or Bundle Resources . Images imported to Asset Catalogs will be added to Assets.xcassets catalog that is created by the default Xamarin.iOS project template. Bundle Resources images are copied to the Resources folder of the project. In both cases the entries are automatically added to the .csproj with the corresponding Bundle Action to ensure they'll be correctly compiled to the application package. Image Density : also dependant on the Target Project, you can select the maximum image density for the target platform. The tool will automatically add all the images from down to the lowest density on that platform. Options are: Android: xxxhdpi , xxhdpi , xhdpi , hdpi , mdpi and ldpi . iOS: @3x , @2x and @1x . MFractor provides a system-wide configuration to set the minimum image density to which you want Android image assets to be imported. This option is presented in the Settings pane in the MFractor section of Visual Studio Preferences: This pane also allows setting the Default Image Asset Type for import iOS images.","title":"Target Projects"},{"location":"image-management/image-importer/#setting-the-image-size","text":"The image importer tool will detect the image dimensions and automatically suggest it as the image size for the import operation. This size determines how big will be the image on the maximum selected bucket for any of the target projects. MFractor then scale down the images to the correct sizes of each bucket on each target project/platform. It's important to understand how densities sizes are calculated in order to correctly apply the size options for your needs. Currently, the platforms work with densities as of the following table: 0.75x 1.0x 1.5x 2.0x 3.0x 4.0x Android ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi iOS N/A @1x N/A @2x @3x N/A There you can see a correlation between density multipliers and the density bucket on each platform. We can see that Android provide several more densities than iOS although most of them are equivalent between platforms. Also Android provides an maximum higher multiplier of 4.0x that iOS doesn't implement. This is important to understand how image sizes are calculated on the image importer tool. On the bottom pane of the importer dialog window you can preview how the images are going to be imported on the selected target project. The sample image from the following screenshot is a 1600x463 banner. If you check the preview pane of the Android target you will notice that its going to generate a image for each of the densities listed above, applying its multiplier to determine the correct image size: When you select the iOS project, you will notice that there's way less densities to manage, and also that the bigger density is smaller than the image size: This happens because the selected maximum density of the Android target project is greater than the maximum density of the iOS project, so the tool automatically downsizes it to keep the image sizes consistent between platforms. If you set the Image Density of the Android target to xxhdpi and check back the preview pane of the iOS target, you will notice that the maximum density will preserve the maximum size of the image.","title":"Setting the Image Size"},{"location":"image-management/image-importer/#import-image","text":"When you're satisfied with the settings you can import the image by clicking on the Import Image button. MFractor will generate and add the images to the projects you've set as target. Check the projects to verify the results:","title":"Import Image"},{"location":"image-management/managing-image-assets/","text":"A centralised location to easily manage the image assets in your mobile solution Introduction The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Opening The Image Manager The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden: Top Menu By acessing the top menu selecting the Manage Image Assets options. Solution Pad You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list. Overview Filtering Image assets Importing Image Assets Deleting Image Assets Optimising Image Assets Searching For Image Usages Visual Studio Mac Only Drag And Drop The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ; Context Actions In both the image asset list and the image density list, you may right click on any item to launch a context Delete Please see Deleting Image Assets Reveal In Finder/Explorer The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image. Reveal In Project Pad The Reveal Project Pad action will locate the image file in the solution pad. Copy Name To Clipboard The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard. Copy File Path To Clipboard The Copy File Path To Clipboard action copies the file path of that image file to the clipboard. Optimise Please see Optimising Image Assets Open Image The Open action opens the selected image file in the operating systems default image viewer. Search For Usages Please see Searching For Image Usages","title":"Managing Images Assets"},{"location":"image-management/managing-image-assets/#introduction","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location.","title":"Introduction"},{"location":"image-management/managing-image-assets/#opening-the-image-manager","text":"The image manager is presented as a pad on the IDE by default on the right side of the Window, below the Toolbox , Properties and Document Outline pads. You can access it from several places if hidden:","title":"Opening The Image Manager"},{"location":"image-management/managing-image-assets/#top-menu","text":"By acessing the top menu selecting the Manage Image Assets options.","title":"Top Menu"},{"location":"image-management/managing-image-assets/#solution-pad","text":"You can right click on a Xamarin.Android and Xamarin.iOS project file and you'll find Manage Image Assets under the Tools menu. Alternatively, double click on and Android or iOS image asset. This will open the image manager, selecting that image in the list.","title":"Solution Pad"},{"location":"image-management/managing-image-assets/#overview","text":"","title":"Overview"},{"location":"image-management/managing-image-assets/#filtering-image-assets","text":"","title":"Filtering Image assets"},{"location":"image-management/managing-image-assets/#importing-image-assets","text":"","title":"Importing Image Assets"},{"location":"image-management/managing-image-assets/#deleting-image-assets","text":"","title":"Deleting Image Assets"},{"location":"image-management/managing-image-assets/#optimising-image-assets","text":"","title":"Optimising Image Assets"},{"location":"image-management/managing-image-assets/#searching-for-image-usages","text":"Visual Studio Mac Only","title":"Searching For Image Usages"},{"location":"image-management/managing-image-assets/#drag-and-drop","text":"The image manager supports drag and drop from the image asset list onto a code file. When you drag and drop an image onto a code file, the image manager will generate code to access that image. For example, given the image logo.png , MFractor will insert the following code: Android AXML : @drawable/logo . Android C# : Resource.Drawable.logo . XAML : logo . C# (Xamarin.Forms) : \"logo.png\" ;","title":"Drag And Drop"},{"location":"image-management/managing-image-assets/#context-actions","text":"In both the image asset list and the image density list, you may right click on any item to launch a context","title":"Context Actions"},{"location":"image-management/managing-image-assets/#delete","text":"Please see Deleting Image Assets","title":"Delete"},{"location":"image-management/managing-image-assets/#reveal-in-finderexplorer","text":"The Reveal In Finder action will open Finder (Mac) or Explorer (Windows) and select that image.","title":"Reveal In Finder/Explorer"},{"location":"image-management/managing-image-assets/#reveal-in-project-pad","text":"The Reveal Project Pad action will locate the image file in the solution pad.","title":"Reveal In Project Pad"},{"location":"image-management/managing-image-assets/#copy-name-to-clipboard","text":"The Copy NameTo Clipboard action copies the full file path of that image file to the clipboard.","title":"Copy Name To Clipboard"},{"location":"image-management/managing-image-assets/#copy-file-path-to-clipboard","text":"The Copy File Path To Clipboard action copies the file path of that image file to the clipboard.","title":"Copy File Path To Clipboard"},{"location":"image-management/managing-image-assets/#optimise","text":"Please see Optimising Image Assets","title":"Optimise"},{"location":"image-management/managing-image-assets/#open-image","text":"The Open action opens the selected image file in the operating systems default image viewer.","title":"Open Image"},{"location":"image-management/managing-image-assets/#search-for-usages","text":"Please see Searching For Image Usages","title":"Search For Usages"},{"location":"image-management/optimising-image-assets/","text":"Reducing the size your image assets using the image optimiser Introduction Configuring TinyPNG API Key Launching The Optimiser","title":"Optimising Image Assets"},{"location":"image-management/optimising-image-assets/#introduction","text":"","title":"Introduction"},{"location":"image-management/optimising-image-assets/#configuring-tinypng-api-key","text":"","title":"Configuring TinyPNG API Key"},{"location":"image-management/optimising-image-assets/#launching-the-optimiser","text":"","title":"Launching The Optimiser"},{"location":"image-management/overview/","text":"Use MFractors image management suite to import, delete, optimise and manage the image assets in your iOS and Android apps Image Management Tool Suite Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features: Image Asset Manager The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets . Image Importer The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets . Image Deletion Tool The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets . Image Optimiser The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Overview"},{"location":"image-management/overview/#image-management-tool-suite","text":"Working with image assets is one of the most time-consuming parts of Xamarin development and improving all image related workflows is one of MFractor's core focuses. At a glance, MFractor's image management tool suite is composed of the following features:","title":"Image Management Tool Suite"},{"location":"image-management/overview/#image-asset-manager","text":"The image asset manager summarises all image assets across your solution from your iOS and Android projects. As a developer, you gain a birds-eye view of all image assets in your solution and that then allows you to delete, import, search and optimise all images from a centralised location. Read more about the image asset manager at Managing Image Assets .","title":"Image Asset Manager"},{"location":"image-management/overview/#image-importer","text":"The image importer takes a source image and generates all densities for iOS and Android apps. Read more about the image importer at Importing Image Assets .","title":"Image Importer"},{"location":"image-management/overview/#image-deletion-tool","text":"The image deletion tool removes all densities of an image asset in all mobile projects. As a developer, you can delete all occurances of an asset in one action instead of needing to track down and delete each density independently. Read more about the image deletion tool at Deleting Image Assets .","title":"Image Deletion Tool"},{"location":"image-management/overview/#image-optimiser","text":"The image optimiser squashes the size of all image assets in your application, reducing the size of those assets by a factor of up to 75% with no visual loss. To do this, it uses TinyPNG to perform intelligent image compression. Read more about the image optimiser at Optimising Image Assets .","title":"Image Optimiser"},{"location":"linker/excluding-symbols-from-linker/","text":"Exclude assemblies, classes or members from the Xamarin linker","title":"Excluding symbols from linker"},{"location":"linker/linker-intellisense/","text":"Use linker.xml IntelliSense to exclude assemblies, classes or members from the Xamarin linker Introduction Linker IntelliSense","title":"Linker intellisense"},{"location":"linker/linker-intellisense/#introduction","text":"","title":"Introduction"},{"location":"linker/linker-intellisense/#linker-intellisense","text":"","title":"Linker IntelliSense"},{"location":"release-notes/known-issues/","text":"A list of currently known issues in our Visual Studio Windows and Mac products Known Issues Please see our issue tracker for a list of active issues . To submit a new issue, please see our Support documentation.","title":"Known Issues"},{"location":"release-notes/known-issues/#known-issues","text":"Please see our issue tracker for a list of active issues . To submit a new issue, please see our Support documentation.","title":"Known Issues"},{"location":"release-notes/mac/current/","text":"Current Release The current version of MFractor for Visual Studio Mac is v3.9.2. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9 Releases (v3.9) v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bug. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance.","title":"Current Release"},{"location":"release-notes/mac/current/#current-release","text":"The current version of MFractor for Visual Studio Mac is v3.9.2. Please note that no release notes for MFractor for Visual Studio Mac are available before v3.9","title":"Current Release"},{"location":"release-notes/mac/current/#releases-v39","text":"v3.9.2 - Released on December 7th 2019 - Critical hotfix to remove incorrectly bundled assemblies, grid IntelliSense improvements and fixes for several customer reported bug. v3.9.1 - Released on December 6th 2019 - Contains various fixes for the value converter generation workflows. v3.9.0 - Released on December 3rd 2019 - Major release improving overall stability and performance.","title":"Releases (v3.9)"},{"location":"release-notes/mac/v3/v3.9/","text":"v3.9.2 Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac. Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153 v3.9.0 Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9"},{"location":"release-notes/mac/v3/v3.9/#v392","text":"Released on December 7th 2019 The 3.9.2 release contains a critical hotfix to remove the Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from MFractor. This fixes instability in the IDE caused by MFractor in Visual Studio Mac 8.3 and above. Features: Star and Auto short hand completions for Grids. Customer Requested : Grid (Boilerplate) short hand completion to create common boilerplate code (row and column definitions) for new grid declarations. Issues Fixed: Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Fixed: Localisation wizard freezes Visual Studio Mac. Released on December 5th 2019 Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v3.9.2"},{"location":"release-notes/mac/v3/v3.9/#v390","text":"Released on December 3rd 2019 Features: When a shared project is select in the solution pad, use the Edit Shared Project Items to open the .projitems file for the shared project. When a font in an iOS project is selected in the solution pad, use the Add UIAppFont Entry to add an info.plist entry for that font, When a font in an iOS project is selected in the solution pad, use the Copy FontFamily XAML To Clipboard to generate the OnPlatform code needed to use that font in XAML. The Delete Output Folders feature is now configurable. The first time you use this feature for a solution or project, it will ask which folders you'd like to delete. #146 Enhancements: We are no longer bundling the Microsoft.CodeAnalysis assemblies (aka Roslyln). This improves Visual Studio Mac performance and stability, as well as reducing the size of MFractor's package. Significant performance and memory improvement for MFractors IntelliSense. We've re-engineered how we discover XAML symbols to reduce memory usage and cut-down the time it takes to resolve a symbol. This work was imperative for our IntelliSense support in Visual Studio Windows. Significant performance and memory improvements for MFractors resource indexer. The following features now have integrated documentation: Extract control. Generate bindable property. Generate attached property. Issues Fixed: Fixed: Importing iOS Image Assets with the Image Importer do not appear. #147 Fixed: When editing inside a Setter, MFractor would try suggestion setter shorthands alongside attributes. Fixed: When editing a XAML document, sometimes MFractor would incorrectly report missing or misnamed static resources.","title":"v3.9.0"},{"location":"release-notes/windows/current/","text":"The current version of MFractor for Visual Studio Windows is v0.2.0 Releases (v0.2) v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows.","title":"Current Release"},{"location":"release-notes/windows/current/#releases-v02","text":"v0.2.0 - Released on December 10th 2019 : Preview 2 release of MFractor for Visual Studio Windows.","title":"Releases (v0.2)"},{"location":"release-notes/windows/v0/v0.1/","text":"v0.1.1 Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1"},{"location":"release-notes/windows/v0/v0.1/#v011","text":"Released on November 25th 2019 MFractor for Visual Studio Windows v0.1.1 is the initial release of the Windows version of MFractor. Officially, this product release is known as MFractor for Visual Studio Windows (Preview 1) . Features: 80+ XAML Analysers. 90+ C# and XAML code actions. Font Importer. Image Importer. MVVM Wizard. Value Converter Wizard. MVVM Navigation. Delete Output Folders. Clean And Compress.","title":"v0.1.1"},{"location":"release-notes/windows/v0/v0.2/","text":"v0.2.0 Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accesibile through Extensions - MFractor - Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2"},{"location":"release-notes/windows/v0/v0.2/#v020","text":"Released on December 10th 2019 MFractor for Visual Studio Windows v0.2.0 is a major upgrade from v0.1, adding our image management tooling and preferences integration. Officially, this product release is known as MFractor for Visual Studio Windows - Preview 2 . Preview 2 adds: Our image asset management tools. Image manager (accesibile through Extensions - MFractor - Manage Image Assets ). Image optimiser. Image deletion tool (Preview) Configurable delete output folders. Full preferences integration. Enhancements: When generating a new value converter, MFractor can automatically add it to the app xaml or current xaml file. #154 Fixed: Remove Newtonsoft.Json and Microsoft.VisualStudio.Composition assemblies from final package. Fixed: Delete output folders fails in v3.9.1. #166 Issues Fixed: Fixed: Generated Converter Type Inference issues. #156 Fixed: Generating a Converter from the Generate actions in Xaml, sets the Converter on the binding twice. #155 Fixed: Value Converter Wizard Parameter Type is ignored. #153","title":"v0.2.0"},{"location":"utilities/clean-and-compress/","text":"Quickly create a zip archive for solution or projects Introduction The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac. Archiving Solutions To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop. Archiving Projects To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop. Example","title":"Clean And Compress"},{"location":"utilities/clean-and-compress/#introduction","text":"The clean and compress tool creates a zip archive of a solution or project. When it generates the zip archive, the tool excludes all build artifacts (such as the bin or obj folder), the nuget packages folder and the .vs folder. As such, the final archive it create contains only the source code and assets necessary to build and run the solution or project. This tool is useful for sharing source code or creating a local backup. The clean and compress tool is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/clean-and-compress/#archiving-solutions","text":"To archive a solution, right click on the solution entry in the solution explorer pad and select Clean and compress MFractor will then archive your solution, including all projects and source code assets, and create a new zip archive named SolutionName.zip on your desktop.","title":"Archiving Solutions"},{"location":"utilities/clean-and-compress/#archiving-projects","text":"To archive a project, right click on the project entry in the solution explorer pad and select Clean and compress MFractor will then archive your project, including all source code and assets for that project, and create a new zip archive named ProjectName.zip on your desktop.","title":"Archiving Projects"},{"location":"utilities/clean-and-compress/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/","text":"Remove the working and output folders for a solution or project Introduction The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac. Using Delete Output Folders To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system. Example Configuring Delete Output Folders The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Delete Output Folders"},{"location":"utilities/delete-output-folders/#introduction","text":"The Delete Output Folders utility deletes the intermediate folders for a solution or project. When developing software, a common troubleshooting strategy for build issues is removing all build artefacts and then rebuilding the solution. while Visual Studios offers a Clean Solution utility, this tool often does not effectively remove the build artefacts. MFractors Delete Output Folders shortcut deletes the bin and obj folders and is easily accessible via the right click menu in the solution explorer. The delete output folders utility is available in both Visual Studio Windows and Mac.","title":"Introduction"},{"location":"utilities/delete-output-folders/#using-delete-output-folders","text":"To delete the output folders to for a solution or project, right click on the solution or project in the solution explorer and then choose Delete Output Folders . MFractor will find the bin and obj folders that are alongside the solutions projects and perform a physical delete on them, removing them from the file system.","title":"Using Delete Output Folders"},{"location":"utilities/delete-output-folders/#example","text":"","title":"Example"},{"location":"utilities/delete-output-folders/#configuring-delete-output-folders","text":"The first that you use the Delete Output Folders feature for a solution or project, you will be prompted to choose which folders to delete: These options are: bin : Delete the bin folder that contains the output binaries. obj : Delete the intermediate files contained in the obj folder. If packages is uncheck, the obj folder will be preserved to keep the nuget package configuration, however, the inner build configuration folders will be deleted. packages : Delete the NuGet packages cache that is within the obj folder. .vs : Delete the .vs working folder. Only applicable to solutions. After you choosing your defaults, these settings are remembered and will used by default next time you use Delete Output Folders . At any time you can change the preferences for a project or solution through the preferences panel. To do so: Go to the top MFractor menu. Select Preferences . Select Delete Output Folders . In the preferences panel, you can enable or disable each of the individual settings in the list view. You can also clear all settings by pressing the Clear button.","title":"Configuring Delete Output Folders"},{"location":"utilities/edit-shared-project-items/","text":"Edit the msbuild for a shared project Introduction One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to. Editing Shared Project Items Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Edit Shared Project Items"},{"location":"utilities/edit-shared-project-items/#introduction","text":"One of the common project types when building Xamarin applications is the Shared Assets Project . These projects are a collection of source code files and assets that are bundled into standalone projects. However, when you reference one of these projects and compile, the compiler treats these files like they are part of the project referencing them. For a full breakdown on shared projects, please see Microsofts Shared Projects Documentation . On disk, a shared project is structured as two distinct projects: The .shproj file is the project that is reference by other compilable projects. The .projitems file defines what the .shproj file will add to the compilation. When we work with shared projects in our Visual Studio, the .projitems is not surfaced by default in the solution explorer. This makes it difficult to edit the MSBuild XML of a shared project when we need to.","title":"Introduction"},{"location":"utilities/edit-shared-project-items/#editing-shared-project-items","text":"Included in MFractor for Visual Studio Mac is an Edit Shared Project Items solution explorer action; we can use this to open the .projitems for a shared project in the MSBuild editor. To open the .projitems items for a shared project: Right click on a shared project in the solution explorere. Navigate to Tools . Select Edit Shared Project Items . This will open the .projitems in the XML editor.","title":"Editing Shared Project Items"},{"location":"xamarin-forms/overview/","text":"Introduction MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite. Xamarin.Forms Features XAML Editor XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation. MVVM Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard. Search Static resource global search. Dynamic resource global search. AutomationID global search. Localisation Generating localisation infrastructure. Localising XAML files. Custom Renderers Finding custom renderers. Creating custom renderers. Custom Controls Creating bindable properties . Extracting XAML controls . Styles Extracting XAML styles. Style analysis. Value Converters Value converter wizard. Value converter analysis.","title":"Overview"},{"location":"xamarin-forms/overview/#introduction","text":"MFractor provides many, many tools and utilities that make building apps with Xamarin.Forms significantly easier. This section of the documentation outlines the features on offer for a Xamarin.Forms developer and how they improve your productivity. At a glance, these are the core features in MFractors Xamarin.Forms tool-suite.","title":"Introduction"},{"location":"xamarin-forms/overview/#xamarinforms-features","text":"","title":"Xamarin.Forms Features"},{"location":"xamarin-forms/overview/#xaml-editor","text":"XAML IntelliSense. 80+ XAML inspections. XAML Tooltips. Over 90 code actions for navigation, refactoring and code organisation.","title":"XAML Editor"},{"location":"xamarin-forms/overview/#mvvm","text":"Before diving into the MVVM feature suite, please read our Binding Context Resolution articles to understand how MFractor automatically resolves ViewModels for Views. Automatic ViewModel Detection for XAML pages . Data-binding analysis. Data-binding IntelliSense. View to ViewModel navigation shortcuts. MVVM Wizard.","title":"MVVM"},{"location":"xamarin-forms/overview/#search","text":"Static resource global search. Dynamic resource global search. AutomationID global search.","title":"Search"},{"location":"xamarin-forms/overview/#localisation","text":"Generating localisation infrastructure. Localising XAML files.","title":"Localisation"},{"location":"xamarin-forms/overview/#custom-renderers","text":"Finding custom renderers. Creating custom renderers.","title":"Custom Renderers"},{"location":"xamarin-forms/overview/#custom-controls","text":"Creating bindable properties . Extracting XAML controls .","title":"Custom Controls"},{"location":"xamarin-forms/overview/#styles","text":"Extracting XAML styles. Style analysis.","title":"Styles"},{"location":"xamarin-forms/overview/#value-converters","text":"Value converter wizard. Value converter analysis.","title":"Value Converters"},{"location":"xamarin-forms/tooltips/","text":"Introduction XAML Tooltips Grids Colors Thicknesses","title":"Tooltips"},{"location":"xamarin-forms/tooltips/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/tooltips/#xaml-tooltips","text":"","title":"XAML Tooltips"},{"location":"xamarin-forms/tooltips/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/tooltips/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/tooltips/#thicknesses","text":"","title":"Thicknesses"},{"location":"xamarin-forms/xaml-intellisense/","text":"TODO: An overview of MFractors XAML intellisense integration. Introduction IntelliSense Features Data-Binding Grids Static Resources Dynamic Resources Images Colors DataTriggers Setter's StackLayout's","title":"Xaml intellisense"},{"location":"xamarin-forms/xaml-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/xaml-intellisense/#intellisense-features","text":"","title":"IntelliSense Features"},{"location":"xamarin-forms/xaml-intellisense/#data-binding","text":"","title":"Data-Binding"},{"location":"xamarin-forms/xaml-intellisense/#grids","text":"","title":"Grids"},{"location":"xamarin-forms/xaml-intellisense/#static-resources","text":"","title":"Static Resources"},{"location":"xamarin-forms/xaml-intellisense/#dynamic-resources","text":"","title":"Dynamic Resources"},{"location":"xamarin-forms/xaml-intellisense/#images","text":"","title":"Images"},{"location":"xamarin-forms/xaml-intellisense/#colors","text":"","title":"Colors"},{"location":"xamarin-forms/xaml-intellisense/#datatriggers","text":"","title":"DataTriggers"},{"location":"xamarin-forms/xaml-intellisense/#setters","text":"","title":"Setter's"},{"location":"xamarin-forms/xaml-intellisense/#stacklayouts","text":"","title":"StackLayout's"},{"location":"xamarin-forms/analysis/overview/","text":"","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/automatic-viewmodel-detection/","text":"MFractor uses automatic ViewModel resolution to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention. Let's consider the following files: LoginPage.xaml - The XAML view. LoginPage.xaml.cs - The code behind for the XAML view. LoginViewModel - The a C# class that is the view model for the LoginPage view. Because these pages share the prefix Login and each has a distinct file extension or suffix, MFractor assumes the following relationships: The .xaml extension denotes that LoginPage.xaml is a xaml view. The .xaml.cs extension and the LoginPage component denotes that LoginPage.xaml.cs is the code behind implementation LoginPage view. The ViewModel suffix implies that LoginViewModel is a view model. When ViewModel is removed from LoginViewModel and Page is removed from LoginPage, the Login component implies that the LoginViewModel is related to the LoginPage XAML view and it's code behind file. MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that LoginViewModel will probably be the BindingContext for LoginPage. The Page - ViewModel naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM. The following suffixes are supported for XAML views: Page: EG LoginPage.xaml - LoginViewModel View: EG LoginView.xaml - LoginViewModel The following suffixes are supported for View Models. ViewModel: LoginPage.xaml - LoginViewModel PageModel: LoginView.xaml - LoginPageModel PageViewModel: LoginView.xaml - LoginPageViewModel Model: LoginView.xaml - LoginModel VM: LoginView.xaml - LoginVM PageVM: LoginView.xaml - LoginPageVM","title":"Automatic ViewModel Detection"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/","text":"Binding Context Evaluation In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} / This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml ContentPage xmlns:local= clr-namespace:MyApp;assembly=MyApp BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} / When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: Switch x:Name= mySwitch / Label BindingContext= {x:Reference mySwitch} IsVisible= {Binding IsToggled} / When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"BindingContext Evaluation"},{"location":"xamarin-forms/binding-context-resolution/binding-context-evaluation/#binding-context-evaluation","text":"In Xamarin.Forms, all views have the property BindingContext; this specifies the object that a view should data-bind with. When coding with XAML, we can use the x:Static markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context: Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} / This is known as the View Model Locator Pattern. We implement a static class named ViewModelLocator and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the View Model Locator Pattern has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent View Model Locator article. For example, given a XAML page named LoginPage, we can explicitly provide an instance of LoginViewModel as the binding context like so: ViewModelLocator.cs public namespace MyApp { public static class ViewModelLocator { public static readonly LoginViewModel LoginViewModel = new LoginViewModel(); } } LoginPage.xaml ContentPage xmlns:local= clr-namespace:MyApp;assembly=MyApp BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} / When MFractor starts analysis on LoginPage.xaml, it will check if any BindingContext properties have been assigned to. As the root ContentPage assigns a binding context, it will inspect the value component of the BindingContext attribute, check if it is a XAML expression and then evaluate it for the return type. For the {x:Static local:ViewModelLocator.LoginViewModel} expression, MFractor will resolve the ViewModelLocator class in the local namespace and then grab the C# type of the LoginViewModel property. This informs MFractor that the page will be bound to a LoginViewModel instance and therefore to analyse all Binding expressions against the LoginViewModel type. Explicit binding context resolution will also work when referencing another element using x:Reference expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so: Switch x:Name= mySwitch / Label BindingContext= {x:Reference mySwitch} IsVisible= {Binding IsToggled} / When MFractor analyses the {Binding IsToggled} expression, it will evaluate the {x:Reference mySwitch} expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch). Explicit binding context resolution will always override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the BindingContext property then MFractor will use the BindingContext return type instead of the implicit Mvvm relationship.","title":"Binding Context Evaluation"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/","text":"Cross Project Binding Context Resolution If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewModelsProjectName value= TODO: Insert the name of your view models project as it appears in the solution explorer / /configure /mfractor In the project that contains your view models, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewsProjectName value= TODO: Insert the name of your views project as it appears in the solution explorer / /configure /mfractor","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/cross-project-binding-context-resolution/#cross-project-binding-context-resolution","text":"If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction. Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution. To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project. In the project that contains your views, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewModelsProjectName value= TODO: Insert the name of your view models project as it appears in the solution explorer / /configure /mfractor In the project that contains your view models, create a file named app.mfc.xml with the following content: ?xml version= 1.0 encoding= UTF-8 ? mfractor configure id= com.mfractor.configuration.forms.mvvm_resolution property name= ViewsProjectName value= TODO: Insert the name of your views project as it appears in the solution explorer / /configure /mfractor","title":"Cross Project Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/","text":"Data Template Binding Context Resolution Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: ListView ItemsSource= {Binding Contacts} ListView.ItemTemplate DataTemplate TextCell Text= {Binding DisplayName} / /DataTemplate /ListView.ItemTemplate /ListView The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"DataTemplate Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/data-template-binding-context-resolution/#data-template-binding-context-resolution","text":"Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a DataTemplate to specify the view appearance of each instance provided through the ItemsSource property. MFractor will attempt to infer the BindingContext for a data templates view by resolving the ItemsSource property on the wrapping view. Consider the following code: ListView ItemsSource= {Binding Contacts} ListView.ItemTemplate DataTemplate TextCell Text= {Binding DisplayName} / /DataTemplate /ListView.ItemTemplate /ListView The inner DataTemplate has a TextCell where the Text property is provided by the binding expression {Binding DisplayName}. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the ItemsSource property and evaluate the expression. When the return type is an IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.","title":"Data Template Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/design-time-binding-context-attribute/","text":"It's also possible to explicitly specify a desired binding context by applying the DesignTimeBindingContext attribute to the code behind class. To get started, add the following code file to your project: DesignTimeBindingContextAttribute.cs using System; namespace MyApp.Attributes { /// summary /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context. /// /summary [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class DesignTimeBindingContextAttribute : Attribute { /// summary /// Specifies the design time binding context using a fully qualified type name. /// /// For example: MyApp.ViewModels.LoginViewModel. /// /summary /// param name= typeName The fully qualified type name for the design time binding context. /param public DesignTimeBindingContextAttribute(string typeName) { } /// summary /// Specifies the design time binding context using typeof(). /// /// For example: typeof(LoginViewModel) /// /summary /// param name= type The see cref= System.Type / for the design time binding context, using typeof(). /param public DesignTimeBindingContextAttribute(Type type) { } } } Next, apply this attribute onto the code-behind class for your XAML file: Applying By Type [DesignTimeBindingContext(typeof(MyBindingContext))] Applying By String [DesignTimeBindingContext(\"MyApp.MyBindingContext\")] Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.","title":"Using The DesignTimeBindingContextAttribute"},{"location":"xamarin-forms/binding-context-resolution/overview/","text":"Binding Context Resolution MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article. Resolution Methods MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Overview"},{"location":"xamarin-forms/binding-context-resolution/overview/#binding-context-resolution","text":"MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaluate the correct binding context for a given node. So, what is a binding context? When using the Model-View-ViewModel architecture pattern, views use a Binding Context to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through data binding; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts The MVVM Pattern article.","title":"Binding Context Resolution"},{"location":"xamarin-forms/binding-context-resolution/overview/#resolution-methods","text":"MFractor supports several methods of binding context resolution: Binding Context Evaluation Automatic View Model Detection The DesignTimeBindingContextAttribute DataTemplate Binding Context Resolution Cross Project Binding Context Resolution","title":"Resolution Methods"},{"location":"xamarin-forms/code-actions/overview/","text":"","title":"Overview"},{"location":"xamarin-forms/colors/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/colors/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/","text":"Generate the C# code to declare a new attached property declaration Introduction In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached( HasShadow , typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example Label local:MyClass.HasShadow= true / One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Attached Property Wizard To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#introduction","text":"In Xamarin.Forms, attached properties are special properties declared on any class that can be consumed in XAML to provide specific, additional behaviour to a XAML element. One of the best examples of an attached property is the Grid.Row , Grid.RowSpan , Grid.Column and Grid.ColumnSpan properties. These properties allow grid row and column information to be \"attached\" to any XAML element without the element having knowledge of the Grid layout. At a minimum, attached properties are composed of three parts: The attached property declaration. This must be a created via the BindableProperty.CreateAttached factory method. The get method for the property. This must be a static method named Get[Name] that returns [Type] with a single parameter of BindableObject . The set method for the property. This must be a static method named Set[Name] that returns void with two parameters of BindableObject, [Type] . Attached Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.CreateAttached( HasShadow , typeof(bool), typeof(MyClass), default(bool)); public static bool GetHasShadow(BindableObject target) { return (bool)target.GetValue(HasShadowProperty); } public static void SetHasShadow(BindableObject target, bool value) { target.SetValue(HasShadowProperty, value); } Usage Example Label local:MyClass.HasShadow= true / One of the main difficulties with attached properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#using-the-attached-property-wizard","text":"To open the attached property wizard, press Alt+Return within the body any C# class. In the code actions menu that opens, choose Create an attached property to launch the wizard. Attached Property Wizard The attached property wizard consists of the following parts: Name : The name of the new attached property. Type : The fully qualified type name for the attached properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of class that declared this attached property. On the right hand side of the wizard is a preview of the code that will be created. To create the new attached property, enter the name and type of the new property and then press Create Attached Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Attached Property Wizard"},{"location":"xamarin-forms/custom-controls/attached-property-wizard/#automatic-type-inference","text":"The attached property wizard supports Automatic Type Inference based on the name that is provided to the wizard. Please see Bindable Property Wizard - Automatic Type Inference for a full breakdown of this feature.","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/","text":"Generate the C# code to declare a new bindable property for a custom control Introduction When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get = (bool)GetValue(HasShadowProperty); set = SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property. Using The Bindable Property Wizard To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret. Automatic Type Inference One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#introduction","text":"When creating a custom control for Xamarin.Forms, bindable properties expose CLR properties that a consumer of the control can data-bind to using the Binding markup extension. EG: Text=\"{Binding Welcome}\" . Bindable properties extend the default behaviour of CLR properties by adding the follow functionality: Validation of incoming property values. Notifications of property changes. Default value support. Value coercion to force the property to revaluate. At a minimum, bindable properties are composed of two parts: The bindable property declaration. This is must be created via the BindableProperty.Create factory method. The instance property declaration. Bindable Property Example public static readonly BindableProperty HasShadowProperty = BindableProperty.Create(nameof(HasShadow), typeof(bool), typeof(HelloWorld), default(bool)); public bool HasShadow { get = (bool)GetValue(HasShadowProperty); set = SetValue(HasShadowProperty, value); } One of the main difficulties with bindable properties is remembering the full syntax and correct structure for a new property. To simplify their creation, the wizard generates the C# code for a new attached property.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#using-the-bindable-property-wizard","text":"To open the bindable property wizard, press Alt+Return within the body a C# class that inherits from Xamarin.Forms.VisualElement . In the code actions menu that opens, choose Create a bindable property to launch the wizard. Bindable Property Wizard The bindable property wizard consists of the following parts: Name : The name of the new bindable property. Type : The fully qualified type name for the bindable properties type. Defaults to System.Object , however, the wizard will attempt to infer the desired type based on the Name input. See Automatic Type Inference . Control Type : The type of control that this bindable property targets. Defaults to the control type where the wizard was launched. Exception Handler : A statement that handles any exception thrown during the application of a new property value. On the right hand side of the wizard is a preview of the code that the wizard will create. To create the new bindable property, enter the name and type of the new property and then press Create Bindable Property . This will insert the generated code into the class at the location of the caret.","title":"Using The Bindable Property Wizard"},{"location":"xamarin-forms/custom-controls/bindable-property-wizard/#automatic-type-inference","text":"One of the most powerful aspects of the bindable wizard is it's ability to inspect the Name and infer what the property type is likely to be. Once you adjust to this feature, this allows you to enter the desired name of the property and MFractor will usually guess the correct property type. This dramatically simplifies and speeds up the process of creating new bindable properties. Here is a full list of the rules and output types the wizard uses: Bool : Name starts with: is , can , has , allows , accepts . Name ends with: boolean , bool , enabled . String : Name ends with: text , label , string , message , character . Double : Name starts with: double . Name ends with: decimal . Char : Name starts with: char . Enum : Name ends with: enum . Xamarin.Forms.ImageSource : Name ends with: image , icon , picture , photo . EventHandler : Name ends with: callback , event . System.IO.FileInfo : Name ends with: file . System.Windows.Input.ICommand : Name ends with: command . System.DateTime : Name starts with: date , time . Name ends with: date , time . System.TimeSpan : Name ends with: timespan . Xamarin.Forms.Color : Name ends with: color , colour .","title":"Automatic Type Inference"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/","text":"Move a XAML layout usage into its own reusable custom control Introduction When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control. Using The Extract Control Refactoring To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Extracting Custom Controls"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#introduction","text":"When developing user interfaces in XAML, it's common to have similiar or even identical XAML blocks. These duplicate code-blocks are ideal candidates to be refactored into a custom control that is reusable. Creating custom controls simplifies your code base and increases it's ease of maintainbility. To help you simplify your XAML, MFractor provides an Extract XAML Control refactoring to move a layout into it's own re-usable custom control.","title":"Introduction"},{"location":"xamarin-forms/custom-controls/extracting-custom-controls/#using-the-extract-control-refactoring","text":"To use the extract control refactoring, press Alt+Return when the caret is at a layout element (IE: A Grid , StackLayout etc) and then choose Extract into new XAML control . In Visual Studio Mac, right click on the layout element, then choose Refactor and then Extract into new XAML control . This will launch the the extract control dialog: The extract control window is made up of the following components: Name : The name of the new custom control. Project : The project that the new custom control will be placed within. By default, this is the project where the refactoring was triggered. Folder : The folder path where the new custom control will be placed. By default this is Controls . You may enter a folder path relative to the root of the selected Project and MFractor will generate that folder path. The right hand panel of the extract control window displays a preview of the code that the wizard will generate. Here you can toggle between the .xaml and .xaml.cs file that the refactoring will generate. To finish extracting the control, click Generate and MFractor will create a new .xaml and .xaml.cs file for that control and replace the original XAMl with a reference to the new control.","title":"Using The Extract Control Refactoring"},{"location":"xamarin-forms/custom-renderers/find-custom-renderers/","text":"Coming soon TODO: Discuss how to use the Find Custom Renderers feature.","title":"Find custom renderers"},{"location":"xamarin-forms/custom-renderers/generate-custom-renderers/","text":"","title":"Generate custom renderers"},{"location":"xamarin-forms/dynamic-resources/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/dynamic-resources/navigation/","text":"","title":"Navigation"},{"location":"xamarin-forms/dynamic-resources/search/","text":"","title":"Search"},{"location":"xamarin-forms/dynamic-resources/tooltips/","text":"","title":"Tooltips"},{"location":"xamarin-forms/grids/analysis/","text":"","title":"Analysis"},{"location":"xamarin-forms/grids/code-actions/","text":"","title":"Code actions"},{"location":"xamarin-forms/grids/intellisense/","text":"","title":"Intellisense"},{"location":"xamarin-forms/grids/tooltips/","text":"","title":"Tooltips"},{"location":"xamarin-forms/search/automationid-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Automationid search"},{"location":"xamarin-forms/search/automationid-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/automationid-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/dynamic-resource-search/","text":"Search your solution for AutomationID declarations Introduction Using AutomationID Search","title":"Dynamic resource search"},{"location":"xamarin-forms/search/dynamic-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/dynamic-resource-search/#using-automationid-search","text":"","title":"Using AutomationID Search"},{"location":"xamarin-forms/search/static-resource-search/","text":"Search your solution for static resources Introduction Dynamic Resource Overview Declaraing Dynamic Resources Using Dynamic Resources Using Dynamic Resource Search","title":"Static resource search"},{"location":"xamarin-forms/search/static-resource-search/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/search/static-resource-search/#dynamic-resource-overview","text":"","title":"Dynamic Resource Overview"},{"location":"xamarin-forms/search/static-resource-search/#declaraing-dynamic-resources","text":"","title":"Declaraing Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resources","text":"","title":"Using Dynamic Resources"},{"location":"xamarin-forms/search/static-resource-search/#using-dynamic-resource-search","text":"","title":"Using Dynamic Resource Search"},{"location":"xamarin-forms/value-converters/value-converter-analysis/","text":"","title":"Value converter analysis"},{"location":"xamarin-forms/value-converters/value-converter-wizard/","text":"Quickly create a Value Converter and reference it on your XAML code Introduction Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic. Using the Wizard The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows: Name and Location Parameters Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters . Type Parameters Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object . Input Type Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method. Output Type Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned. Parameter Type Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: Label Text= {Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'} / The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type. Optional XML Entry Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: ResourceDictionary converters:BoolNegationConverter x:Key= boolNegationConverter / /ResourceDictionary MFractor will also take care of adding the required namespace imports to the file. Default Code Snippet This is the default code snippet of a Value Converter file. using System; using System.Globalization; using Xamarin.Forms; namespace [DefaultProjectNamespace].Converters { [ValueConversion(typeof(object), typeof(object))] public class $name$ : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is object == false) { return default(object); } var input = (object)value; var param = (object)parameter; // TODO: Put your value conversion logic here. return default(object); } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); } } }","title":"Value Converter Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#introduction","text":"Value Converters extends Xamarin.Forms binding engine by allowing custom logic to run when you need to bind a value from a source in which the type is different from the destiation where it will be consumed. The official documentation provides further information about the feature itself. To create a Value Converter you need to create a class that implements the IValueConverter interface and then reference it on the Resources Dictionary of the Page or Application that you wish to use it. That's where the Value Converter Wizard comes in, to facilitate this creation and reference, by providing a stub of the converter and let you focus on the conversion logic.","title":"Introduction"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#using-the-wizard","text":"The Wizard can be invoked from MFractor Main Menu, under the Wizards sub-menu. Notice that the option will only appear if the loaded solution contains a Xamarin.Forms project. The Wizard Window is divided in two sections: parameters and preview. The parameters control the behavior of the newly created Value Converter and the options are as follows:","title":"Using the Wizard"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#name-and-location-parameters","text":"Name : Required. The name of the Value Converter, will also be used to name the file that will hold the code. By convetion Converters adds a Converter suffix to its name. Infer Input/Output Types : MFractor can infer the input and output data types based on the name you set for the converter. As an example, if you name a converter like IntToBoolConverter it will infer that the input parameter is of type int and the output parameter will be a bool . Folder : the folder where the converter will be created inside the project. Defaults to Converters .","title":"Name and Location Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#type-parameters","text":"Optionally you can specify the types for the arguments you can use to process a value converter. The default code snippet for generating a value converter adds type-casting to the choosen types for each argument. Those fields expects a valid .NET/C# data-type Those parameters are optional and if omitted will default to object .","title":"Type Parameters"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#input-type","text":"Represents the type of the input parameter that is the data that is been passed to the converter from the source binding property. As an example, if your View Model declares a string property and it's bound to a property that uses your converter, this value is passed through value argument of the Convert method. In the default code snippet the value argument will be cast to the input local variable on the method.","title":"Input Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#output-type","text":"Represents the type of the output parameter, that is the data that will be returned from the converter. This information is used to feed the ValueConversion attribute that is added to your Value Converter on the default Code Snippet. Even though not being used directly in the method body, this information is used by the Analyzers to identify when you used a converter on a property which the type is different from what is expected to be returned.","title":"Output Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#parameter-type","text":"Value converters allow passing an additional parameter that can be used for further customize its behavior. Parameters are passed along with the binding declaraction on the property, such as: Label Text= {Binding Text, Converter={StaticResource converterReference}, ConverterParameter='parameter data'} / The value parameter data is passed through the parameter argument on the Convert method. In this case the value is a string, but you can also bind to the converter parameter itself. The Parameter Type field allows you to specify the type of this parameter and it will be made available through the param local variable on the method body cast to this type.","title":"Parameter Type"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#optional-xml-entry","text":"Create XML Entry : check this option for the wizard to add an entry to the Resource Dictionary of a Page XAML file or App.xaml file to allow access to the newly created Value Converter. Add XAML Entry To : select the file to which you want to add the entry of the new Value Converter. Only supported files (.xaml) will be listed here. If you check this option and select a destination file MFractor will add a declaration for the Value Converter on the ResourceDictionary of that file, such as: ResourceDictionary converters:BoolNegationConverter x:Key= boolNegationConverter / /ResourceDictionary MFractor will also take care of adding the required namespace imports to the file.","title":"Optional XML Entry"},{"location":"xamarin-forms/value-converters/value-converter-wizard/#default-code-snippet","text":"This is the default code snippet of a Value Converter file. using System; using System.Globalization; using Xamarin.Forms; namespace [DefaultProjectNamespace].Converters { [ValueConversion(typeof(object), typeof(object))] public class $name$ : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is object == false) { return default(object); } var input = (object)value; var param = (object)parameter; // TODO: Put your value conversion logic here. return default(object); } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); } } }","title":"Default Code Snippet"},{"location":"xamarin-forms/working-with-styles/extracting-styles/","text":"","title":"Extracting styles"},{"location":"xamarin-forms/working-with-styles/matching-style-analysis/","text":"","title":"Matching style analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-analysis/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Data Binding Analysis"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/","text":"Introduction Using Data-Binding IntelliSense","title":"Data Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#introduction","text":"","title":"Introduction"},{"location":"xamarin-forms/working-with-viewmodels/data-binding-intellisense/#using-data-binding-intellisense","text":"","title":"Using Data-Binding IntelliSense"},{"location":"xamarin-forms/working-with-viewmodels/generating-properties-and-commands/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"Generating Properties/Commands"},{"location":"xamarin-forms/working-with-viewmodels/mvvm-wizard/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"MVVM Wizard"},{"location":"xamarin-forms/working-with-viewmodels/view-viewmodel-navigation/","text":"\ud83d\udd28\ud83d\udd28\ud83d\udd28 Under construction \ud83d\udd28\ud83d\udd28\ud83d\udd28","title":"View-ViewModel Navigation"}]}